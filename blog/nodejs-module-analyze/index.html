<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width,
                   height=device-height,
                   initial-scale=1.0,
                   maximum-scale=1.0,
                   user-scalable=no"
    />
    <meta name="author"
          content="ecomfe">
    
    
    <title>结合源码分析 Node.js 模块加载与运行原理 | EFE Tech</title>
    

    <link rel="stylesheet" href="/css/page.css">
    <link rel="stylesheet" href="/css/code.css">
    <link rel="stylesheet" href="/css/font-awesome.css">
</head>
<body>

<aside>
    <a class="home" href="/" title="EFE Home"><abbr title="EFE">EFE</abbr></a>
    <nav>
        <a href="https://github.com/ecomfe/spec" target="_blank">SPECS</a>
        <a href="/projects/">PROJECTS</a>
        <!--a href="/about.html">ABOUT</a-->
    </nav>
    <ul class="product-overview">
        <li><a target="_blank" href="https://ecomfe.github.io/san/"> <span class="product-overview-title">SAN</span> <span class="product-overview-desc">- MVVM 组件框架</span></a></li>
        <li><a target="_blank" href="http://fecs.baidu.com/"> <span class="product-overview-title">FECS</span> <span class="product-overview-desc">- 前端代码风格检查套件</span></a></li>
        <li><a target="_blank" href="http://echarts.baidu.com/"> <span class="product-overview-title">ECharts</span> <span class="product-overview-desc">- 数据可视化图表库</span></a></li>
        <li><a target="_blank" href="https://github.com/ecomfe/esl"><span class="product-overview-title">ESL</span> <span class="product-overview-desc"> - AMD Loader</span></a></li>
        <li><a target="_blank" href="http://ecomfe.github.io/edp/"><span class="product-overview-title">EDP</span> <span class="product-overview-desc"> - 前端开发平台</span></a></li>
        <li><a target="_blank" href="http://ecomfe.github.io/est/"><span class="product-overview-title">EST</span> <span class="product-overview-desc"> - 基于 Less 的样式工具库</span></a></li>
        <li><a target="_blank" href="http://ecomfe.github.io/saber/"><span class="product-overview-title">Saber</span> <span class="product-overview-desc"> - 移动 SPA 项目解决方案</span></a></li>
        <li><a target="_blank" href="http://ecomfe.github.io/saber/"><span class="product-overview-title">Rebas</span> <span class="product-overview-desc"> - 基于 NodeJS 的同构解决方案</span></a></li>
        <li><a target="_blank" href="https://github.com/ecomfe/rider"><span class="product-overview-title">Rider</span> <span class="product-overview-desc"> - 移动样式工具库</span></a></li>
        <li><a target="_blank" href="https://github.com/ecomfe/er"><span class="product-overview-title">ER</span> <span class="product-overview-desc"> - SPA 应用框架</span></a></li>
        <li><a target="_blank" href="https://github.com/ecomfe/esui"><span class="product-overview-title">ESUI</span> <span class="product-overview-desc"> - UI 组件库</a></span></li>
        <li><a target="_blank" href="http://ecomfe.github.io/etpl/"><span class="product-overview-title">ETpl</span> <span class="product-overview-desc"> - 灵活、高性能的模板引擎</span></a></li>
        <li><a target="_blank" href="https://github.com/BE-FE/iSlider"><span class="product-overview-title">iSlider</span> <span class="product-overview-desc"> - 轻量、高性能的移动滑动方案</span></a></li>
        <li><a target="_blank" href="http://tushuo.baidu.com/"><span class="product-overview-title">图说</span> <span class="product-overview-desc"> - 可视化数据分享平台</span></a></li>
        <li><a target="_blank" href="http://ecomfe.github.io/fontmin"><span class="product-overview-title">Fontmin</span> <span class="product-overview-desc"> - 首个纯 JS 字体子集化方案</span></a></li>
    </ul>
    <p class="efe-desc">百度EFE（Excellent FrontEnd）技术体系，前身是ECOM前端团队，后经过技术的发展，逐渐形成一套完善的前端技术体系。<br><br>EFE技术体系现由多个遵循该技术体系的前端团队所组成。E(Excellent)代表我们追求卓越的技术态度。</p>

    
    <dl class="tags">
        <dt>Tags</dt>
        
            <dd><a href="/tags/JavaScript/">JavaScript</a> <small>(30)</small></dd>
        
            <dd><a href="/tags/ECharts/">ECharts</a> <small>(20)</small></dd>
        
            <dd><a href="/tags/数据可视化/">数据可视化</a> <small>(17)</small></dd>
        
            <dd><a href="/tags/模块化/">模块化</a> <small>(9)</small></dd>
        
            <dd><a href="/tags/CSS/">CSS</a> <small>(8)</small></dd>
        
            <dd><a href="/tags/教程/">教程</a> <small>(7)</small></dd>
        
            <dd><a href="/tags/AMD/">AMD</a> <small>(6)</small></dd>
        
            <dd><a href="/tags/新版本/">新版本</a> <small>(6)</small></dd>
        
            <dd><a href="/tags/ESNext/">ESNext</a> <small>(6)</small></dd>
        
            <dd><a href="/tags/Lint/">Lint</a> <small>(4)</small></dd>
        
            <dd><a href="/tags/MVVM/">MVVM</a> <small>(4)</small></dd>
        
            <dd><a href="/tags/Mobile/">Mobile</a> <small>(4)</small></dd>
        
            <dd><a href="/tags/font/">font</a> <small>(4)</small></dd>
        
            <dd><a href="/tags/San/">San</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/ES6/">ES6</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/HTML/">HTML</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/优化/">优化</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/NodeJS/">NodeJS</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/React-Native/">React Native</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/Hint/">Hint</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/图片/">图片</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/tool/">tool</a> <small>(3)</small></dd>
        
            <dd><a href="/tags/promise/">promise</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/IoC/">IoC</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/用户体验/">用户体验</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/地图/">地图</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/ESL/">ESL</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/中文字体/">中文字体</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/GL/">GL</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/Less/">Less</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/重构/">重构</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/practice/">practice</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/fixed/">fixed</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/设计/">设计</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/mixin/">mixin</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/React/">React</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/JS-Engine/">JS Engine</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/Objective-C/">Objective C</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/DI/">DI</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/Check/">Check</a> <small>(2)</small></dd>
        
            <dd><a href="/tags/依赖注入/">依赖注入</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/OO/">OO</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Isomorphic/">Isomorphic</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/可视分析/">可视分析</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/高阶组合/">高阶组合</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Layout/">Layout</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/硬件加速/">硬件加速</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Hardware-Accelerated/">Hardware Accelerated</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/subtree/">subtree</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/submoudle/">submoudle</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/git/">git</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Saucelabs/">Saucelabs</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/1px/">1px</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/tesing/">tesing</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Travis-CI/">Travis CI</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/HTTP/">HTTP</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/REST/">REST</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/float/">float</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/ETpl/">ETpl</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/模板引擎/">模板引擎</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/弹性滚动/">弹性滚动</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/MVC/">MVC</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/beautify/">beautify</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/fix/">fix</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/format/">format</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/check/">check</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/MVP/">MVP</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/构建/">构建</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/3D/">3D</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/ECharts-X/">ECharts-X</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Ionic/">Ionic</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/SPA/">SPA</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/水球图/">水球图</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/直方图/">直方图</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Number/">Number</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/IEEE-754/">IEEE_754</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/iOS/">iOS</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/字体/">字体</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/图标/">图标</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/SVG/">SVG</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/sticky/">sticky</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/响应式/">响应式</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/预处理器/">预处理器</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/工具疲劳/">工具疲劳</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Sass/">Sass</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Stylus/">Stylus</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/文本截断/">文本截断</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/ellipsis/">ellipsis</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/text-overflow/">text-overflow</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/algorithm/">algorithm</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/VitualDOM/">VitualDOM</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Preact/">Preact</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/扩展性/">扩展性</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/高阶函数/">高阶函数</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/forEach/">forEach</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/baidu网盘/">baidu网盘</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Android/">Android</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/venn/">venn</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/VIM/">VIM</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Completion/">Completion</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/color/">color</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/前端设计感/">前端设计感</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/windows/">windows</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/XHR/">XHR</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/baidubce/">baidubce</a> <small>(1)</small></dd>
        
            <dd><a href="/tags/Coveralls/">Coveralls</a> <small>(1)</small></dd>
        
    </dl>


        <dl class="links">
        <dt>Links</dt>
        <dd><a target="_blank" href="http://fex.baidu.com/">Baidu FEX</a></dd>
        <dd><a target="_blank" href="http://eux.baidu.com/">Baidu EUX</a></dd>
        <dd><a target="_blank" href="http://ued.taobao.org/blog/">Taobao UED</a></dd>
        <dd><a target="_blank" href="http://www.alloyteam.com/">Tencent AlloyTeam</a></dd>
        <dd><a target="_blank" href="http://isux.tencent.com/">Tencent ISUX</a></dd>
        <dd><a target="_blank" href="http://ued.ctrip.com/blog/?cat=11">CTrip UED</a></dd>
        <dd><a target="_blank" href="http://www.75team.com/">75Team</a></dd>
    </ul>

</aside>

<article>
    
        <h1>结合源码分析 Node.js 模块加载与运行原理</h1>
    

    <div class="article-meta">
        <span class="article-author"><i class="fa fa-pencil"></i>
    
        <a target="_blank" href="https://github.com/mly-zju/blog" title="马龄阳">马龄阳</a>
    
</span>

        <time datetime="2018-06-13T16:00:00.000Z" itemprop="datePublished"><i class="fa fa-clock-o"></i> 2018-06-14</time>

        
    
    <span class="article-tags"><i class="fa fa-tag"></i> <a href="/tags/NodeJS/">NodeJS</a>, <a href="/tags/模块化/">模块化</a></span>


    </div>

    
        <p>Node.js 的出现，让 JavaScript 脱离了浏览器的束缚，进入了广阔的服务端开发领域。而 Node.js 对 CommonJS 模块化规范的引入，则更是让 JavaScript成为了一门真正能够适应大型工程的语言。</p>
<p>在 Node.js 中使用模块非常简单，我们日常开发中几乎都有过这样的经历：写一段 JavaScript 代码，require 一些想要的包，然后将代码产物 exports 导出。但是，对于 Node.js 模块化背后的加载与运行原理，我们是否清楚呢。首先抛出以下几个问题：</p>
<ul>
<li>Node.js 中的模块支持哪些文件类型？</li>
<li>核心模块和第三方模块的加载运行流程有什么不同？</li>
<li>除了 JavaScript 模块以外，怎样去写一个 C/C++ 扩展模块？</li>
<li>……</li>
</ul>
<p>本篇文章，就会结合 Node.js 源码，探究一下以上这些问题背后的答案。</p>
<a id="more"></a>
<h3 id="node.js-模块类型">1. Node.js 模块类型</h3>
<p>在 Node.js 中，模块主要可以分为以下几种类型：</p>
<ul>
<li>核心模块：包含在 Node.js 源码中，被编译进 Node.js 可执行二进制文件 JavaScript 模块，也叫 native 模块，比如常用的 http, fs 等等</li>
<li>C/C++ 模块，也叫 built-in 模块，一般我们不直接调用，而是在 native module 中调用，然后我们再 require</li>
<li>native 模块，比如我们在 Node.js 中常用的 buffer，fs，os 等 native 模块，其底层都有调用 built-in 模块。</li>
<li>第三方模块：非 Node.js 源码自带的模块都可以统称第三方模块，比如 express，webpack 等等。
<ul>
<li>JavaScript 模块，这是最常见的，我们开发的时候一般都写的是 JavaScript 模块</li>
<li>JSON 模块，这个很简单，就是一个 JSON 文件</li>
<li>C/C++ 扩展模块，使用 C/C++ 编写，编译之后后缀名为 .node</li>
</ul></li>
</ul>
<p>本篇文章中，我们会一一涉及到上述几种模块的加载、运行原理。</p>
<h3 id="node.js-源码结构一览">2. Node.js 源码结构一览</h3>
<p>这里使用 Node.js 6.x 版本源码为例子来做分析。去 github 上下载相应版本的 Node.js 源码，可以看到代码大体结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── AUTHORS</span><br><span class="line">├── BSDmakefile</span><br><span class="line">├── BUILDING.md</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── CODE_OF_CONDUCT.md</span><br><span class="line">├── COLLABORATOR_GUIDE.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── GOVERNANCE.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── android-configure</span><br><span class="line">├── benchmark</span><br><span class="line">├── common.gypi</span><br><span class="line">├── configure</span><br><span class="line">├── deps</span><br><span class="line">├── doc</span><br><span class="line">├── lib</span><br><span class="line">├── node.gyp</span><br><span class="line">├── node.gypi</span><br><span class="line">├── src</span><br><span class="line">├── test</span><br><span class="line">├── tools</span><br><span class="line">└── vcbuild.bat</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>./lib</code>文件夹主要包含了各种 JavaScript 文件，我们常用的 JavaScript native 模块都在这里。</li>
<li><code>./src</code>文件夹主要包含了 Node.js 的 C/C++ 源码文件，其中很多 built-in 模块都在这里。</li>
<li><code>./deps</code>文件夹包含了 Node.js 依赖的各种库，典型的如 v8，libuv，zlib 等。</li>
</ul>
<p>我们在开发中使用的 release 版本，其实就是从源码编译得到的可执行文件。如果我们想要对 Node.js 进行一些个性化的定制，则可以对源码进行修改，然后再运行编译，得到定制化的 Node.js 版本。这里以 Linux 平台为例，简要介绍一下 Node.js 编译流程。</p>
<p>首先，我们需要认识一下编译用到的组织工具，即 <code>gyp</code>。Node.js 源码中我们可以看到一个 <code>node.gyp</code>，这个文件中的内容是由 python 写成的一些 JSON-like 配置，定义了一连串的构建工程任务。我们举个例子，其中有一个字段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &apos;target_name&apos;: &apos;node_js2c&apos;,</span><br><span class="line">      &apos;type&apos;: &apos;none&apos;,</span><br><span class="line">      &apos;toolsets&apos;: [&apos;host&apos;],</span><br><span class="line">      &apos;actions&apos;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &apos;action_name&apos;: &apos;node_js2c&apos;,</span><br><span class="line">          &apos;inputs&apos;: [</span><br><span class="line">            &apos;&lt;@(library_files)&apos;,</span><br><span class="line">            &apos;./config.gypi&apos;,</span><br><span class="line">          ],</span><br><span class="line">          &apos;outputs&apos;: [</span><br><span class="line">            &apos;&lt;(SHARED_INTERMEDIATE_DIR)/node_natives.h&apos;,</span><br><span class="line">          ],</span><br><span class="line">          &apos;conditions&apos;: [</span><br><span class="line">            [ &apos;node_use_dtrace==&quot;false&quot; and node_use_etw==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/notrace_macros.py&apos; ]</span><br><span class="line">            &#125;],</span><br><span class="line">            [&apos;node_use_lttng==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/nolttng_macros.py&apos; ]</span><br><span class="line">            &#125;],</span><br><span class="line">            [ &apos;node_use_perfctr==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/perfctr_macros.py&apos; ]</span><br><span class="line">            &#125;]</span><br><span class="line">          ],</span><br><span class="line">          &apos;action&apos;: [</span><br><span class="line">            &apos;python&apos;,</span><br><span class="line">            &apos;tools/js2c.py&apos;,</span><br><span class="line">            &apos;&lt;@(_outputs)&apos;,</span><br><span class="line">            &apos;&lt;@(_inputs)&apos;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;, # end node_js2c</span><br></pre></td></tr></table></figure>
<p>这个任务主要的作用从名称 <code>node_js2c</code> 就可以看出来，是将 JavaScript 转换为 C/C++ 代码。这个任务我们下面还会提到。</p>
<p>首先编译 Node.js，需要提前安装一些工具：</p>
<ul>
<li>gcc 和 g++ 4.9.4 及以上版本</li>
<li>clang 和 clang++</li>
<li>python 2.6 或者 2.7，这里要注意，只能是这两个版本，不可以为python 3+</li>
<li>GNU MAKE 3.81 及以上版本</li>
</ul>
<p>有了这些工具，进入 Node.js 源码目录，我们只需要依次运行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configuration</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>即可编译生成可执行文件并安装了。</p>
<h3 id="从-node-index.js-开始">3. 从 <code>node index.js</code> 开始</h3>
<p>让我们首先从最简单的情况开始。假设有一个 index.js 文件，里面只有一行很简单的 <code>console.log('hello world')</code> 代码。当输入 <code>node index.js</code> 的时候，Node.js 是如何编译、运行这个文件的呢？</p>
<p>当输入 Node.js 命令的时候，调用的是 Node.js 源码当中的 main 函数，在 <code>src/node_main.cc</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node_main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;VersionHelpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span> *wargv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// windows下面的入口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// UNIX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Disable stdio buffering, it interacts poorly with printf()</span></span><br><span class="line">  <span class="comment">// calls elsewhere in the program (e.g., any logging from V8.)</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 关注下面这一行</span></span><br><span class="line">  <span class="keyword">return</span> node::Start(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个文件只做入口用，区分了 Windows 和 Unix 环境。我们以 Unix 为例，在 main 函数中最后调用了 <code>node::Start</code>，这个是在 <code>src/node.cc</code> 文件中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">NodeInstanceData <span class="title">instance_data</span><span class="params">(NodeInstanceType::MAIN,</span></span></span><br><span class="line">                                   uv_default_loop(),</span><br><span class="line">                                   argc,</span><br><span class="line">                                   <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>**&gt;(argv),</span><br><span class="line">                                   exec_argc,</span><br><span class="line">                                   exec_argv,</span><br><span class="line">                                   use_debug_agent);</span><br><span class="line">    StartNodeInstance(&amp;instance_data);</span><br><span class="line">    exit_code = instance_data.exit_code();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StartNodeInstance</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        Environment::<span class="function">AsyncCallbackScope <span class="title">callback_scope</span><span class="params">(env)</span></span>;</span><br><span class="line">        LoadEnvironment(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadEnvironment</span><span class="params">(Environment* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(),</span><br><span class="line">                                                        <span class="string">"bootstrap_node.js"</span>);</span><br><span class="line">    Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br><span class="line">    <span class="keyword">if</span> (try_catch.HasCaught())  &#123;</span><br><span class="line">        ReportException(env, try_catch);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The bootstrap_node.js file returns a function 'f'</span></span><br><span class="line">    CHECK(f_value-&gt;IsFunction());</span><br><span class="line">    Local&lt;Function&gt; f = Local&lt;Function&gt;::Cast(f_value);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f-&gt;Call(Null(env-&gt;isolate()), <span class="number">1</span>, &amp;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个文件比较长，在上面代码段里，只截取了我们最需要关注的流程片段，调用关系如下： <code>Start -&gt; StartNodeInstance -&gt; LoadEnvironment</code>。</p>
<p>在 <code>LoadEnvironment</code> 需要我们关注，主要做的事情就是，取出 <code>bootstrap_node.js</code> 中的代码字符串，解析成函数，并最后通过 <code>f-&gt;Call</code> 去执行。</p>
<p>OK，重点来了，从 Node.js 启动以来，我们终于看到了第一个 JavaScript 文件 <code>bootstrap_node.js</code>，从文件名我们也可以看出这个是一个入口性质的文件。那么我们快去看看吧，该文件路径为 <code>lib/internal/bootstrap_node.js</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/boostrap_node.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">process</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (process.argv[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = NativeModule.require(<span class="string">'path'</span>);</span><br><span class="line">      process.argv[<span class="number">1</span>] = path.resolve(process.argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">const</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      preloadModules();</span><br><span class="line">      run(Module.runMain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  startup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// bootstrap main module.</span></span><br><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Load the main module--the command line argument.</span></span><br><span class="line">  Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Handle any nextTicks added in the first tick of the program</span></span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这里我们依然关注主流程，可以看到，<code>bootstrap_node.js</code> 中，执行了一个 <code>startup()</code> 函数。通过 <code>process.argv[1]</code> 拿到文件名，在我们的 <code>node index.js</code> 中，<code>process.argv[1]</code> 显然就是 <code>index.js</code>，然后调用 <code>path.resolve</code> 解析出文件路径。在最后，<code>run(Module.runMain)</code> 来编译执行我们的 <code>index.js</code>。</p>
<p>而 <code>Module.runMain</code> 函数定义在 <code>lib/module.js</code> 中，在上述代码片段的最后，列出了这个函数，可以看到，主要是调用 <code>Module._load</code> 来加载执行 <code>process.argv[1]</code>。</p>
<p>下文我们在分析模块的 require 的时候，也会来到 <code>lib/module.js</code> 中，也会分析到 <code>Module._load</code>。<strong><em>因此我们可以看出，Node.js 启动一个文件的过程，其实到最后，也是 <code>require</code> 一个文件的过程，可以理解为是立即 require 一个文件。</em></strong>下面就来分析 require 的原理。</p>
<h3 id="模块加载原理的关键require">4. 模块加载原理的关键：require</h3>
<p>我们进一步，假设我们的 <code>index.js</code> 有如下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure>
<p>那么当执行这一句代码的时候，会发生什么呢？</p>
<p>require的定义依然在 <code>lib/module.js</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  assert(path, <span class="string">'missing path'</span>);</span><br><span class="line">  assert(<span class="keyword">typeof</span> path === <span class="string">'string'</span>, <span class="string">'path must be a string'</span>);</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>, <span class="comment">/* isMain */</span> <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>require</code> 方法定义在Module的原型链上。可以看到这个方法中，调用了 <code>Module._load</code>。</p>
<p>我们这么快就又来到了 <code>Module._load</code> 来看看这个关键的方法究竟做了什么吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    debug(<span class="string">'Module._load REQUEST %s parent: %s'</span>, request, parent.id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这段代码的流程比较清晰，具体说来：</p>
<ol style="list-style-type: decimal">
<li>根据文件名，调用 <code>Module._resolveFilename</code> 解析文件的路径</li>
<li>查看缓存 <code>Module._cache</code> 中是否有该模块，如果有，直接返回</li>
<li>通过 <code>NativeModule.nonInternalExists</code> 判断该模块是否为核心模块，如果核心模块，调用核心模块的加载方法 <code>NativeModule.require</code></li>
<li>如果不是核心模块，新创建一个 Module 对象，调用 <code>tryModuleLoad</code> 函数加载模块</li>
</ol>
<p>我们首先来看一下 <code>Module._resolveFilename</code>，看懂这个方法对于我们理解 Node.js 的文件路径解析原理很有帮助：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._findPath(request, paths, isMain);</span><br><span class="line">  <span class="keyword">if</span> (!filename) &#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + request + <span class="string">"'"</span>);</span><br><span class="line">    err.code = <span class="string">'MODULE_NOT_FOUND'</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Module._resolveFilename</code> 中调用了 <code>Module._findPath</code>，模块加载的判断逻辑实际上集中在这个方法中，由于这个方法较长，直接附上 github 该方法代码：</p>
<p><a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L158" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L158</a></p>
<p>可以看出，文件路径解析的逻辑流程是这样的：</p>
<ul>
<li>先生成 cacheKey，判断相应 cache 是否存在，若存在直接返回</li>
<li>如果 path 的最后一个字符不是 <code>/</code>：
<ul>
<li>如果路径是一个文件并且存在，那么直接返回文件的路径</li>
<li>如果路径是一个目录，调用 <code>tryPackage</code> 函数去解析目录下的 <code>package.json</code>，然后取出其中的 <code>main</code> 字段所写入的文件路径
<ul>
<li>判断路径如果存在，直接返回</li>
<li>尝试在路径后面加上 .js, .json, .node 三种后缀名，判断是否存在，存在则返回</li>
<li>尝试在路径后面依次加上 index.js, index.json, index.node，判断是否存在，存在则返回</li>
</ul></li>
<li>如果还不成功，直接对当前路径加上 .js, .json, .node 后缀名进行尝试</li>
</ul></li>
<li>如果 path 的最后一个字符是 <code>/</code>：
<ul>
<li>调用 <code>tryPackage</code> ，解析流程和上面的情况类似</li>
<li>如果不成功，尝试在路径后面依次加上 index.js, index.json, index.node，判断是否存在，存在则返回</li>
</ul></li>
</ul>
<p>解析文件中用到的 <code>tryPackage</code> 和 <code>tryExtensions</code> 方法的 github 链接： <a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L108" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L108</a> <a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L146" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L146</a></p>
<p>整个流程可以参考下面这张图： <img src="/blog/nodejs-module-analyze/process1.png" alt="process1"></p>
<p>而在文件路径解析完成之后，根据文件路径查看缓存是否存在，存在直接返回，不存在的话，走到 3 或者 4 步骤。</p>
<p>这里，在 3、4 两步产生了两个分支，即核心模块和第三方模块的加载方法不一样。由于我们假设了我们的 <code>index.js</code> 中为 <code>var http = require('http')</code>，http 是一个核心模块，所以我们先来分析核心模块加载的这个分支。</p>
<h4 id="核心模块加载原理">4.1 核心模块加载原理</h4>
<p>核心模块是通过 <code>NativeModule.require</code> 加载的，NativeModule的定义在 <code>bootstrap_node.js</code> 中，附上 github 链接： <a href="https://github.com/nodejs/node/blob/v6.x/lib/internal/bootstrap_node.js#L401" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/internal/bootstrap_node.js#L401</a></p>
<p>从代码中可以看到，<code>NativeModule.require</code> 的流程如下：</p>
<ol style="list-style-type: decimal">
<li>判断 cache 中是否已经加载过，如果有，直接返回 exports</li>
<li>新建 nativeModule 对象，然后缓存，并加载编译</li>
</ol>
<p>首先我们来看一下如何编译，从代码中看是调用了 <code>compile</code> 方法，而在 <code>NativeModule.prototype.compile</code> 方法中，首先是通过 <code>NativeModule.getSource</code> 获取了要加载模块的源码，那么这个源码是如何获取的呢？看一下 <code>getSource</code> 方法的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">NativeModule._source = process.binding(<span class="string">'natives'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">NativeModule.getSource = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NativeModule._source[id];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>直接从 <code>NativeModule._source</code> 获取的，而这个又是在哪里赋值的呢？在上述代码中也截取了出来，是通过 <code>NativeModule._source = process.binding('natives')</code> 获取的。</p>
<p>这里就要插入介绍一下 JavaScript native 模块代码是如何存储的了。Node.js 源码编译的时候，会采用 v8 附带的 js2c.py 工具，将 lib 文件夹下面的 js 模块的代码都转换成 C 里面的数组，生成一个 node_natives.h 头文件，记录这个数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> node &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> node_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> console_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> buffer_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct _native &#123;<span class="keyword">const</span> <span class="keyword">char</span> name;  <span class="keyword">const</span> <span class="keyword">char</span>* source;  <span class="keyword">size_t</span> source_len;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">native</span> <span class="title">natives</span>[] = &#123;</span></span><br><span class="line"></span><br><span class="line">  &#123; “node”, node_native, <span class="keyword">sizeof</span>(node_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“dgram”, dgram_native, <span class="keyword">sizeof</span>(dgram_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“console”, console_native, <span class="keyword">sizeof</span>(console_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“buffer”, buffer_native, <span class="keyword">sizeof</span>(buffer_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>而上文中 <code>NativeModule._source = process.binding('natives');</code> 的作用，就是取出这个 natives 数组，赋值给<code>NativeModule._source</code>，所以在 <code>getSource</code> 方法中，直接可以使用模块名作为索引，从数组中取出模块的源代码。</p>
<p>在这里我们插入回顾一下上文，在介绍 Node.js 编译的时候，我们介绍了 <code>node.gyp</code>，其中有一个任务是 <code>node_js2c</code>，当时笔者提到从名称看这个任务是将 JavaScript 转换为 C 代码，而这里的 natives 数组中的 C 代码，正是这个构建任务的产物。而到了这里，我们终于知道了这个编译任务的作用了。</p>
<p>知道了源码的获取，继续往下看 <code>compile</code> 方法，看看源码是如何编译的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line">  NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  NativeModule.wrapper = [</span><br><span class="line">    <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">    <span class="string">'\n&#125;);'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">    source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = runInThisContext(source, &#123;</span><br><span class="line">        filename: <span class="keyword">this</span>.filename,</span><br><span class="line">        lineOffset: <span class="number">0</span>,</span><br><span class="line">        displayErrors: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">      fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>NativeModule.prototype.compile</code> 在获取到源码之后，它主要做了：使用 <code>wrap</code> 方法处理源代码，最后调用 runInThisContext 进行编译得到一个函数，最后执行该函数。其中 wrap 方法，是给源代码加上了一头一尾，其实相当于是将源码包在了一个函数中，这个函数的参数有 exports, require, module 等。这就是为什么我们写模块的时候，不需要定义 exports, require, module 就可以直接用的原因。</p>
<p>至此就基本讲清楚了 Node.js 核心模块的加载过程。说到这里大家可能有一个疑惑，上述分析过程，好像只涉及到了核心模块中的 JavaScript native模块，那么对于 C/C++ built-in 模块呢？</p>
<p>其实是这样的，对于 built-in 模块而言，它们不是通过 require 来引入的，而是通过 <code>precess.binding('模块名')</code> 引入的。一般我们很少在自己的代码中直接使用 <code>process.binding</code> 来引入built-in模块，而是通过 <code>require</code> 引用native模块，而 native 模块里面会引入 built-in 模块。比如我们常用的 buffer 模块，其内部实现中就引入了 C/C++ built-in 模块，这是为了避开 v8 的内存限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lib/buffer.js</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">// 通过 process.binding 引入名为 buffer 的 C/C++ built-in 模块</span><br><span class="line">const binding = process.binding(&apos;buffer&apos;);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<p>这样，我们在 <code>require('buffer')</code> 的时候，其实是间接的使用了 C/C++ built-in 模块。</p>
<p>这里再次出现了 <code>process.binding</code>！事实上，process.binding 这个方法定义在 <code>node.cc</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Binding</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  node_module* mod = get_builtin_module(*module_v);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">env-&gt;SetMethod(process, <span class="string">"binding"</span>, Binding);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>Binding</code> 这个函数中关键的一步是 <code>get_builtin_module</code>。这里需要再次插入介绍一下 C/C++ 内建模块的存储方式：</p>
<p>在 Node.js 中，内建模块是通过一个名为 <code>node_module_struct</code> 的结构体定义的。所以的内建模块会被放入一个叫做 <code>node_module_list</code> 的数组中。而 <code>process.binding</code> 的作用，正是使用 <code>get_builtin_module</code> 从这个数组中取出相应的内建模块代码。</p>
<p>综上，我们就完整介绍了核心模块的加载原理，主要是区分 JavaScript 类型的 native 模块和 C/C++ 类型的 built-in 模块。这里绘制一张图来描述一下核心模块加载过程：</p>
<div class="figure">
<img src="/blog/nodejs-module-analyze/process2.png" alt="process2"><p class="caption">process2</p>
</div>
<p>而回忆我们在最开始介绍的，native 模块在源码中存放在 lib/ 目录下，而 built-in 模块在源码中存放在 src/ 目录下，下面这张图则从编译的角度梳理了 native 和 built-in 模块如何被编译进 Node.js 可执行文件：</p>
<div class="figure">
<img src="/blog/nodejs-module-analyze/process3.png" alt="process3"><p class="caption">process3</p>
</div>
<h4 id="第三方模块加载原理">4.2 第三方模块加载原理</h4>
<p>下面让我们继续分析第二个分支，假设我们的 <code>index.js</code> 中 require 的不是 http，而是一个用户自定义模块，那么在 module.js 中, 我们会走到 tryModuleLoad 方法中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryModuleLoad</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> threw = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.load(filename);</span><br><span class="line">    threw = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threw) &#123;</span><br><span class="line">      <span class="keyword">delete</span> Module._cache[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  debug(<span class="string">'load %j for module %j'</span>, filename, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">  assert(!<span class="keyword">this</span>.loaded);</span><br><span class="line">  <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  <span class="keyword">this</span>.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这里看到，<code>tryModuleLoad</code> 中实际调用了 <code>Module.prototype.load</code> 定义的方法，这个方法主要做的事情是，检测 filename 的扩展名，然后针对不同的扩展名，调用不同的 <code>Module._extensions</code> 方法来加载、编译模块。接着我们看看 <code>Module._extensions</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Native extension for .js</span></span><br><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">module</span>._compile(internalModule.stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Native extension for .json</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(internalModule.stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">': '</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Native extension for .node</span></span><br><span class="line">Module._extensions[<span class="string">'.node'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> process.dlopen(<span class="built_in">module</span>, path._makeLong(filename));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>可以看出，一共支持三种类型的模块加载：.js, .json, .node。其中 .json 类型的文件加载方法是最简单的，直接读取文件内容，然后 <code>JSON.parse</code> 之后返回对象即可。</p>
<p>下面来看对 .js 的处理，首先也是通过 <code>fs</code> 模块同步读取文件内容，然后调用了 <code>module._compile</code>，看看相关代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.wrap = NativeModule.wrap;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// create wrapper function</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> compiledWrapper = vm.runInThisContext(wrapper, &#123;</span><br><span class="line">    filename: filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> result = compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</span><br><span class="line">  <span class="keyword">if</span> (depth === <span class="number">0</span>) stat.cache = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>首先调用 <code>Module.wrap</code> 对源代码进行包裹，之后调用 <code>vm.runInThisContext</code> 方法进行编译执行，最后返回 exports 的值。而从 <code>Module.wrap = NativeModule.wrap</code> 这一句可以看出，第三方模块的 wrap 方法，和核心模块的 wrap 方法是一样的。我们回忆一下刚才讲到的核心js模块加载关键代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line"> NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  NativeModule.wrapper = [</span><br><span class="line">    <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">    <span class="string">'\n&#125;);'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">    source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = runInThisContext(source, &#123;</span><br><span class="line">        filename: <span class="keyword">this</span>.filename,</span><br><span class="line">        lineOffset: <span class="number">0</span>,</span><br><span class="line">        displayErrors: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">      fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>两厢对比，发现二者对源代码的编译执行几乎是一模一样的。从整体流程上来讲，核心 JavaScript 模块与第三方 JavaScript 模块最大的不同就是，核心 JavaScript 模块源代码是通过 <code>process.binding('natives')</code> 从内存中获取的，而第三方 JavaScript 模块源代码是通过 <code>fs.readFileSync</code> 方法从文件中读取的。</p>
<p>最后，再来看一下加载第三方 C/C++模块（.node后缀）。直观上来看，很简单，就是调用了 <code>process.dlopen</code> 方法。这个方法的定义在 <code>node.cc</code> 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">env-&gt;SetMethod(process, <span class="string">"dlopen"</span>, DLOpen);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLOpen</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_dlopen_error = uv_dlopen(*filename, &amp;lib);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>实际上最终调用了 <code>DLOpen</code> 函数，该函数中最重要的是使用 <code>uv_dlopen</code> 方法打开动态链接库，然后对 C/C++ 模块进行加载。<code>uv_dlopen</code> 方法是定义在 <code>libuv</code> 库中的。<code>libuv</code> 库是一个跨平台的异步 IO 库。对于扩展模块的动态加载这部分功能，在 *nix 平台下，实际上调用的是 dlfcn.h 中定义的 dlopen() 方法，而在 Windows 下，则为 LoadLibraryExW() 方法，在两个平台下，他们加载的分别是 .so 和 .dll 文件，而 Node.js 中，这些文件统一被命名了 .node 后缀，屏蔽了平台的差异。</p>
<p>关于 <code>libuv</code> 库，是 Node.js 异步 IO 的核心驱动力，这一块本身就值得专门作为一个专题来研究，这里就不展开讲了。</p>
<p>到此为止，我们理清楚了三种第三方模块的加载、编译过程。</p>
<h2 id="cc-扩展模块的开发以及应用场景">5. C/C++ 扩展模块的开发以及应用场景</h2>
<p>上文分析了 Node.js 当中各类模块的加载流程。大家对于 JavaScript 模块的开发应该是驾轻就熟了，但是对于 C/C++ 扩展模块开发可能还有些陌生。这一节就简单介绍一下扩展模块的开发，并谈谈其应用场景。</p>
<p>关于 Node.js 扩展模块的开发，在 Node.js 官网文档中专门有一节予以介绍，大家可以移步官网文档查看：<a href="https://nodejs.org/docs/latest-v6.x/api/addons.html" class="uri" target="_blank" rel="noopener">https://nodejs.org/docs/latest-v6.x/api/addons.html</a> 。这里仅仅以其中的 hello world 例子来介绍一下编写扩展模块的一些比较重要的概念：</p>
<p>假设我们希望通过扩展模块来实现一个等同于如下 JavaScript 函数的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.hello = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure>
<p>首先创建一个 hello.cc 文件，编写如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line"><span class="keyword">using</span> v8::Isolate;</span><br><span class="line"><span class="keyword">using</span> v8::Local;</span><br><span class="line"><span class="keyword">using</span> v8::Object;</span><br><span class="line"><span class="keyword">using</span> v8::String;</span><br><span class="line"><span class="keyword">using</span> v8::Value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = args.GetIsolate();</span><br><span class="line">  args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">  NODE_SET_METHOD(exports, <span class="string">"hello"</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace demo</span></span><br></pre></td></tr></table></figure>
<p>文件虽短，但是已经出现了一些我们比较陌生的代码，这里一一介绍一下，对于了解扩展模块基础知识还是很有帮助的。</p>
<p>首先在开头引入了 <code>node.h</code>，这个是编写 Node.js 扩展时必用的头文件，里面几乎包含了我们所需要的各种库、数据类型。</p>
<p>其次，看到了很多 <code>using v8:xxx</code> 这样的代码。我们知道，Node.js 是基于 v8 引擎的，而 v8 引擎，就是用 C++ 来写的。我们要开发 C++ 扩展模块，便需要使用 v8 中提供的很多数据类型，而这一系列代码，正是声明了需要使用 v8 命名空间下的这些数据类型。</p>
<p>然后来看 <code>Method</code> 方法，它的参数类型 <code>FunctionCallbackInfo&lt;Value&gt;&amp; args</code>，这个 args 就是从 JavaScript 中传入的参数，同时，如果想在 <code>Method</code> 中为 JavaScript 返回变量，则需要调用 <code>args.GetReturnValue().Set</code> 方法。</p>
<p>接下来需要定义扩展模块的初始化方法，这里是 <code>Init</code> 函数，只有一句简单的 <code>NODE_SET_METHOD(exports, &quot;hello&quot;, Method);</code>，代表给 exports 赋予一个名为 <code>hello</code> 的方法，这个方法的具体定义就是 <code>Method</code> 函数。</p>
<p>最后是一个宏定义：<code>NODE_MODULE(NODE_GYP_MODULE_NAME, init)</code>，第一个参数是希望的扩展模块名称，第二个参数就是该模块的初始化方法。</p>
<p>为了编译这个模块，我们需要通过npm安装 <code>node-gyp</code> 编译工具。该工具将 Google 的 <code>gyp</code> 工具封装，用来构建 Node.js 扩展。安装这个工具后，我们在源码文件夹下面增加一个名为 <code>bingding.gyp</code> 的配置文件，对于我们这个例子，文件只要这样写：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">      <span class="attr">"sources"</span>: [ <span class="string">"hello.cc"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，运行 <code>node-gyp build</code> 即可编译扩展模块。在这个过程中，<code>node-gyp</code> 还会去指定目录（一般是 ~/.node-gyp）下面搜我们当前 Node.js 版本的一些头文件和库文件，如果不存在，它还会帮我们去 Node.js 官网下载。这样，在编写扩展的时候，通过 <code>#include &lt;&gt;</code>，我们就可以直接使用所有 Node.js 的头文件了。</p>
<p>如果编译成功，会在当前文件夹的 <code>build/Release/</code> 路径下看到一个 <code>addon.node</code>，这个就是我们编译好的可 require 的扩展模块。</p>
<p>从上面的例子中，我们能大体看出扩展模块的运作模式，它可以接收来自 JavaScript 的参数，然后中间可以调用 C/C++ 语言的能力去做各种运算、处理，然后最后可以将结果再返回给 JavaScript。</p>
<p>值得注意的是，不同 Node.js 版本，依赖的 v8 版本不同，导致很多 API 会有差别，因此使用原生 C/C++ 开发扩展的过程中，也需要针对不同版本的 Node.js 做兼容处理。比如说，声明一个函数，在 v6.x 和 v0.12 以下的版本中，分别需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Handle&lt;Value&gt; Example(<span class="keyword">const</span> Arguments&amp; args); <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure>
<p>可以看到，函数的声明，包括函数中参数的写法，都不尽相同。这让人不由得想起了在 Node.js 开发中，为了写 ES6，也是需要使用 Babel 来帮忙进行兼容性转换。那么在 Node.js 扩展开发领域，有没有类似 Babel 这样帮助我们处理兼容性问题的库呢？答案是肯定的，它的名字叫做 NAN (Native Abstraction for Node.js)。它本质上是一堆宏，能够帮助我们检测 Node.js 的不同版本，并调用不同的 API。例如，在 NAN 的帮助下，声明一个函数，我们不需要再考虑 Node.js 版本，而只需要写一段这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nan.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NAN_METHOD(Example) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NAN 的宏会在编译的时候自动判断，根据 Node.js 版本的不同展开不同的结果，从而解决了兼容性问题。对 NAN 更详细的介绍，感兴趣的同学可以移步该项目的 github 主页：<a href="https://github.com/nodejs/nan" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/nan</a>。</p>
<p>介绍了这么多扩展模块的开发，可能有同学会问了，像这些扩展模块实现的功能，看起来似乎用js也可以很快的实现，何必大费周折去开发扩展呢？这就引出了一个问题：C/C++ 扩展的适用场景。</p>
<p>笔者在这里大概归纳了几类 C/C++ 适用的情景：</p>
<ol style="list-style-type: decimal">
<li>计算密集型应用。我们知道，Node.js 的编程模型是单线程 + 异步 IO，其中单线程导致了它在计算密集型应用上是一个软肋，大量的计算会阻塞 JavaScript 主线程，导致无法响应其他请求。对于这种场景，就可以使用 C/C++ 扩展模块，来加快计算速度，毕竟，虽然 v8 引擎的执行速度很快，但终究还是比不过 C/C++。另外，使用 C/C++，还可以允许我们开多线程，避免阻塞 JavaScript 主线程，社区里目前已经有一些基于扩展模块的 Node.js 多线程方案，其中最受欢迎的可能是一个叫做 <code>thread-a-gogo</code> 的项目，具体可以移步 github：<a href="https://github.com/xk/node-threads-a-gogo" class="uri" target="_blank" rel="noopener">https://github.com/xk/node-threads-a-gogo</a>。</li>
<li>内存消耗较大的应用。Node.js 是基于 v8 的，而 v8 一开始是为浏览器设计的，所以其在内存方面是有比较严格的限制的，所以对于一些需要较大内存的应用，直接基于 v8 可能会有些力不从心，这个时候就需要使用扩展模块，来绕开 v8 的内存限制，最典型的就是我们常用的 buffer.js 模块，其底层也是调用了 C++，在 C++ 的层面上去申请内存，避免 v8 内存瓶颈。</li>
</ol>
<p>关于第一点，笔者这里也分别用原生 Node.js 以及 Node.js 扩展实现了一个测试例子来对比计算性能。测试用例是经典的计算斐波那契数列，首先使用 Node.js 原生语言实现一个计算斐波那契数列的函数，取名为 <code>fibJs</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibJs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibJs(n - <span class="number">1</span>) + fibJs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用 C++ 编写一个实现同样功能的扩展函数，取名 <code>fibC</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibC.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n ==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">    <span class="keyword">int</span> result = fib(n);</span><br><span class="line">    args.GetReturnValue().Set(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt; Object &gt; exports, Local &lt; Object &gt; <span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(<span class="keyword">module</span>, <span class="string">"exports"</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(fibC, init)</span><br></pre></td></tr></table></figure>
<p>在测试中，分别使用这两个函数计算从 1~40 的斐波那契数列:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSpeed</span>(<span class="params">fn, testName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        fn(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> spend = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">    <span class="built_in">console</span>.log(testName, <span class="string">'spend time: '</span>, spend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展模块测试</span></span><br><span class="line"><span class="keyword">var</span> fibC = <span class="built_in">require</span>(<span class="string">'./build/Release/fibC'</span>); <span class="comment">// 这里是扩展模块编译产物的存放路径</span></span><br><span class="line">testSpeed(fibC, <span class="string">'c++ test:'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 JavaScript 函数进行测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibJs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibJs(n - <span class="number">1</span>) + fibJs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">testSpeed(fibJs, <span class="string">'js test:'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ test: spend time:  1221</span></span><br><span class="line"><span class="comment">// js test: spend time:  2611</span></span><br></pre></td></tr></table></figure>
<p>多次测试，扩展模块平均花费时长大约 1.2s，而 JavaScript 模块花费时长大约 2.6s，可见在此场景下，C/C++ 扩展性能还是要快上不少的。</p>
<p>当然，这几点只是基于笔者的认识。在实际开发过程中，大家在遇到问题的时候，也可以尝试着考虑如果使用 C/C++ 扩展模块，问题是不是能够得到更好的解决。</p>
<h3 id="结语">结语</h3>
<p>文章读到这里，我们再回去看一下一开始提出的那些问题，是否在文章分析的过程中都得到了解答？再来回顾一下本文的逻辑脉络：</p>
<ul>
<li>首先以一个<code>node index.js</code> 的运行原理开始，指出使用<code>node</code> 运行一个文件，等同于立即执行一次<code>require</code> 。</li>
<li>然后引出了node中的require方法，在这里，区分了核心模块、内建模块和非核心模块几种情况，分别详述了加载、编译的流程原理。在这个过程中，还分别涉及到了模块路径解析、模块缓存等等知识点的描述。</li>
<li>最后介绍了大家不太熟悉的c/c++扩展模块的开发，并结合一个性能对比的例子来说明其适用场景。</li>
</ul>
<p>事实上，通过学习 Node.js 模块加载流程，有助于我们更深刻的了解 Node.js 底层的运行原理，而掌握了其中的扩展模块开发，并学会在适当的场景下使用，则能够使得我们开发出的 Node.js 应用性能更高。</p>
<p>学习 Node.js 原理是一条漫长的路径。建议了解了底层模块机制的读者，可以去更深入的学习 v8, libuv 等等知识，对于精通 Node.js，必将大有裨益。</p>

    
</article>

<div class="article-license">
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="知识共享许可协议" src="/img/cc-by.png" width="80" height="15"></a>
</div>
<nav class="article-pagination">
    
    <a href="/blog/bfcache-analysis-and-fix/" class="article-prev">前一篇: 浏览器往返缓存（Back/Forward cache）问题的分析与解决</a>
    
    
    <a href="/blog/san-3-3-0/" class="article-next">后一篇: San 3.3.0 发布</a>
    
</nav>

<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<div class="ds-thread" data-thread-key="blog/nodejs-module-analyze/" data-title="结合源码分析 Node.js 模块加载与运行原理" data-url="http://efe.baidu.com/blog/nodejs-module-analyze/"></div>
<script>
var duoshuoQuery = {short_name:"baidu-efe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';
    ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>




<footer>
    <p class="copy">&copy;2018 Baidu EFE | Powered By <a href="http://hexo.io/" target="_blank" title="Hexo">Hexo</a></p>
</footer>

<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F8581b5de0049c5e3009931686fc45d7a' type='text/javascript'%3E%3C/script%3E"));
</script>

</body>
</html>


