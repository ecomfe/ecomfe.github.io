<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EFE Tech</title>
  
  <subtitle>百度EFE（Excellent FrontEnd）技术体系</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://efe.baidu.com/"/>
  <updated>2019-05-18T12:42:11.730Z</updated>
  <id>http://efe.baidu.com/</id>
  
  <author>
    <name>efe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>San 为什么会这么快</title>
    <link href="http://efe.baidu.com/blog/san-perf/"/>
    <id>http://efe.baidu.com/blog/san-perf/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-18T12:42:11.730Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个 MVVM 框架的性能进化之路</p></blockquote><p>性能一直是 <a href="https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49" target="_blank" rel="noopener">框架选型</a> 最重要的考虑因素之一。<a href="https://baidu.github.io/san/" target="_blank" rel="noopener">San</a> 从设计之初就希望不要因为自身的短板（性能、体积、兼容性等）而成为开发者为难的理由，所以我们在性能上投入了很多的关注和精力，效果至少从 <a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener">benchmark</a> 看来，还不错。</p><div class="figure"><img src="/blog/san-perf/san-perf-non-keyed.png" alt="San non-keyed performance"><p class="caption">San non-keyed performance</p></div><p>将近 2 年以前，我发了一篇 <a href="https://efe.baidu.com/blog/san-a-traditional-mvvm-component-framework/">San - 一个传统的MVVM组件框架</a>。对 <a href="https://baidu.github.io/san/" target="_blank" rel="noopener">San</a> 设计初衷感兴趣的同学可以翻翻。我一直觉得框架选型的时候，了解它的调性是非常关键的一点。</p><p>不过其实，大多数应用场景的框架选型中，<strong>知名度</strong> 是最主要的考虑因素，因为 <strong>知名度</strong> 意味着你可以找到更多的人探讨、可以找到更多周边、可以更容易招聘熟手或者以后自己找工作更有优势。所以本文的目的并不是将你从三大阵营（<a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>、<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>、<a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>）拉出来，而是想把 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的性能经验分享给你。这些经验无论在应用开发，还是写一些基础的东西，都会有所帮助。</p><p>在正式开始之前，惯性先厚脸皮求下 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">Star</a>。</p><a id="more"></a><h2 id="视图创建">视图创建</h2><p>考虑下面这个还算简单的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyApp = san.defineComponent(&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li s-for="item,i in list"&gt;&#123;&#123;item&#125;&#125; &lt;a on-click="removeItem(i)"&gt;x&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;h4&gt;Operation&lt;/h4&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                Name:</span></span><br><span class="line"><span class="string">                &lt;input type="text" value="&#123;=value=&#125;"&gt;</span></span><br><span class="line"><span class="string">                &lt;button on-click="addItem"&gt;add&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;button on-click="reset"&gt;reset&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line"></span><br><span class="line">    initData() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            title: <span class="string">'List'</span>,</span><br><span class="line">            list: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    addItem() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(<span class="string">'list'</span>, <span class="keyword">this</span>.data.get(<span class="string">'value'</span>));</span><br><span class="line">        <span class="keyword">this</span>.data.set(<span class="string">'value'</span>, <span class="string">''</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeItem(index) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.removeAt(<span class="string">'list'</span>, index);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    reset() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.set(<span class="string">'list'</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在视图初次渲染完成后，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 会生成一棵这样子的树：</p><div class="figure"><img src="/blog/san-perf/render-tree.png" alt="Render Tree"><p class="caption">Render Tree</p></div><p>那么，在这个过程里，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 都做了哪些事情呢？</p><h3 id="模板解析">模板解析</h3><p>在组件第一个实例被创建时，<strong>template</strong> 属性会被解析成 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a>。</p><div class="figure"><img src="/blog/san-perf/anode.png" alt="ANode"><p class="caption">ANode</p></div><p><a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 的含义是抽象节点树，包含了模板声明的所有信息，包括标签、文本、插值、数据绑定、条件、循环、事件等信息。对每个数据引用的声明，也会解析出具体的表达式对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"directives"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"props"</span>: [],</span><br><span class="line">    <span class="attr">"events"</span>: [],</span><br><span class="line">    <span class="attr">"children"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"directives"</span>: &#123;</span><br><span class="line">                <span class="attr">"for"</span>: &#123;</span><br><span class="line">                    <span class="attr">"item"</span>: <span class="string">"item"</span>,</span><br><span class="line">                    <span class="attr">"value"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="number">4</span>,</span><br><span class="line">                        <span class="attr">"paths"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                                <span class="attr">"value"</span>: <span class="string">"list"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"index"</span>: <span class="string">"i"</span>,</span><br><span class="line">                    <span class="attr">"raw"</span>: <span class="string">"item,i in list"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"props"</span>: [],</span><br><span class="line">            <span class="attr">"events"</span>: [],</span><br><span class="line">            <span class="attr">"children"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"textExpr"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="number">7</span>,</span><br><span class="line">                        <span class="attr">"segs"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"type"</span>: <span class="number">5</span>,</span><br><span class="line">                                <span class="attr">"expr"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"type"</span>: <span class="number">4</span>,</span><br><span class="line">                                    <span class="attr">"paths"</span>: [</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                                            <span class="attr">"value"</span>: <span class="string">"item"</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;,</span><br><span class="line">                                <span class="attr">"filters"</span>: [],</span><br><span class="line">                                <span class="attr">"raw"</span>: <span class="string">"item"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"directives"</span>: &#123;&#125;,</span><br><span class="line">                    <span class="attr">"props"</span>: [],</span><br><span class="line">                    <span class="attr">"events"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"name"</span>: <span class="string">"click"</span>,</span><br><span class="line">                            <span class="attr">"modifier"</span>: &#123;&#125;,</span><br><span class="line">                            <span class="attr">"expr"</span>: &#123;</span><br><span class="line">                                <span class="attr">"type"</span>: <span class="number">6</span>,</span><br><span class="line">                                <span class="attr">"name"</span>: &#123;</span><br><span class="line">                                    <span class="attr">"type"</span>: <span class="number">4</span>,</span><br><span class="line">                                    <span class="attr">"paths"</span>: [</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                                            <span class="attr">"value"</span>: <span class="string">"removeItem"</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;,</span><br><span class="line">                                <span class="attr">"args"</span>: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="attr">"type"</span>: <span class="number">4</span>,</span><br><span class="line">                                        <span class="attr">"paths"</span>: [</span><br><span class="line">                                            &#123;</span><br><span class="line">                                                <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                                                <span class="attr">"value"</span>: <span class="string">"i"</span></span><br><span class="line">                                            &#125;</span><br><span class="line">                                        ]</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">"raw"</span>: <span class="string">"removeItem(i)"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"children"</span>: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"textExpr"</span>: &#123;</span><br><span class="line">                                <span class="attr">"type"</span>: <span class="number">7</span>,</span><br><span class="line">                                <span class="attr">"segs"</span>: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="attr">"type"</span>: <span class="number">1</span>,</span><br><span class="line">                                        <span class="attr">"literal"</span>: <span class="string">"x"</span>,</span><br><span class="line">                                        <span class="attr">"value"</span>: <span class="string">"x"</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                <span class="attr">"value"</span>: <span class="string">"x"</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"tagName"</span>: <span class="string">"a"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"tagName"</span>: <span class="string">"li"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"tagName"</span>: <span class="string">"ul"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 保存着视图声明的数据引用与事件绑定信息，在视图的初次渲染与后续的视图更新中，都扮演着不可或缺的作用。</p><p>无论一个组件被创建了多少个实例，<strong>template</strong> 的解析都只会进行一次。当然，预编译是可以做的。但因为 <strong>template</strong> 是用才解析，没有被使用的组件不会解析，所以就看实际使用中值不值，有没有必要了。</p><h3 id="preheat">preheat</h3><p>在组件第一个实例被创建时，<a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 会进行一个 <strong>预热</strong> 操作。看起来， <strong>预热</strong> 和 <strong>template解析</strong> 都是发生在第一个实例创建时，那他们有什么区别呢？</p><ol style="list-style-type: decimal"><li><strong>template解析</strong> 生成的 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 是一个可以被 JSON stringify 的对象。</li><li>由于 1，所以 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 可以进行预编译。这种情况下，<strong>template解析</strong> 过程会被省略。而 <strong>预热</strong> 是必然会发生的。</li></ol><p>接下来，让我们看看预热到底生成了什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aNode.hotspot = &#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    dynamicProps: [],</span><br><span class="line">    xProps: [],</span><br><span class="line">    props: &#123;&#125;,</span><br><span class="line">    sourceNode: sourceNode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面这个来自 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js" target="_blank" rel="noopener">preheat-a-node.js</a> 的简单代码节选不包含细节，但是可以看出， <strong>预热</strong> 过程生成了一个 <code>hotspot</code> 对象，其包含这样的一些属性：</p><ul><li>data - 节点数据引用的摘要信息</li><li>dynamicProps - 节点上的动态属性</li><li>xProps - 节点上的双向绑定属性</li><li>props - 节点的属性索引</li><li>sourceNode - 用于节点生成的 HTMLElement</li></ul><p><strong>预热</strong> 的主要目的非常简单，就是把在模板信息中就能确定的事情提前，只做一遍，避免在 <strong>渲染/更新</strong> 过程中重复去做，从而节省时间。<strong>预热</strong> 过程更多的细节见 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js" target="_blank" rel="noopener">preheat-a-node.js</a>。在接下来的部分，对 <code>hotspot</code> 发挥作用的地方也会进行详细说明。</p><h3 id="视图创建过程">视图创建过程</h3><div class="figure"><img src="/blog/san-perf/anode-render.png" alt="Render"><p class="caption">Render</p></div><p>视图创建是个很常规的过程：基于初始的 <strong>数据</strong> 和 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a>，创建一棵对象树，树中的每个节点负责自身在 DOM 树上节点的操作（创建、更新、删除）行为。对一个组件框架来说，创建对象树的操作无法省略，所以这个过程一定比原始地 createElement + appendChild 慢。</p><p>因为这个过程比较常规，所以接下来不会描述整个过程，而是提一些有价值的优化点。</p><h4 id="clonenode">cloneNode</h4><p>在 <strong>预热</strong> 阶段，我们根据 <code>tagName</code> 创建了 <code>sourceNode</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isBrowser &amp;&amp; aNode.tagName</span><br><span class="line">    &amp;&amp; !<span class="regexp">/^(template|slot|select|input|option|button)$/i</span>.test(aNode.tagName)</span><br><span class="line">) &#123;</span><br><span class="line">    sourceNode = createEl(aNode.tagName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 中包含了所有的属性声明，我们知道哪些属性是动态的，哪些属性是静态的。对于静态属性，我们可以在 <strong>预热</strong> 阶段就直接设置好。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L122-L142" target="_blank" rel="noopener">preheat-a-node.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">each(aNode.props, <span class="function"><span class="keyword">function</span> (<span class="params">prop, index</span>) </span>&#123;</span><br><span class="line">    aNode.hotspot.props[prop.name] = index;</span><br><span class="line">    prop.handler = getPropHandler(aNode.tagName, prop.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (prop.expr.value != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sourceNode) &#123;</span><br><span class="line">            prop.handler(sourceNode, prop.expr.value, prop.name, aNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop.x) &#123;</span><br><span class="line">            aNode.hotspot.xProps.push(prop);</span><br><span class="line">        &#125;</span><br><span class="line">        aNode.hotspot.dynamicProps.push(prop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <strong>视图创建过程</strong> 中，就可以从 <code>sourceNode</code> clone，并且只对动态属性进行设置。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L115-L150" target="_blank" rel="noopener">element.js#L115-L150</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sourceNode = <span class="keyword">this</span>.aNode.hotspot.sourceNode;</span><br><span class="line"><span class="keyword">var</span> props = <span class="keyword">this</span>.aNode.props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sourceNode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = sourceNode.cloneNode(<span class="literal">false</span>);</span><br><span class="line">    props = <span class="keyword">this</span>.aNode.hotspot.dynamicProps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = createEl(<span class="keyword">this</span>.tagName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = props.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> prop = props[i];</span><br><span class="line">    <span class="keyword">var</span> propName = prop.name;</span><br><span class="line">    <span class="keyword">var</span> value = isComponent</span><br><span class="line">        ? evalExpr(prop.expr, <span class="keyword">this</span>.data, <span class="keyword">this</span>)</span><br><span class="line">        : evalExpr(prop.expr, <span class="keyword">this</span>.scope, <span class="keyword">this</span>.owner);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    prop.handler(<span class="keyword">this</span>.el, value, propName, <span class="keyword">this</span>, prop);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性操作">属性操作</h4><p>不同属性对应 DOM 的操作方式是不同的，属性的 <strong>预热</strong> 提前保存了属性操作函数（<a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L133" target="_blank" rel="noopener">preheat-a-node.js#L133</a>），属性初始化或更新时就无需每次都重复获取。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prop.handler = getPropHandler(aNode.tagName, prop.name);</span><br></pre></td></tr></table></figure><p>对于 <code>s-bind</code>，对应的数据是 <strong>预热</strong> 阶段无法预知的，所以属性操作函数只能在具体操作时决定。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L128-L137" target="_blank" rel="noopener">element.js#L128-L137</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>._sbindData) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._sbindData.hasOwnProperty(key)) &#123;</span><br><span class="line">        getPropHandler(<span class="keyword">this</span>.tagName, key)( <span class="comment">// 看这里看这里</span></span><br><span class="line">            <span class="keyword">this</span>.el,</span><br><span class="line">            <span class="keyword">this</span>._sbindData[key],</span><br><span class="line">            key,</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，<code>getPropHandler</code> 函数的实现也进行了相应的结果缓存。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/get-prop-handler.js#L247-L258" target="_blank" rel="noopener">get-prop-handler.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tagPropHandlers = elementPropHandlers[tagName];</span><br><span class="line"><span class="keyword">if</span> (!tagPropHandlers) &#123;</span><br><span class="line">    tagPropHandlers = elementPropHandlers[tagName] = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> propHandler = tagPropHandlers[attrName];</span><br><span class="line"><span class="keyword">if</span> (!propHandler) &#123;</span><br><span class="line">    propHandler = defaultElementPropHandlers[attrName] || defaultElementPropHandler;</span><br><span class="line">    tagPropHandlers[attrName] = propHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> propHandler;</span><br></pre></td></tr></table></figure><h4 id="创建节点">创建节点</h4><p>视图创建过程中，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 通过 <code>createNode</code> 工厂方法，根据 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 上每个节点的信息，创建组件的每个节点。</p><p><a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 上与节点创建相关的信息有：</p><ul><li>if 声明</li><li>for 声明</li><li>标签名</li><li>文本表达式</li></ul><p>节点类型有：</p><ul><li>IfNode</li><li>ForNode</li><li>TextNode</li><li>Element</li><li>Component</li><li>SlotNode</li><li>TemplateNode</li></ul><p>因为每个节点都通过 <code>createNode</code> 方法创建，所以它的性能是极其重要的。那这个过程的实现，有哪些性能相关的考虑呢？</p><p>首先，<strong>预热</strong> 过程提前选择好 <a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 节点对应的实际类型。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L58" target="_blank" rel="noopener">preheat-a-node.js#L58</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L170" target="_blank" rel="noopener">preheat-a-node.js#L170</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L185" target="_blank" rel="noopener">preheat-a-node.jsL185</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L190-L197" target="_blank" rel="noopener">preheat-a-node.jsL190</a></p><p>在 <code>createNode</code> 一开始就可以直接知道对应的节点类型。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/create-node.js#L24-L26" target="_blank" rel="noopener">create-node.js#L24-L26</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aNode.Clazz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> aNode.Clazz(aNode, parent, scope, owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，我们可以看到，除了 Component 之外，其他节点类型的构造函数参数签名都是 <code>(aNode, parent, scope, owner, reverseWalker)</code>，并没有使用一个 Object 包起来，就是为了在节点创建过程避免创建无用的中间对象，浪费创建和回收的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IfNode</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ForNode</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextNode</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SlotNode</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TemplateNode</span>(<span class="params">aNode, parent, scope, owner, reverseWalker</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">options</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>而 Component 由于使用者可直接接触到，初始化参数的便利性就更重要些，所以初始化参数是一个 options 对象。</p><h2 id="视图更新">视图更新</h2><h3 id="从数据变更到遍历更新">从数据变更到遍历更新</h3><p>考虑上文中展示过的组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyApp = san.defineComponent(&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li s-for="item,i in list"&gt;&#123;&#123;item&#125;&#125; &lt;a on-click="removeItem(i)"&gt;x&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">            &lt;h4&gt;Operation&lt;/h4&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                Name:</span></span><br><span class="line"><span class="string">                &lt;input type="text" value="&#123;=value=&#125;"&gt;</span></span><br><span class="line"><span class="string">                &lt;button on-click="addItem"&gt;add&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;button on-click="reset"&gt;reset&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line"></span><br><span class="line">    initData() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            title: <span class="string">'List'</span>,</span><br><span class="line">            list: []</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    addItem() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.push(<span class="string">'list'</span>, <span class="keyword">this</span>.data.get(<span class="string">'value'</span>));</span><br><span class="line">        <span class="keyword">this</span>.data.set(<span class="string">'value'</span>, <span class="string">''</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeItem(index) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.removeAt(<span class="string">'list'</span>, index);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    reset() &#123;</span><br><span class="line">        <span class="keyword">this</span>.data.set(<span class="string">'list'</span>, []);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myApp = <span class="keyword">new</span> MyApp();</span><br><span class="line">myApp.attach(<span class="built_in">document</span>.body);</span><br></pre></td></tr></table></figure><p>当我们更改了数据，视图就会自动刷新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myApp.data.set(<span class="string">'title'</span>, <span class="string">'SampleList'</span>);</span><br></pre></td></tr></table></figure><h4 id="data">data</h4><p>我们可以很容易的发现，<code>data</code> 是：</p><ul><li>组件上的一个属性，组件的数据状态容器</li><li>一个对象，提供了数据读取和操作的方法。See <a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作文档</a></li><li>Observable。每次数据的变更都会 <code>fire</code>，可以通过 <code>listen</code> 方法监听数据变更。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js" target="_blank" rel="noopener">data.js</a></li></ul><p><code>data</code> 是变化可监听的，所以组件的视图变更就有了基础出发点。</p><h4 id="视图更新过程">视图更新过程</h4><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 最初设计的时候想法很简单：模板声明包含了对数据的引用，当数据变更时可以精准地只更新需要更新的节点，性能应该是很高的。从上面组件例子的模板中，一眼就能看出，title 数据的修改，只需要更新一个节点。但是，我们如何去找到它并执行视图更新动作呢？这就是组件的视图更新机制了。其中，有几个关键的要素：</p><ul><li>组件在初始化的过程中，创建了 <code>data</code> 实例并监听其数据变化。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/component.js#L255" target="_blank" rel="noopener">component.js#L255</a></li><li>视图更新是异步的。数据变化会被保存在一个数组里，在 <code>nextTick</code> 时批量更新。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/component.js#L782-L787" target="_blank" rel="noopener">component.js#L782</a></li><li>组件是个 <code>children</code> 属性串联的节点树，视图更新是个自上而下遍历的过程。</li></ul><p>在节点树更新的遍历过程中，每个节点通过 <code>_update({Array}changes)</code> 方法接收数据变化信息，更新自身的视图，并向子节点传递数据变化信息。<a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/component.js#L688-L690" target="_blank" rel="noopener">component.js#L688</a> 是组件向下遍历的起始，但从最典型的 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L240-L299" target="_blank" rel="noopener">Element的_update方法</a> 可以看得更清晰些：</p><ol style="list-style-type: decimal"><li>先看自身的属性有没有需要更新的</li><li>然后把数据变化信息通过 <code>children</code> 往下传递。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节选</span></span><br><span class="line">Element.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">changes</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先看自身的属性有没有需要更新的</span></span><br><span class="line">    <span class="keyword">var</span> dynamicProps = <span class="keyword">this</span>.aNode.hotspot.dynamicProps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = dynamicProps.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> prop = dynamicProps[i];</span><br><span class="line">        <span class="keyword">var</span> propName = prop.name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, changeLen = changes.length; j &lt; changeLen; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> change = changes[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isDataChangeByElement(change, <span class="keyword">this</span>, propName)</span><br><span class="line">                &amp;&amp; changeExprCompare(change.expr, prop.hintExpr, <span class="keyword">this</span>.scope)</span><br><span class="line">            ) &#123;</span><br><span class="line">                prop.handler(<span class="keyword">this</span>.el, evalExpr(prop.expr, <span class="keyword">this</span>.scope, <span class="keyword">this</span>.owner), propName, <span class="keyword">this</span>, prop);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后把数据变化信息通过 children 往下传递</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.children.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.children[i]._update(changes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面这张图说明了在节点树中，<code>this.data.set('title', 'hello')</code> 带来的视图刷新，遍历过程与数据变化信息的传递经过了哪些节点。左侧最大的点是实际需要更新的节点，红色的线代表遍历过程经过的路径，红色的小圆点代表遍历到的节点。可以看出，虽然需要进行视图更新的节点只有一个，但所有的节点都被遍历到了。</p><div class="figure"><img src="/blog/san-perf/update-flow.png" alt="Update Flow"><p class="caption">Update Flow</p></div><h3 id="节点遍历中断">节点遍历中断</h3><p>从上图中不难发现，与实际的更新行为相比，遍历确定更新节点的消耗要大得多。所以为遍历过程减负，是一个必要的事情。<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 在这方面是怎么做的呢？</p><p>首先，<strong>预热</strong> 过程生成的 <code>hotspot</code> 对象中，有一项 <code>data</code>，包含了节点及其子节点对数据引用的摘要信息。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js" target="_blank" rel="noopener">preheat-a-node.js</a></p><p>然后，在视图更新的节点树遍历过程中，使用 <code>hotspot.data</code> 与数据变化信息进行比对。结果为 false 时意味着数据的变化不会影响当前节点及其子节点的视图，就不会执行自身属性的更新，也不会继续向下遍历。遍历过程在更高层的节点被中断，节省了下层子树的遍历开销。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L240-L241" target="_blank" rel="noopener">element.js#241</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/changes-is-in-data-ref.js" target="_blank" rel="noopener">changes-is-in-data-ref.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">changes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dataHotspot = <span class="keyword">this</span>.aNode.hotspot.data;</span><br><span class="line">    <span class="keyword">if</span> (dataHotspot &amp;&amp; changesIsInDataRef(changes, dataHotspot)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了节点遍历中断的机制，title 数据修改引起视图变更的遍历过程如下。可以看到，灰色的部分都是由于中断，无需到达的节点。</p><div class="figure"><img src="/blog/san-perf/update-flow-opti.png" alt="Update Flow"><p class="caption">Update Flow</p></div><p>有没有似曾相识的感觉？是不是很像 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 中的 <a href="https://reactjs.org/docs/optimizing-performance.html#shouldcomponentupdate-in-action" target="_blank" rel="noopener">shouldComponentUpdate</a>？不过不同的是，由于模板声明包含了对数据的引用，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 可以在框架层面自动做到这一点，组件开发者不需要人工去干这件事了。</p><h3 id="属性更新">属性更新</h3><p>在视图创建过程的章节中，提到过在 <strong>预热</strong> 过程中，我们得到了：</p><ul><li>dynamicProps：哪些属性是动态的。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L122-L142" target="_blank" rel="noopener">preheat-a-node.js#L117</a></li><li>prop.handler：属性的设置操作函数。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/preheat-a-node.js#L124" target="_blank" rel="noopener">preheat-a-node.jsL119</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"&#123;=value=&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面这个例子中，<code>dynamicProps</code> 只包含 <code>value</code>，不包含 <code>type</code>。</p><p>所以在节点的属性更新时，我们只需要遍历 <code>hotspot.dynamicProps</code>，并且直接使用 <code>prop.handler</code> 来执行属性更新。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L259-L277" target="_blank" rel="noopener">element.js#L259-L277</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">changes</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先看自身的属性有没有需要更新的</span></span><br><span class="line">    <span class="keyword">var</span> dynamicProps = <span class="keyword">this</span>.aNode.hotspot.dynamicProps;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = dynamicProps.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> prop = dynamicProps[i];</span><br><span class="line">        <span class="keyword">var</span> propName = prop.name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, changeLen = changes.length; j &lt; changeLen; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> change = changes[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isDataChangeByElement(change, <span class="keyword">this</span>, propName)</span><br><span class="line">                &amp;&amp; changeExprCompare(change.expr, prop.hintExpr, <span class="keyword">this</span>.scope)</span><br><span class="line">            ) &#123;</span><br><span class="line">                prop.handler(<span class="keyword">this</span>.el, evalExpr(prop.expr, <span class="keyword">this</span>.scope, <span class="keyword">this</span>.owner), propName, <span class="keyword">this</span>, prop);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="immutable">Immutable</h3><p><a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">Immutable</a> 在视图更新中最大的意义是，可以无脑认为 === 时，数据是没有变化的。在很多场景下，对视图是否需要更新的判断变得简单很多。否则判断的成本对应用来说是不可接受的。</p><p>但是，<a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">Immutable</a> 可能会导致开发过程的更多成本。如果开发者不借助任何库，只使用原始的 JavaScript，一个对象的赋值会写的有些麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123;</span><br><span class="line">        b1: <span class="number">2</span>,</span><br><span class="line">        b2: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutable</span></span><br><span class="line">obj.b.b1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// immutable</span></span><br><span class="line">obj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj, &#123;<span class="attr">b</span>: <span class="built_in">Object</span>.assign(&#123;&#125;, obj.b, &#123;<span class="attr">b1</span>: <span class="number">5</span>&#125;)&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的<a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作</a>是通过 data 上的方法提供的，所以内部实现可以天然 immutable，这利于视图更新操作中的一些判断。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L209" target="_blank" rel="noopener">data.js#L209</a></p><p>由于视图刷新是根据数据变化信息进行的，所以判断当数据没有变化时，不产生数据变化信息就行了。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L204" target="_blank" rel="noopener">data.js#L204</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L570" target="_blank" rel="noopener">for-node.jsL570</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L595" target="_blank" rel="noopener">L595</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L679" target="_blank" rel="noopener">L679</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L731" target="_blank" rel="noopener">L731</a></p><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 期望开发者对数据操作细粒度的使用<a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作方法</a>。否则，不熟悉 immutable 的开发者可能会碰到如下情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设初始数据如下</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 1,</span></span><br><span class="line"><span class="comment">    b: &#123;</span></span><br><span class="line"><span class="comment">        b1: 2,</span></span><br><span class="line"><span class="comment">        b2: 3</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">this</span>.data.get(<span class="string">'b'</span>);</span><br><span class="line">b.b1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 b 对象引用不变，会导致视图不刷新</span></span><br><span class="line"><span class="keyword">this</span>.data.set(<span class="string">'b'</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法。set 操作在 san 内部是 immutable 的</span></span><br><span class="line"><span class="keyword">this</span>.data.set(<span class="string">'b.b1'</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="列表更新">列表更新</h3><h4 id="列表数据操作方法">列表数据操作方法</h4><p>上文中我们提到，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的视图更新机制是基于数据变化信息的。<a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作方法</a> 提供了一系列方法，会 fire changeObj。changeObj 只有两种类型： <strong>SET</strong> 和 <strong>SPLICE</strong>。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data-change-type.js" target="_blank" rel="noopener">data-change-type.js</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L211" target="_blank" rel="noopener">data.js#L211</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L352" target="_blank" rel="noopener">data.js#L352</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SET</span></span><br><span class="line">changeObj = &#123;</span><br><span class="line">    type: DataChangeType.SET,</span><br><span class="line">    expr,</span><br><span class="line">    value,</span><br><span class="line">    option</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPLICE</span></span><br><span class="line">changeObj = &#123;</span><br><span class="line">    type: DataChangeType.SPLICE,</span><br><span class="line">    expr,</span><br><span class="line">    index,</span><br><span class="line">    deleteCount,</span><br><span class="line">    value,</span><br><span class="line">    insertions,</span><br><span class="line">    option</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 提供的<a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作方法</a>里，很多是针对数组的，并且大部分与 JavaScript 原生的数组方法是一致的。从 changeObj 的类型可以容易看出，最基础的方法只有 <code>splice</code> 一个，其他方法都是 <code>splice</code> 之上的封装。</p><ul><li>push</li><li>pop</li><li>shift</li><li>unshift</li><li>remove</li><li>removeAt</li><li>splice</li></ul><p>基于数据变化信息的视图更新机制，意味着数据操作的粒度越细越精准，视图更新的负担越小性能越高。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad performance</span></span><br><span class="line"><span class="keyword">this</span>.data.set(<span class="string">'list[0]'</span>, &#123;</span><br><span class="line">    name: <span class="string">'san'</span>,</span><br><span class="line">    id: <span class="keyword">this</span>.data.get(<span class="string">'list[0].id'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line"><span class="keyword">this</span>.data.set(<span class="string">'list[0].name'</span>, <span class="string">'san'</span>);</span><br></pre></td></tr></table></figure><h4 id="更新过程">更新过程</h4><p>我们看个简单的例子：下图中，我们要把第一行的列表更新成第二行，需要插入绿色部分，更新黄色部分，删除红色部分。</p><div class="figure"><img src="/blog/san-perf/list-eg.png" alt="List Update"><p class="caption">List Update</p></div><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js" target="_blank" rel="noopener">ForNode</a> 负责列表的渲染和更新。在更新过程里：</p><ul><li><a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L242" target="_blank" rel="noopener">_update</a> 方法接收数据变化信息后，根据类型进行分发</li><li><a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L350" target="_blank" rel="noopener">_updateArray</a> 负责处理数组类型的更新。其遍历数据变化信息，计算得到更新动作，最后执行更新行为。</li></ul><p>假设数据变化信息为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    <span class="comment">// insert [2, 3], pos 1</span></span><br><span class="line">    <span class="comment">// update 4</span></span><br><span class="line">    <span class="comment">// remove 7</span></span><br><span class="line">    <span class="comment">// remove 10</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在遍历数据变化信息前，我们先初始化一个和当前 children 等长的数组：childrenChanges。其用于存储 children 里每个子节点的数据变化信息。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L352" target="_blank" rel="noopener">for-node.js#L352</a></p><p>同时，我们初始化一个 disposeChildren 数组，用于存储需要被删除的节点。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L362" target="_blank" rel="noopener">for-node.js#L362</a></p><div class="figure"><img src="/blog/san-perf/children-changes.png" alt="childrenChanges"><p class="caption">childrenChanges</p></div><p>接下来，<a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L376" target="_blank" rel="noopener">_updateArray</a> 循环处理数据变化信息。当遇到插入时，同时扩充 children 和 childrenChanges 数组。</p><div class="figure"><img src="/blog/san-perf/children-changes-insert.png" alt="childrenChanges"><p class="caption">childrenChanges</p></div><p>当遇到更新时，如果更新对应的是某一项，则对应该项的 childrenChanges 添加更新信息。</p><div class="figure"><img src="/blog/san-perf/children-changes-update.png" alt="childrenChanges"><p class="caption">childrenChanges</p></div><p>当遇到删除时，我们把要删除的子节点从 children 移除，放入 disposeChildren。同时，childrenChanges 里相应位置的项也被移除。</p><div class="figure"><img src="/blog/san-perf/children-changes-remove.png" alt="childrenChanges"><p class="caption">childrenChanges</p></div><p>遍历数据变化信息结束后，执行更新行为分成两步：See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L772-L823" target="_blank" rel="noopener">for-node.js#L772-L823</a></p><ol style="list-style-type: decimal"><li>先执行删除 disposeChildren</li><li>遍历 children，对标记全新的子节点执行创建与插入，对存在的节点根据 childrenChanges 相应位置的信息执行更新</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._disposeChildren(disposeChildren, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doCreateAndUpdate();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>下面，我们看看常见的列表更新场景下， <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 都有哪些性能优化的手段。</p><h4 id="添加项">添加项</h4><p>在遍历数据变化信息时，遇到添加项，往 children 和 childrenChanges 中填充的只是 <code>undefined</code> 或 <code>0</code> 的占位值，不初始化新节点。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L518-L520" target="_blank" rel="noopener">for-node.js#L518-L520</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spliceArgs = [changeStart + deleteCount, <span class="number">0</span>].concat(<span class="keyword">new</span> <span class="built_in">Array</span>(newCount));</span><br><span class="line"><span class="keyword">this</span>.children.splice.apply(<span class="keyword">this</span>.children, spliceArgs);</span><br><span class="line">childrenChanges.splice.apply(childrenChanges, spliceArgs);</span><br></pre></td></tr></table></figure><p>由于 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的视图是异步更新的，当前更新周期可能包含多个数据操作。如果这些数据操作中创建了一个项又删除了的话，在遍历数据变化信息过程中初始化新节点就是没有必要的浪费。所以创建节点的操作放到后面 <strong>执行更新</strong> 的阶段。</p><h4 id="删除项">删除项</h4><p>前文中提过，视图创建的过程，对于 DOM 的创建是挨个 <code>createElement</code> 并 <code>appendChild</code> 到 <code>parentNode</code> 中的。但是在删除的时候，我们并不需要把整棵子树上的节点都挨个删除，只需要把要删除子树的根元素从 <code>parentNode</code> 中 <code>removeChild</code>。</p><p>所以，对于 Element、TextNode、ForNode、IfNode 等节点的 <code>dispose</code> 方法，都包含一个隐藏参数：<code>noDetach</code>。当接收到的值为 <code>true</code> 时，节点只做必要的清除操作（移除 DOM 上挂载的事件、清理节点树的引用关系），不执行其对应 DOM 元素的删除操作。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/text-node.js#L118" target="_blank" rel="noopener">text-node.js#L118</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/node-own-simple-dispose.js#L22" target="_blank" rel="noopener">node-own-simple-dispose.js#L22</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L211" target="_blank" rel="noopener">element.js#L211</a> etc...</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!noDetach) &#123;</span><br><span class="line">    removeEl(<span class="keyword">this</span>.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在很多情况下，一次视图更新周期中如果有数组项的删除，是不会有对其他项的更新操作的。所以我们增加了 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L368" target="_blank" rel="noopener">isOnlyDispose</a> 变量用于记录是否只包含数组项删除操作。在 <strong>执行更新</strong> 阶段，如果该项为 <code>true</code>，则完成删除动作后不再遍历 <code>children</code> 进行子项更新。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L787" target="_blank" rel="noopener">for-node.js#L787</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isOnlyDispose) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对相应的项进行更新</span></span><br><span class="line"><span class="comment">// 如果不attached则直接创建，如果存在则调用更新函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newLen; i++) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="length">length</h4><p>数据变化（添加项、删除项等）可能会导致数组长度变化，数组长度也可能会被数据引用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">s-for</span>=<span class="string">"item, index in list"</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;/&#123;&#123;list.length&#125;&#125; item<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这种场景下，即使只添加或删除一项，整个列表视图都需要被刷新。由于子节点的更新是在 <strong>执行更新</strong> 阶段通过 _update 方法传递数据变化信息的，所以在 <strong>执行更新</strong> 前，我们根据以下两个条件，判断是否需要为子节点增加 length 变更信息。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L752-L767" target="_blank" rel="noopener">for-node.js#L752-L767</a></p><ul><li>数组长度是否发生变化</li><li>通过数据摘要判断子项视图是否依赖 length 数据。这个判断逻辑上是多余的，但是可以减少子项更新的成本</li></ul><h4 id="清空">清空</h4><p>首先，当数组长度为 0 时，显然整个列表项直接清空就行了，数据变化信息可以完全忽略，不需要进行多余的遍历。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L248-L251" target="_blank" rel="noopener">for-node.js#L248-L251</a></p><p>其次，如果一个元素里的所有元素都是由列表项组成的，那么元素的删除可以<strong>暴力清除</strong>：通过一次 <code>parentNode.textContent = ''</code> 完成，无需逐项从父元素中移除。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L316-L332" target="_blank" rel="noopener">for-node.js#L316-L332</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码节选</span></span><br><span class="line"><span class="keyword">var</span> violentClear = !<span class="keyword">this</span>.aNode.directives.transition</span><br><span class="line">    &amp;&amp; !children</span><br><span class="line">    <span class="comment">// 是否 parent 的唯一 child</span></span><br><span class="line">    &amp;&amp; len &amp;&amp; parentFirstChild === <span class="keyword">this</span>.children[<span class="number">0</span>].el &amp;&amp; parentLastChild === <span class="keyword">this</span>.el</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (violentClear) &#123;</span><br><span class="line">    parentEl.textContent = <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子项更新">子项更新</h4><p>想象下面这个列表数据子项的变更：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myApp.data.set(<span class="string">'list[2]'</span>, <span class="string">'two'</span>);</span><br></pre></td></tr></table></figure><p>对于 ForNode 的更新：</p><ul><li>首先使用 <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L378" target="_blank" rel="noopener">changeExprCompare</a> 方法判断数据变化对象与列表引用数据声明之间的关系。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/change-expr-compare.js" target="_blank" rel="noopener">change-expr-compare.js</a></li><li>如果属于子项更新，则转换成对应子项的数据变更信息，其他子项对该信息无感知。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L426" target="_blank" rel="noopener">for-node.js#L426</a></li></ul><div class="figure"><img src="/blog/san-perf/update-for-item.png" alt="Update For Item"><p class="caption">Update For Item</p></div><p>从上图的更新过程可以看出，子项更新的更新过程能精确处理最少的节点。数据变更时精准地更新节点是 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的优势。</p><h4 id="整列表变更">整列表变更</h4><p>对于整列表变更，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的处理原则是：尽可能重用当前存在的节点。原列表与新列表数据相比：</p><ul><li>原列表项更多</li><li>新列表项更多</li><li>一样多</li></ul><p>我们采用了如下的处理过程，保证原列表与新列表重叠部分节点执行更新操作，无需删除再创建：</p><ol style="list-style-type: decimal"><li>如果原列表项更多，从尾部开始把多余的部分标记清除。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L717-L721" target="_blank" rel="noopener">for-node.js#L717-L721</a></li><li>从起始遍历新列表。如果在旧列表长度范围内，标记更新(See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L730-L740" target="_blank" rel="noopener">for-node.js#L730-L740</a>)；如果是新列表多出的部分，标记新建(See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L742" target="_blank" rel="noopener">for-node.js#L742</a>)。</li></ol><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 鼓励开发者细粒度的使用<a href="https://baidu.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作方法</a>，但总有无法精准进行数据操作，只能直接 <a href="https://baidu.github.io/san/tutorial/data-method/#set" target="_blank" rel="noopener">set</a> 整个数组。举一个最常见的例子：数据是从服务端返回的 JSON。在这种场景下，就是 <a href="https://baidu.github.io/san/tutorial/for/#trackBy" target="_blank" rel="noopener">trackBy</a> 发挥作用的时候了。</p><h4 id="trackby">trackBy</h4><blockquote><p>我就是我，是颜色不一样的烟火。 -- 张国荣《我》</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">s-for</span>=<span class="string">"p in persons trackBy p.name"</span>&gt;</span>&#123;&#123;p.name&#125;&#125; - &#123;&#123;p.email&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://baidu.github.io/san/tutorial/for/#trackBy" target="_blank" rel="noopener">trackBy</a> 也叫 keyed，其作用就是当列表数据 <strong>无法进行引用比较</strong> 时，告诉框架一个依据，框架就可以判断出新列表中的项是原列表中的哪一项。上文提到的：服务端返回的数据，是 <strong>无法进行引用比较</strong> 的典型例子。</p><p>这里我们不说 <a href="https://baidu.github.io/san/tutorial/for/#trackBy" target="_blank" rel="noopener">trackBy</a> 的整个更新细节，只提一个优化手段。这个优化手段不是 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 独有的，而是经典的优化手段。</p><div class="figure"><img src="/blog/san-perf/trackby-opti.png" alt="TrackBy Optimize"><p class="caption">TrackBy Optimize</p></div><p>可以看到，我们从新老列表的头部和尾部进行分别遍历，找出新老列表头部和尾部的相同项，并把他们排除。这样剩下需要进行 trackBy 的项可能就少多了。对应到常见的视图变更场景，该优化手段都能发挥较好的作用。</p><ul><li>添加：无论在什么位置添加几项，该优化都能发挥较大作用</li><li>删除：无论在什么位置删除几项，该优化都能发挥较大作用</li><li>更新部分项：头尾都有更新时，该优化无法发挥作用。也就是说，对于长度固定的列表有少量新增项时，该优化无用。不过 trackBy 过程在该场景下，性能消耗不高</li><li>更新全部项：trackBy 过程在该场景下，性能消耗很低</li><li>交换：相邻元素的交换，该优化都能发挥较大作用。交换的元素间隔越小，该优化发挥作用越大</li></ul><p>从 <a href="https://krausest.github.io/js-framework-benchmark/current.html" target="_blank" rel="noopener">benchmark</a> 的结果能看出来，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 在 <a href="https://baidu.github.io/san/tutorial/for/#trackBy" target="_blank" rel="noopener">trackBy</a> 下也有较好的性能。</p><div class="figure"><img src="/blog/san-perf/san-perf-keyed.png" alt="San keyed performance"><p class="caption">San keyed performance</p></div><h2 id="吹毛求疵">吹毛求疵</h2><p>在这个部分，我会列举一些大多数人觉得知道、但又不会这么去做的优化写法。这些优化写法貌似对性能没什么帮助，但是积少成多，带来的性能增益还是不可忽略的。</p><h3 id="避免-call-和-apply">避免 call 和 apply</h3><p>call 和 apply 是 JavaScript 中的魔法，也是性能的大包袱。在 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 中，我们尽可能减少 call 和 apply 的使用。下面列两个点：</p><p>比如，对 filter 的处理中，内置的 filter 由于都是 pure function，我们明确知道运行结果不依赖 this，并且参数个数都是确定的，所以无需使用 call。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/eval-expr.js#L164-L172" target="_blank" rel="noopener">eval-expr.js#L164-L172</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (owner.filters[filterName]) &#123;</span><br><span class="line">    value = owner.filters[filterName].apply(</span><br><span class="line">        owner,</span><br><span class="line">        [value].concat(evalArgs(filter.args, data, owner))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (DEFAULT_FILTERS[filterName]) &#123;</span><br><span class="line">    value = DEFAULT_FILTERS[filterName](value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如，Component 和 Element 之间应该是继承关系，create、attach、dispose、toPhase 等方法有很多可以复用的逻辑。基于性能的考虑，实现中并没有让 Component 和 Element 发生关系。对于复用的部分：</p><ul><li>复用逻辑较少的直接再写一遍（See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/component.js#L355" target="_blank" rel="noopener">component.js#L355</a>）</li><li>复用逻辑多的，部分通过函数直接调用的形式复用（See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element-get-transition.js" target="_blank" rel="noopener">element-get-transition.js</a> etc...），部分通过函数挂载到 prototype 成为实例方法的形式复用（See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element-own-dispose.js" target="_blank" rel="noopener">element-own-dispose.js</a> etc...）。场景和例子比较多，就不一一列举了。</li></ul><h3 id="减少中间对象">减少中间对象</h3><p>看到这里的你不知是否记得，在 <strong>创建节点</strong> 章节中，提到节点的函数签名不合并成一个数组，就是为了防止中间对象的创建。中间对象不止是创建时有开销，触发 GC 回收内存也是有开销的。在 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 的实现中，我们尽可能避免中间对象的创建。下面列两个点：</p><p>数据操作的过程，直接传递表达式层级数组，以及当前指针位置。不使用 slice 创建表达式子层级数组。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L138" target="_blank" rel="noopener">data.js#L138</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immutableSet</span>(<span class="params">source, exprPaths, pathsStart, pathsLen, value, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathsStart &gt;= pathsLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>data 创建时如果传入初始数据对象，以此为准，避免 extend 使初始数据对象变成中间对象。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/data.js#L23" target="_blank" rel="noopener">data.js#L23</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Data</span>(<span class="params">data, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">this</span>.raw = data || &#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.listeners = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少函数调用">减少函数调用</h3><p>函数调用本身的开销是很小的，但是调用本身也会初始化环境对象，调用结束后环境对象也需要被回收。<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 对函数调用较为频繁的地方，做了避免调用的条件判断。下面列两个点：</p><p>element 在创建子元素时，判断子元素构造器是否存在，如果存在则无需调用 createNode 函数。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/element.js#L167-L169" target="_blank" rel="noopener">element.js#L167-L169</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = childANode.Clazz</span><br><span class="line">    ? <span class="keyword">new</span> childANode.Clazz(childANode, <span class="keyword">this</span>, <span class="keyword">this</span>.scope, <span class="keyword">this</span>.owner)</span><br><span class="line">    : createNode(childANode, <span class="keyword">this</span>, <span class="keyword">this</span>.scope, <span class="keyword">this</span>.owner);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/baidu/san/blob/master/doc/anode.md" target="_blank" rel="noopener">ANode</a> 中对定值表达式（数字、bool、字符串字面量）的值保存在对象的 value 属性中。<code>evalExpr</code> 方法开始时根据 <code>expr.value != null</code> 返回。不过在调用频繁的场景（比如文本的拼接、表达式变化比对、等等），会提前进行一次判断，减少 <code>evalExpr</code> 的调用。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/eval-expr.js#L203" target="_blank" rel="noopener">eval-expr.js#L203</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/change-expr-compare.js#L77" target="_blank" rel="noopener">change-expr-compare.js#L77</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf += seg.value || evalExpr(seg, data, owner);</span><br></pre></td></tr></table></figure><p>另外，还有很重要的一点：<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 里虽然实现了 <code>each</code> 方法，但是在视图创建、视图更新、变更判断、表达式取值等关键性的过程中，还是直接使用 for 进行遍历，就是为了减少不必要的函数调用开销。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/util/each.js" target="_blank" rel="noopener">each.js</a> <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/runtime/eval-expr.js" target="_blank" rel="noopener">eval-expr.js</a> etc...</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad performance</span></span><br><span class="line">each(expr.segs.length, <span class="function"><span class="keyword">function</span> (<span class="params">seg</span>) </span>&#123;</span><br><span class="line">    buf += seg.value || evalExpr(seg, data, owner);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = expr.segs.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> seg = expr.segs[i];</span><br><span class="line">    buf += seg.value || evalExpr(seg, data, owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少对象遍历">减少对象遍历</h3><p>使用 for...in 进行对象的遍历是非常耗时的操作，<a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 在视图创建、视图更新等过程中，当运行过程明确时，尽可能不使用 for...in 进行对象的遍历。一个比较容易被忽略的场景是对象的 extend，其隐藏了 for...in 遍历过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="keyword">var</span> value = source[key];</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">                target[key] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从一个对象创建一个大部分成员都一样的新对象时，避免使用 <code>extend</code>。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/for-node.js#L404" target="_blank" rel="noopener">for-node.jsL404</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad performance</span></span><br><span class="line">change = extend(</span><br><span class="line">    extend(&#123;&#125;, change),</span><br><span class="line">    &#123;</span><br><span class="line">        expr: createAccessor(<span class="keyword">this</span>.itemPaths.concat(changePaths.slice(forLen + <span class="number">1</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line">change = change.type === DataChangeType.SET</span><br><span class="line">    ? &#123;</span><br><span class="line">        type: change.type,</span><br><span class="line">        expr: createAccessor(</span><br><span class="line">            <span class="keyword">this</span>.itemPaths.concat(changePaths.slice(forLen + <span class="number">1</span>))</span><br><span class="line">        ),</span><br><span class="line">        value: change.value,</span><br><span class="line">        option: change.option</span><br><span class="line">    &#125;</span><br><span class="line">    : &#123;</span><br><span class="line">        index: change.index,</span><br><span class="line">        deleteCount: change.deleteCount,</span><br><span class="line">        insertions: change.insertions,</span><br><span class="line">        type: change.type,</span><br><span class="line">        expr: createAccessor(</span><br><span class="line">            <span class="keyword">this</span>.itemPaths.concat(changePaths.slice(forLen + <span class="number">1</span>))</span><br><span class="line">        ),</span><br><span class="line">        value: change.value,</span><br><span class="line">        option: change.option</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>将一个对象的成员赋予另一个对象时，避免使用 <code>extend</code>。See <a href="https://github.com/baidu/san/blob/15935bdaad42246742e16759f789af536592c3b7/src/view/component.js#L113" target="_blank" rel="noopener">component.jsL113</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad performance</span></span><br><span class="line">extend(<span class="keyword">this</span>, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line"><span class="keyword">this</span>.owner = options.owner;</span><br><span class="line"><span class="keyword">this</span>.scope = options.scope;</span><br><span class="line"><span class="keyword">this</span>.el = options.el;</span><br></pre></td></tr></table></figure><h2 id="最后">最后</h2><p>性能对于一个框架来说，是非常重要的事情。应用开发的过程通常很少会关注框架的实现；而如果框架实现有瓶颈，应用开发工程师其实是很难解决的。开发一时爽，调优火葬场的故事，发生得太多了。</p><p><a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 在性能方面做了很多工作，但是看下来，其实没有什么非常深奥难以理解的技术。我们仅仅是觉得性能很重要，并且尽可能细致的考虑和实现。因为我们不希望自己成为应用上的瓶颈，也不希望性能成为开发者在选型时犹豫的理由。</p><p>如果你看到这里，觉得 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">San</a> 还算有诚意，或者觉得有收获，给个 <a href="https://github.com/baidu/san/" target="_blank" rel="noopener">Star</a> 呗。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个 MVVM 框架的性能进化之路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;性能一直是 &lt;a href=&quot;https://medium.freecodecamp.org/the-12-things-you-need-to-consider-when-evaluating-any-new-javascript-library-3908c4ed3f49&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;框架选型&lt;/a&gt; 最重要的考虑因素之一。&lt;a href=&quot;https://baidu.github.io/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;San&lt;/a&gt; 从设计之初就希望不要因为自身的短板（性能、体积、兼容性等）而成为开发者为难的理由，所以我们在性能上投入了很多的关注和精力，效果至少从 &lt;a href=&quot;https://krausest.github.io/js-framework-benchmark/current.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;benchmark&lt;/a&gt; 看来，还不错。&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/blog/san-perf/san-perf-non-keyed.png&quot; alt=&quot;San non-keyed performance&quot;&gt;&lt;p class=&quot;caption&quot;&gt;San non-keyed performance&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;将近 2 年以前，我发了一篇 &lt;a href=&quot;https://efe.baidu.com/blog/san-a-traditional-mvvm-component-framework/&quot;&gt;San - 一个传统的MVVM组件框架&lt;/a&gt;。对 &lt;a href=&quot;https://baidu.github.io/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;San&lt;/a&gt; 设计初衷感兴趣的同学可以翻翻。我一直觉得框架选型的时候，了解它的调性是非常关键的一点。&lt;/p&gt;
&lt;p&gt;不过其实，大多数应用场景的框架选型中，&lt;strong&gt;知名度&lt;/strong&gt; 是最主要的考虑因素，因为 &lt;strong&gt;知名度&lt;/strong&gt; 意味着你可以找到更多的人探讨、可以找到更多周边、可以更容易招聘熟手或者以后自己找工作更有优势。所以本文的目的并不是将你从三大阵营（&lt;a href=&quot;https://reactjs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React&lt;/a&gt;、&lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;、&lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular&lt;/a&gt;）拉出来，而是想把 &lt;a href=&quot;https://github.com/baidu/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;San&lt;/a&gt; 的性能经验分享给你。这些经验无论在应用开发，还是写一些基础的东西，都会有所帮助。&lt;/p&gt;
&lt;p&gt;在正式开始之前，惯性先厚脸皮求下 &lt;a href=&quot;https://github.com/baidu/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Star&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MVVM" scheme="http://efe.baidu.com/tags/MVVM/"/>
    
      <category term="San" scheme="http://efe.baidu.com/tags/San/"/>
    
  </entry>
  
  <entry>
    <title>浏览器往返缓存（Back/Forward cache）问题的分析与解决</title>
    <link href="http://efe.baidu.com/blog/bfcache-analysis-and-fix/"/>
    <id>http://efe.baidu.com/blog/bfcache-analysis-and-fix/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-10T14:21:46.930Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是往返缓存backforward-cache">什么是往返缓存（Back/Forward cache）</h3><p>往返缓存（<code>Back/Forward cache</code>，下文中简称<code>bfcache</code>）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到<code>bfcache</code>中；当用户点击后退按钮的时候，将页面直接从<code>bfcache</code>中加载，节省了网络请求的时间。</p><p>但是<code>bfcache</code>的引入，导致了很多问题。下面，举一个我们遇到的场景：</p><div class="figure"><img src="/blog/bfcache-analysis-and-fix/img/sample.jpg" alt="sample"><p class="caption">sample</p></div><p>页面A是一个任务列表，用户从A页面选择了“任务1：看新闻”，点击“去完成”跳转到B页面。当用户进入B页面后，任务完成。此时用户点击回退按钮，会回退到A页面。此时的A页面“任务1：看新闻”的按钮，应该需要标记为“已完成”，由于<code>bfcache</code>的存在，当存入<code>bfcache</code>时，“任务1”的按钮是“去完成”，所以此时回来，按钮也是“去完成”，而不会标记为“已完成”。</p><p>既然bug产生了，我们该如何去解决它？很多文章都会提到<code>unload</code>事件，但是我们实际进行了测试发现并不好用。于是，为了解决问题，我们的<code>bfcache</code>探秘之旅开始了。</p><a id="more"></a><h3 id="bfcache-探秘">bfcache 探秘</h3><p>在检索<code>page cache in chromium</code>的时候，我们发现了这个issue：https://bugs.chromium.org/p/chromium/issues/detail?id=229605 。里面提到 chromium（chrome的开源版本）在很久以前就已经将<code>PageCache</code>（即<code>bfcache</code>）这部分代码移除了。也就是说现在的chrome应该是没有这个东西的。可以确定的是，chrome以前的版本中，<code>bfcache</code>的实现是从<code>webkit</code>中拿来的，加上我们项目目前面向的用户主体就是 iOS + Android，iOS下是基于Webkit，Android基于chrome（且这部分功能也是源于webkit）。因此追溯这个问题，我们只要专注于研究<code>webkit</code>里<code>bfcache</code>的逻辑即可。</p><p>同样通过上文中描述的commit记录，我们也很快定位到了<code>PageCache</code>相关逻辑在Webkit中的位置：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/history/PageCache.cpp" target="_blank" rel="noopener">webkit/Source/WebCore/history/PageCache.cpp</a>。</p><p>该文件中包含的两个方法引起了我们的注意：<code>canCachePage</code>和<code>canCacheFrame</code>。这里的<code>Page</code>即是我们通常理解中的“网页”，而我们也知道网页中可以嵌套<code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>等标签来置入其他页面。所以，<code>Page</code>和<code>Frame</code>的概念就很明确了。而在<code>canCachePage</code>方法中，是调用了<code>canCacheFrame</code>的，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给定 page 的 mainFrame 被传入了 canCacheFrame</span></span><br><span class="line"><span class="keyword">bool</span> isCacheable = canCacheFrame(page.mainFrame(), diagnosticLoggingClient, indentLevel + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>源代码链接：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/history/PageCache.cpp#L199" target="_blank" rel="noopener">webkit/Source/WebCore/history/PageCache.cpp</a></p><p>因此，重头戏就在<code>canCacheFrame</code>了。</p><p><code>canCacheFrame</code>方法返回的是一个布尔值，也就是其中变量<code>isCacheable</code>的值。那么，<code>isCacheable</code>的判断策略是什么？更重要的，这里面的策略，有哪些是我们能够利用到的。</p><p>注意到这里的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;ActiveDOMObject*&gt; unsuspendableObjects;</span><br><span class="line"><span class="keyword">if</span> (frame.document() &amp;&amp; !frame.document()-&gt;canSuspendActiveDOMObjectsForDocumentSuspension(&amp;unsuspendableObjects)) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">    isCacheable = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码链接：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/history/PageCache.cpp#L150" target="_blank" rel="noopener">webkit/Source/WebCore/history/PageCache.cpp</a></p><p>很明显<code>canSuspendActiveDOMObjectsForDocumentSuspension</code>是一个非常重要的方法，该方法中的重要信息见如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ScriptExecutionContext::canSuspendActiveDOMObjectsForDocumentSuspension(Vector&lt;ActiveDOMObject*&gt;* unsuspendableObjects)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something here...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canSuspend = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something here...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We assume that m_activeDOMObjects will not change during iteration: canSuspend</span></span><br><span class="line">    <span class="comment">// functions should not add new active DOM objects, nor execute arbitrary JavaScript.</span></span><br><span class="line">    <span class="comment">// An ASSERT_WITH_SECURITY_IMPLICATION or RELEASE_ASSERT will fire if this happens, but it's important to code</span></span><br><span class="line">    <span class="comment">// canSuspend functions so it will not happen!</span></span><br><span class="line">    ScriptDisallowedScope::InMainThread scriptDisallowedScope;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* activeDOMObject : m_activeDOMObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!activeDOMObject-&gt;canSuspendForDocumentSuspension()) &#123;</span><br><span class="line">            canSuspend = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// someting here</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something here...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> canSuspend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码链接：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/dom/ScriptExecutionContext.cpp#L225" target="_blank" rel="noopener">webkit/Source/WebCore/dom/ScriptExecutionContext.cpp</a></p><p>在这一部分，可以看到他调用每一个 <code>ActiveDOMObject</code> 的 <code>canSuspendForDocumentSuspension</code> 方法，只要有一个返回了<code>false</code>，<code>canSuspend</code>就会是<code>false</code>（Suspend这个单词是挂起的意思，也就是说存入<code>bfcache</code>对于浏览器来说就是把页面上的<code>frame</code>挂起了）。</p><p>接下来，关键的<code>ActiveDOMObject</code>定义在：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/dom/ActiveDOMObject.h#L46" target="_blank" rel="noopener">webkit/Source/WebCore/dom/ActiveDOMObject.h</a> ，该文件这部分注释，已经告诉了我们最想要的信息。</p><blockquote><p>The canSuspendForDocumentSuspension() function is used by the caller if there is a choice between suspending and stopping. For example, a page won't be suspended and placed in the back/forward cache if it contains any objects that cannot be suspended.</p></blockquote><p><code>canSuspendForDocumentSuspension</code> 用于帮助函数调用者在“挂起（suspending）”与“停止”间做出选择。例如，一个页面如果包含任何不能被挂起的对象的话，那么它就不会被挂起并放到<code>PageCache</code>中。</p><p>接下来，我们要找的就是，哪些对象是不能被挂起的？在<code>WebCore</code>目录下，搜索包含<code>canSuspendForDocumentSuspension() const</code>关键字的<code>.cpp</code>文件，能找到48个结果。大概看了一下，最好用的<code>objects that cannot be suspended</code>应该就是<code>Worker</code>对象了，见代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Worker::canSuspendForDocumentSuspension() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里其实是有一个 FIXME 的，看来 webkit 团队也觉得直接 return false 有点简单粗暴。</span></span><br><span class="line">    <span class="comment">// 不过还是等哪天他们真的修了再说吧</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> It is not currently possible to suspend a worker, so pages with workers can not go into page cache.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码链接：<a href="https://github.com/WebKit/webkit/blob/0fce2cb9b2fd61f9f249f09a14b40ac163ab16c6/Source/WebCore/workers/Worker.cpp#L144" target="_blank" rel="noopener">webkit/Source/WebCore/workers/Worker.cpp</a></p><h3 id="解决方案">解决方案</h3><p>业务上添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// disable bfcache</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> bfWorker = <span class="keyword">new</span> Worker(<span class="built_in">window</span>.URL.createObjectURL(<span class="keyword">new</span> Blob([<span class="string">'1'</span>])));</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'unload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这里绑个事件，构造一个闭包，以免 worker 被垃圾回收导致逻辑失效</span></span><br><span class="line">        bfWorker.terminate();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// if you want to do something here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="thanks-to">Thanks to</h3><ul><li><span class="citation">[@luyuan]</span>(https://github.com/luyuan)</li><li><span class="citation">[@junmer]</span>(https://github.com/junmer)</li><li><span class="citation">[@jiangjiu]</span>(https://github.com/jiangjiu)</li><li><span class="citation">[@zhanfang]</span>(https://github.com/zhanfang)</li></ul><h3 id="相关链接">相关链接</h3><ul><li>https://sites.google.com/a/avassiliev.com/wiki/javascript/back-forward-cache</li><li>https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Working_with_BFCache</li><li>https://bugs.chromium.org/p/chromium/issues/detail?id=229605</li><li>https://stackoverflow.com/questions/158319/is-there-a-cross-browser-onload-event-when-clicking-the-back-button</li><li>http://frontenddev.org/link/browser-page-to-enter-and-leave-the-event-pageshow-pagehide.html</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是往返缓存backforward-cache&quot;&gt;什么是往返缓存（Back/Forward cache）&lt;/h3&gt;
&lt;p&gt;往返缓存（&lt;code&gt;Back/Forward cache&lt;/code&gt;，下文中简称&lt;code&gt;bfcache&lt;/code&gt;）是浏览器为了在用户页面间执行前进后退操作时拥有更加流畅体验的一种策略。该策略具体表现为，当用户前往新页面时，将当前页面的浏览器DOM状态保存到&lt;code&gt;bfcache&lt;/code&gt;中；当用户点击后退按钮的时候，将页面直接从&lt;code&gt;bfcache&lt;/code&gt;中加载，节省了网络请求的时间。&lt;/p&gt;
&lt;p&gt;但是&lt;code&gt;bfcache&lt;/code&gt;的引入，导致了很多问题。下面，举一个我们遇到的场景：&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/blog/bfcache-analysis-and-fix/img/sample.jpg&quot; alt=&quot;sample&quot;&gt;&lt;p class=&quot;caption&quot;&gt;sample&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;页面A是一个任务列表，用户从A页面选择了“任务1：看新闻”，点击“去完成”跳转到B页面。当用户进入B页面后，任务完成。此时用户点击回退按钮，会回退到A页面。此时的A页面“任务1：看新闻”的按钮，应该需要标记为“已完成”，由于&lt;code&gt;bfcache&lt;/code&gt;的存在，当存入&lt;code&gt;bfcache&lt;/code&gt;时，“任务1”的按钮是“去完成”，所以此时回来，按钮也是“去完成”，而不会标记为“已完成”。&lt;/p&gt;
&lt;p&gt;既然bug产生了，我们该如何去解决它？很多文章都会提到&lt;code&gt;unload&lt;/code&gt;事件，但是我们实际进行了测试发现并不好用。于是，为了解决问题，我们的&lt;code&gt;bfcache&lt;/code&gt;探秘之旅开始了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mobile" scheme="http://efe.baidu.com/tags/Mobile/"/>
    
  </entry>
  
  <entry>
    <title>结合源码分析 Node.js 模块加载与运行原理</title>
    <link href="http://efe.baidu.com/blog/nodejs-module-analyze/"/>
    <id>http://efe.baidu.com/blog/nodejs-module-analyze/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-06-14T09:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node.js 的出现，让 JavaScript 脱离了浏览器的束缚，进入了广阔的服务端开发领域。而 Node.js 对 CommonJS 模块化规范的引入，则更是让 JavaScript成为了一门真正能够适应大型工程的语言。</p><p>在 Node.js 中使用模块非常简单，我们日常开发中几乎都有过这样的经历：写一段 JavaScript 代码，require 一些想要的包，然后将代码产物 exports 导出。但是，对于 Node.js 模块化背后的加载与运行原理，我们是否清楚呢。首先抛出以下几个问题：</p><ul><li>Node.js 中的模块支持哪些文件类型？</li><li>核心模块和第三方模块的加载运行流程有什么不同？</li><li>除了 JavaScript 模块以外，怎样去写一个 C/C++ 扩展模块？</li><li>……</li></ul><p>本篇文章，就会结合 Node.js 源码，探究一下以上这些问题背后的答案。</p><a id="more"></a><h3 id="node.js-模块类型">1. Node.js 模块类型</h3><p>在 Node.js 中，模块主要可以分为以下几种类型：</p><ul><li>核心模块：包含在 Node.js 源码中，被编译进 Node.js 可执行二进制文件 JavaScript 模块，也叫 native 模块，比如常用的 http, fs 等等</li><li>C/C++ 模块，也叫 built-in 模块，一般我们不直接调用，而是在 native module 中调用，然后我们再 require</li><li>native 模块，比如我们在 Node.js 中常用的 buffer，fs，os 等 native 模块，其底层都有调用 built-in 模块。</li><li>第三方模块：非 Node.js 源码自带的模块都可以统称第三方模块，比如 express，webpack 等等。<ul><li>JavaScript 模块，这是最常见的，我们开发的时候一般都写的是 JavaScript 模块</li><li>JSON 模块，这个很简单，就是一个 JSON 文件</li><li>C/C++ 扩展模块，使用 C/C++ 编写，编译之后后缀名为 .node</li></ul></li></ul><p>本篇文章中，我们会一一涉及到上述几种模块的加载、运行原理。</p><h3 id="node.js-源码结构一览">2. Node.js 源码结构一览</h3><p>这里使用 Node.js 6.x 版本源码为例子来做分析。去 github 上下载相应版本的 Node.js 源码，可以看到代码大体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── AUTHORS</span><br><span class="line">├── BSDmakefile</span><br><span class="line">├── BUILDING.md</span><br><span class="line">├── CHANGELOG.md</span><br><span class="line">├── CODE_OF_CONDUCT.md</span><br><span class="line">├── COLLABORATOR_GUIDE.md</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── GOVERNANCE.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── README.md</span><br><span class="line">├── android-configure</span><br><span class="line">├── benchmark</span><br><span class="line">├── common.gypi</span><br><span class="line">├── configure</span><br><span class="line">├── deps</span><br><span class="line">├── doc</span><br><span class="line">├── lib</span><br><span class="line">├── node.gyp</span><br><span class="line">├── node.gypi</span><br><span class="line">├── src</span><br><span class="line">├── test</span><br><span class="line">├── tools</span><br><span class="line">└── vcbuild.bat</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>./lib</code>文件夹主要包含了各种 JavaScript 文件，我们常用的 JavaScript native 模块都在这里。</li><li><code>./src</code>文件夹主要包含了 Node.js 的 C/C++ 源码文件，其中很多 built-in 模块都在这里。</li><li><code>./deps</code>文件夹包含了 Node.js 依赖的各种库，典型的如 v8，libuv，zlib 等。</li></ul><p>我们在开发中使用的 release 版本，其实就是从源码编译得到的可执行文件。如果我们想要对 Node.js 进行一些个性化的定制，则可以对源码进行修改，然后再运行编译，得到定制化的 Node.js 版本。这里以 Linux 平台为例，简要介绍一下 Node.js 编译流程。</p><p>首先，我们需要认识一下编译用到的组织工具，即 <code>gyp</code>。Node.js 源码中我们可以看到一个 <code>node.gyp</code>，这个文件中的内容是由 python 写成的一些 JSON-like 配置，定义了一连串的构建工程任务。我们举个例子，其中有一个字段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      &apos;target_name&apos;: &apos;node_js2c&apos;,</span><br><span class="line">      &apos;type&apos;: &apos;none&apos;,</span><br><span class="line">      &apos;toolsets&apos;: [&apos;host&apos;],</span><br><span class="line">      &apos;actions&apos;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &apos;action_name&apos;: &apos;node_js2c&apos;,</span><br><span class="line">          &apos;inputs&apos;: [</span><br><span class="line">            &apos;&lt;@(library_files)&apos;,</span><br><span class="line">            &apos;./config.gypi&apos;,</span><br><span class="line">          ],</span><br><span class="line">          &apos;outputs&apos;: [</span><br><span class="line">            &apos;&lt;(SHARED_INTERMEDIATE_DIR)/node_natives.h&apos;,</span><br><span class="line">          ],</span><br><span class="line">          &apos;conditions&apos;: [</span><br><span class="line">            [ &apos;node_use_dtrace==&quot;false&quot; and node_use_etw==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/notrace_macros.py&apos; ]</span><br><span class="line">            &#125;],</span><br><span class="line">            [&apos;node_use_lttng==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/nolttng_macros.py&apos; ]</span><br><span class="line">            &#125;],</span><br><span class="line">            [ &apos;node_use_perfctr==&quot;false&quot;&apos;, &#123;</span><br><span class="line">              &apos;inputs&apos;: [ &apos;src/perfctr_macros.py&apos; ]</span><br><span class="line">            &#125;]</span><br><span class="line">          ],</span><br><span class="line">          &apos;action&apos;: [</span><br><span class="line">            &apos;python&apos;,</span><br><span class="line">            &apos;tools/js2c.py&apos;,</span><br><span class="line">            &apos;&lt;@(_outputs)&apos;,</span><br><span class="line">            &apos;&lt;@(_inputs)&apos;,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;, # end node_js2c</span><br></pre></td></tr></table></figure><p>这个任务主要的作用从名称 <code>node_js2c</code> 就可以看出来，是将 JavaScript 转换为 C/C++ 代码。这个任务我们下面还会提到。</p><p>首先编译 Node.js，需要提前安装一些工具：</p><ul><li>gcc 和 g++ 4.9.4 及以上版本</li><li>clang 和 clang++</li><li>python 2.6 或者 2.7，这里要注意，只能是这两个版本，不可以为python 3+</li><li>GNU MAKE 3.81 及以上版本</li></ul><p>有了这些工具，进入 Node.js 源码目录，我们只需要依次运行如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configuration</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>即可编译生成可执行文件并安装了。</p><h3 id="从-node-index.js-开始">3. 从 <code>node index.js</code> 开始</h3><p>让我们首先从最简单的情况开始。假设有一个 index.js 文件，里面只有一行很简单的 <code>console.log('hello world')</code> 代码。当输入 <code>node index.js</code> 的时候，Node.js 是如何编译、运行这个文件的呢？</p><p>当输入 Node.js 命令的时候，调用的是 Node.js 源码当中的 main 函数，在 <code>src/node_main.cc</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node_main.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"node.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;VersionHelpers.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wmain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">wchar_t</span> *wargv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// windows下面的入口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">// UNIX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Disable stdio buffering, it interacts poorly with printf()</span></span><br><span class="line">  <span class="comment">// calls elsewhere in the program (e.g., any logging from V8.)</span></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="literal">nullptr</span>, _IONBF, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 关注下面这一行</span></span><br><span class="line">  <span class="keyword">return</span> node::Start(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个文件只做入口用，区分了 Windows 和 Unix 环境。我们以 Unix 为例，在 main 函数中最后调用了 <code>node::Start</code>，这个是在 <code>src/node.cc</code> 文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Start</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">NodeInstanceData <span class="title">instance_data</span><span class="params">(NodeInstanceType::MAIN,</span></span></span><br><span class="line">                                   uv_default_loop(),</span><br><span class="line">                                   argc,</span><br><span class="line">                                   <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>**&gt;(argv),</span><br><span class="line">                                   exec_argc,</span><br><span class="line">                                   exec_argv,</span><br><span class="line">                                   use_debug_agent);</span><br><span class="line">    StartNodeInstance(&amp;instance_data);</span><br><span class="line">    exit_code = instance_data.exit_code();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StartNodeInstance</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        Environment::<span class="function">AsyncCallbackScope <span class="title">callback_scope</span><span class="params">(env)</span></span>;</span><br><span class="line">        LoadEnvironment(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoadEnvironment</span><span class="params">(Environment* env)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(),</span><br><span class="line">                                                        <span class="string">"bootstrap_node.js"</span>);</span><br><span class="line">    Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);</span><br><span class="line">    <span class="keyword">if</span> (try_catch.HasCaught())  &#123;</span><br><span class="line">        ReportException(env, try_catch);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The bootstrap_node.js file returns a function 'f'</span></span><br><span class="line">    CHECK(f_value-&gt;IsFunction());</span><br><span class="line">    Local&lt;Function&gt; f = Local&lt;Function&gt;::Cast(f_value);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    f-&gt;Call(Null(env-&gt;isolate()), <span class="number">1</span>, &amp;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个文件比较长，在上面代码段里，只截取了我们最需要关注的流程片段，调用关系如下： <code>Start -&gt; StartNodeInstance -&gt; LoadEnvironment</code>。</p><p>在 <code>LoadEnvironment</code> 需要我们关注，主要做的事情就是，取出 <code>bootstrap_node.js</code> 中的代码字符串，解析成函数，并最后通过 <code>f-&gt;Call</code> 去执行。</p><p>OK，重点来了，从 Node.js 启动以来，我们终于看到了第一个 JavaScript 文件 <code>bootstrap_node.js</code>，从文件名我们也可以看出这个是一个入口性质的文件。那么我们快去看看吧，该文件路径为 <code>lib/internal/bootstrap_node.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/boostrap_node.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">process</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">startup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (process.argv[<span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = NativeModule.require(<span class="string">'path'</span>);</span><br><span class="line">      process.argv[<span class="number">1</span>] = path.resolve(process.argv[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">const</span> Module = NativeModule.require(<span class="string">'module'</span>);</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      preloadModules();</span><br><span class="line">      run(Module.runMain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  startup();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// bootstrap main module.</span></span><br><span class="line">Module.runMain = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Load the main module--the command line argument.</span></span><br><span class="line">  Module._load(process.argv[<span class="number">1</span>], <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Handle any nextTicks added in the first tick of the program</span></span><br><span class="line">  process._tickCallback();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里我们依然关注主流程，可以看到，<code>bootstrap_node.js</code> 中，执行了一个 <code>startup()</code> 函数。通过 <code>process.argv[1]</code> 拿到文件名，在我们的 <code>node index.js</code> 中，<code>process.argv[1]</code> 显然就是 <code>index.js</code>，然后调用 <code>path.resolve</code> 解析出文件路径。在最后，<code>run(Module.runMain)</code> 来编译执行我们的 <code>index.js</code>。</p><p>而 <code>Module.runMain</code> 函数定义在 <code>lib/module.js</code> 中，在上述代码片段的最后，列出了这个函数，可以看到，主要是调用 <code>Module._load</code> 来加载执行 <code>process.argv[1]</code>。</p><p>下文我们在分析模块的 require 的时候，也会来到 <code>lib/module.js</code> 中，也会分析到 <code>Module._load</code>。<strong><em>因此我们可以看出，Node.js 启动一个文件的过程，其实到最后，也是 <code>require</code> 一个文件的过程，可以理解为是立即 require 一个文件。</em></strong>下面就来分析 require 的原理。</p><h3 id="模块加载原理的关键require">4. 模块加载原理的关键：require</h3><p>我们进一步，假设我们的 <code>index.js</code> 有如下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br></pre></td></tr></table></figure><p>那么当执行这一句代码的时候，会发生什么呢？</p><p>require的定义依然在 <code>lib/module.js</code> 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype.require = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  assert(path, <span class="string">'missing path'</span>);</span><br><span class="line">  assert(<span class="keyword">typeof</span> path === <span class="string">'string'</span>, <span class="string">'path must be a string'</span>);</span><br><span class="line">  <span class="keyword">return</span> Module._load(path, <span class="keyword">this</span>, <span class="comment">/* isMain */</span> <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>require</code> 方法定义在Module的原型链上。可以看到这个方法中，调用了 <code>Module._load</code>。</p><p>我们这么快就又来到了 <code>Module._load</code> 来看看这个关键的方法究竟做了什么吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module._load = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    debug(<span class="string">'Module._load REQUEST %s parent: %s'</span>, request, parent.id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> cachedModule = Module._cache[filename];</span><br><span class="line">  <span class="keyword">if</span> (cachedModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">    debug(<span class="string">'load native module %s'</span>, request);</span><br><span class="line">    <span class="keyword">return</span> NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = <span class="keyword">new</span> Module(filename, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Module._cache[filename] = <span class="built_in">module</span>;</span><br><span class="line"></span><br><span class="line">  tryModuleLoad(<span class="built_in">module</span>, filename);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这段代码的流程比较清晰，具体说来：</p><ol style="list-style-type: decimal"><li>根据文件名，调用 <code>Module._resolveFilename</code> 解析文件的路径</li><li>查看缓存 <code>Module._cache</code> 中是否有该模块，如果有，直接返回</li><li>通过 <code>NativeModule.nonInternalExists</code> 判断该模块是否为核心模块，如果核心模块，调用核心模块的加载方法 <code>NativeModule.require</code></li><li>如果不是核心模块，新创建一个 Module 对象，调用 <code>tryModuleLoad</code> 函数加载模块</li></ol><p>我们首先来看一下 <code>Module._resolveFilename</code>，看懂这个方法对于我们理解 Node.js 的文件路径解析原理很有帮助：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module._resolveFilename = <span class="function"><span class="keyword">function</span>(<span class="params">request, parent, isMain</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> filename = Module._findPath(request, paths, isMain);</span><br><span class="line">  <span class="keyword">if</span> (!filename) &#123;</span><br><span class="line">    <span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Cannot find module '"</span> + request + <span class="string">"'"</span>);</span><br><span class="line">    err.code = <span class="string">'MODULE_NOT_FOUND'</span>;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> filename;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>在 <code>Module._resolveFilename</code> 中调用了 <code>Module._findPath</code>，模块加载的判断逻辑实际上集中在这个方法中，由于这个方法较长，直接附上 github 该方法代码：</p><p><a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L158" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L158</a></p><p>可以看出，文件路径解析的逻辑流程是这样的：</p><ul><li>先生成 cacheKey，判断相应 cache 是否存在，若存在直接返回</li><li>如果 path 的最后一个字符不是 <code>/</code>：<ul><li>如果路径是一个文件并且存在，那么直接返回文件的路径</li><li>如果路径是一个目录，调用 <code>tryPackage</code> 函数去解析目录下的 <code>package.json</code>，然后取出其中的 <code>main</code> 字段所写入的文件路径<ul><li>判断路径如果存在，直接返回</li><li>尝试在路径后面加上 .js, .json, .node 三种后缀名，判断是否存在，存在则返回</li><li>尝试在路径后面依次加上 index.js, index.json, index.node，判断是否存在，存在则返回</li></ul></li><li>如果还不成功，直接对当前路径加上 .js, .json, .node 后缀名进行尝试</li></ul></li><li>如果 path 的最后一个字符是 <code>/</code>：<ul><li>调用 <code>tryPackage</code> ，解析流程和上面的情况类似</li><li>如果不成功，尝试在路径后面依次加上 index.js, index.json, index.node，判断是否存在，存在则返回</li></ul></li></ul><p>解析文件中用到的 <code>tryPackage</code> 和 <code>tryExtensions</code> 方法的 github 链接： <a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L108" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L108</a> <a href="https://github.com/nodejs/node/blob/v6.x/lib/module.js#L146" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/module.js#L146</a></p><p>整个流程可以参考下面这张图： <img src="/blog/nodejs-module-analyze/process1.png" alt="process1"></p><p>而在文件路径解析完成之后，根据文件路径查看缓存是否存在，存在直接返回，不存在的话，走到 3 或者 4 步骤。</p><p>这里，在 3、4 两步产生了两个分支，即核心模块和第三方模块的加载方法不一样。由于我们假设了我们的 <code>index.js</code> 中为 <code>var http = require('http')</code>，http 是一个核心模块，所以我们先来分析核心模块加载的这个分支。</p><h4 id="核心模块加载原理">4.1 核心模块加载原理</h4><p>核心模块是通过 <code>NativeModule.require</code> 加载的，NativeModule的定义在 <code>bootstrap_node.js</code> 中，附上 github 链接： <a href="https://github.com/nodejs/node/blob/v6.x/lib/internal/bootstrap_node.js#L401" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/node/blob/v6.x/lib/internal/bootstrap_node.js#L401</a></p><p>从代码中可以看到，<code>NativeModule.require</code> 的流程如下：</p><ol style="list-style-type: decimal"><li>判断 cache 中是否已经加载过，如果有，直接返回 exports</li><li>新建 nativeModule 对象，然后缓存，并加载编译</li></ol><p>首先我们来看一下如何编译，从代码中看是调用了 <code>compile</code> 方法，而在 <code>NativeModule.prototype.compile</code> 方法中，首先是通过 <code>NativeModule.getSource</code> 获取了要加载模块的源码，那么这个源码是如何获取的呢？看一下 <code>getSource</code> 方法的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">NativeModule._source = process.binding(<span class="string">'natives'</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">NativeModule.getSource = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NativeModule._source[id];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接从 <code>NativeModule._source</code> 获取的，而这个又是在哪里赋值的呢？在上述代码中也截取了出来，是通过 <code>NativeModule._source = process.binding('natives')</code> 获取的。</p><p>这里就要插入介绍一下 JavaScript native 模块代码是如何存储的了。Node.js 源码编译的时候，会采用 v8 附带的 js2c.py 工具，将 lib 文件夹下面的 js 模块的代码都转换成 C 里面的数组，生成一个 node_natives.h 头文件，记录这个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> node &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> node_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> console_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> buffer_native[] = &#123;<span class="number">47</span>, <span class="number">47</span>, <span class="number">32</span>, <span class="number">67</span>, <span class="number">112</span> …&#125;</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct _native &#123;<span class="keyword">const</span> <span class="keyword">char</span> name;  <span class="keyword">const</span> <span class="keyword">char</span>* source;  <span class="keyword">size_t</span> source_len;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">native</span> <span class="title">natives</span>[] = &#123;</span></span><br><span class="line"></span><br><span class="line">  &#123; “node”, node_native, <span class="keyword">sizeof</span>(node_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“dgram”, dgram_native, <span class="keyword">sizeof</span>(dgram_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“console”, console_native, <span class="keyword">sizeof</span>(console_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  &#123;“buffer”, buffer_native, <span class="keyword">sizeof</span>(buffer_native)<span class="number">-1</span> &#125;,</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而上文中 <code>NativeModule._source = process.binding('natives');</code> 的作用，就是取出这个 natives 数组，赋值给<code>NativeModule._source</code>，所以在 <code>getSource</code> 方法中，直接可以使用模块名作为索引，从数组中取出模块的源代码。</p><p>在这里我们插入回顾一下上文，在介绍 Node.js 编译的时候，我们介绍了 <code>node.gyp</code>，其中有一个任务是 <code>node_js2c</code>，当时笔者提到从名称看这个任务是将 JavaScript 转换为 C 代码，而这里的 natives 数组中的 C 代码，正是这个构建任务的产物。而到了这里，我们终于知道了这个编译任务的作用了。</p><p>知道了源码的获取，继续往下看 <code>compile</code> 方法，看看源码是如何编译的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line">  NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  NativeModule.wrapper = [</span><br><span class="line">    <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">    <span class="string">'\n&#125;);'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">    source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = runInThisContext(source, &#123;</span><br><span class="line">        filename: <span class="keyword">this</span>.filename,</span><br><span class="line">        lineOffset: <span class="number">0</span>,</span><br><span class="line">        displayErrors: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">      fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>NativeModule.prototype.compile</code> 在获取到源码之后，它主要做了：使用 <code>wrap</code> 方法处理源代码，最后调用 runInThisContext 进行编译得到一个函数，最后执行该函数。其中 wrap 方法，是给源代码加上了一头一尾，其实相当于是将源码包在了一个函数中，这个函数的参数有 exports, require, module 等。这就是为什么我们写模块的时候，不需要定义 exports, require, module 就可以直接用的原因。</p><p>至此就基本讲清楚了 Node.js 核心模块的加载过程。说到这里大家可能有一个疑惑，上述分析过程，好像只涉及到了核心模块中的 JavaScript native模块，那么对于 C/C++ built-in 模块呢？</p><p>其实是这样的，对于 built-in 模块而言，它们不是通过 require 来引入的，而是通过 <code>precess.binding('模块名')</code> 引入的。一般我们很少在自己的代码中直接使用 <code>process.binding</code> 来引入built-in模块，而是通过 <code>require</code> 引用native模块，而 native 模块里面会引入 built-in 模块。比如我们常用的 buffer 模块，其内部实现中就引入了 C/C++ built-in 模块，这是为了避开 v8 的内存限制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// lib/buffer.js</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">// 通过 process.binding 引入名为 buffer 的 C/C++ built-in 模块</span><br><span class="line">const binding = process.binding(&apos;buffer&apos;);</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>这样，我们在 <code>require('buffer')</code> 的时候，其实是间接的使用了 C/C++ built-in 模块。</p><p>这里再次出现了 <code>process.binding</code>！事实上，process.binding 这个方法定义在 <code>node.cc</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Binding</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  node_module* mod = get_builtin_module(*module_v);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">env-&gt;SetMethod(process, <span class="string">"binding"</span>, Binding);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p><code>Binding</code> 这个函数中关键的一步是 <code>get_builtin_module</code>。这里需要再次插入介绍一下 C/C++ 内建模块的存储方式：</p><p>在 Node.js 中，内建模块是通过一个名为 <code>node_module_struct</code> 的结构体定义的。所以的内建模块会被放入一个叫做 <code>node_module_list</code> 的数组中。而 <code>process.binding</code> 的作用，正是使用 <code>get_builtin_module</code> 从这个数组中取出相应的内建模块代码。</p><p>综上，我们就完整介绍了核心模块的加载原理，主要是区分 JavaScript 类型的 native 模块和 C/C++ 类型的 built-in 模块。这里绘制一张图来描述一下核心模块加载过程：</p><div class="figure"><img src="/blog/nodejs-module-analyze/process2.png" alt="process2"><p class="caption">process2</p></div><p>而回忆我们在最开始介绍的，native 模块在源码中存放在 lib/ 目录下，而 built-in 模块在源码中存放在 src/ 目录下，下面这张图则从编译的角度梳理了 native 和 built-in 模块如何被编译进 Node.js 可执行文件：</p><div class="figure"><img src="/blog/nodejs-module-analyze/process3.png" alt="process3"><p class="caption">process3</p></div><h4 id="第三方模块加载原理">4.2 第三方模块加载原理</h4><p>下面让我们继续分析第二个分支，假设我们的 <code>index.js</code> 中 require 的不是 http，而是一个用户自定义模块，那么在 module.js 中, 我们会走到 tryModuleLoad 方法中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryModuleLoad</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> threw = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.load(filename);</span><br><span class="line">    threw = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (threw) &#123;</span><br><span class="line">      <span class="keyword">delete</span> Module._cache[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype.load = <span class="function"><span class="keyword">function</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  debug(<span class="string">'load %j for module %j'</span>, filename, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">  assert(!<span class="keyword">this</span>.loaded);</span><br><span class="line">  <span class="keyword">this</span>.filename = filename;</span><br><span class="line">  <span class="keyword">this</span>.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> extension = path.extname(filename) || <span class="string">'.js'</span>;</span><br><span class="line">  <span class="keyword">if</span> (!Module._extensions[extension]) extension = <span class="string">'.js'</span>;</span><br><span class="line">  Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>这里看到，<code>tryModuleLoad</code> 中实际调用了 <code>Module.prototype.load</code> 定义的方法，这个方法主要做的事情是，检测 filename 的扩展名，然后针对不同的扩展名，调用不同的 <code>Module._extensions</code> 方法来加载、编译模块。接着我们看看 <code>Module._extensions</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Native extension for .js</span></span><br><span class="line">Module._extensions[<span class="string">'.js'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">module</span>._compile(internalModule.stripBOM(content), filename);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Native extension for .json</span></span><br><span class="line">Module._extensions[<span class="string">'.json'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = <span class="built_in">JSON</span>.parse(internalModule.stripBOM(content));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    err.message = filename + <span class="string">': '</span> + err.message;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Native extension for .node</span></span><br><span class="line">Module._extensions[<span class="string">'.node'</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">module, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> process.dlopen(<span class="built_in">module</span>, path._makeLong(filename));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>可以看出，一共支持三种类型的模块加载：.js, .json, .node。其中 .json 类型的文件加载方法是最简单的，直接读取文件内容，然后 <code>JSON.parse</code> 之后返回对象即可。</p><p>下面来看对 .js 的处理，首先也是通过 <code>fs</code> 模块同步读取文件内容，然后调用了 <code>module._compile</code>，看看相关代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/module.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.wrap = NativeModule.wrap;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Module.prototype._compile = <span class="function"><span class="keyword">function</span>(<span class="params">content, filename</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// create wrapper function</span></span><br><span class="line">  <span class="keyword">var</span> wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> compiledWrapper = vm.runInThisContext(wrapper, &#123;</span><br><span class="line">    filename: filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> result = compiledWrapper.apply(<span class="keyword">this</span>.exports, args);</span><br><span class="line">  <span class="keyword">if</span> (depth === <span class="number">0</span>) stat.cache = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>首先调用 <code>Module.wrap</code> 对源代码进行包裹，之后调用 <code>vm.runInThisContext</code> 方法进行编译执行，最后返回 exports 的值。而从 <code>Module.wrap = NativeModule.wrap</code> 这一句可以看出，第三方模块的 wrap 方法，和核心模块的 wrap 方法是一样的。我们回忆一下刚才讲到的核心js模块加载关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/bootstrap_node.js</span></span><br><span class="line"> NativeModule.wrap = <span class="function"><span class="keyword">function</span>(<span class="params">script</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> NativeModule.wrapper[<span class="number">0</span>] + script + NativeModule.wrapper[<span class="number">1</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  NativeModule.wrapper = [</span><br><span class="line">    <span class="string">'(function (exports, require, module, __filename, __dirname) &#123; '</span>,</span><br><span class="line">    <span class="string">'\n&#125;);'</span></span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  NativeModule.prototype.compile = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> source = NativeModule.getSource(<span class="keyword">this</span>.id);</span><br><span class="line">    source = NativeModule.wrap(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loading = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = runInThisContext(source, &#123;</span><br><span class="line">        filename: <span class="keyword">this</span>.filename,</span><br><span class="line">        lineOffset: <span class="number">0</span>,</span><br><span class="line">        displayErrors: <span class="literal">true</span></span><br><span class="line">      &#125;);</span><br><span class="line">      fn(<span class="keyword">this</span>.exports, NativeModule.require, <span class="keyword">this</span>, <span class="keyword">this</span>.filename);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>两厢对比，发现二者对源代码的编译执行几乎是一模一样的。从整体流程上来讲，核心 JavaScript 模块与第三方 JavaScript 模块最大的不同就是，核心 JavaScript 模块源代码是通过 <code>process.binding('natives')</code> 从内存中获取的，而第三方 JavaScript 模块源代码是通过 <code>fs.readFileSync</code> 方法从文件中读取的。</p><p>最后，再来看一下加载第三方 C/C++模块（.node后缀）。直观上来看，很简单，就是调用了 <code>process.dlopen</code> 方法。这个方法的定义在 <code>node.cc</code> 中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node.cc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">env-&gt;SetMethod(process, <span class="string">"dlopen"</span>, DLOpen);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLOpen</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> is_dlopen_error = uv_dlopen(*filename, &amp;lib);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>实际上最终调用了 <code>DLOpen</code> 函数，该函数中最重要的是使用 <code>uv_dlopen</code> 方法打开动态链接库，然后对 C/C++ 模块进行加载。<code>uv_dlopen</code> 方法是定义在 <code>libuv</code> 库中的。<code>libuv</code> 库是一个跨平台的异步 IO 库。对于扩展模块的动态加载这部分功能，在 *nix 平台下，实际上调用的是 dlfcn.h 中定义的 dlopen() 方法，而在 Windows 下，则为 LoadLibraryExW() 方法，在两个平台下，他们加载的分别是 .so 和 .dll 文件，而 Node.js 中，这些文件统一被命名了 .node 后缀，屏蔽了平台的差异。</p><p>关于 <code>libuv</code> 库，是 Node.js 异步 IO 的核心驱动力，这一块本身就值得专门作为一个专题来研究，这里就不展开讲了。</p><p>到此为止，我们理清楚了三种第三方模块的加载、编译过程。</p><h2 id="cc-扩展模块的开发以及应用场景">5. C/C++ 扩展模块的开发以及应用场景</h2><p>上文分析了 Node.js 当中各类模块的加载流程。大家对于 JavaScript 模块的开发应该是驾轻就熟了，但是对于 C/C++ 扩展模块开发可能还有些陌生。这一节就简单介绍一下扩展模块的开发，并谈谈其应用场景。</p><p>关于 Node.js 扩展模块的开发，在 Node.js 官网文档中专门有一节予以介绍，大家可以移步官网文档查看：<a href="https://nodejs.org/docs/latest-v6.x/api/addons.html" class="uri" target="_blank" rel="noopener">https://nodejs.org/docs/latest-v6.x/api/addons.html</a> 。这里仅仅以其中的 hello world 例子来介绍一下编写扩展模块的一些比较重要的概念：</p><p>假设我们希望通过扩展模块来实现一个等同于如下 JavaScript 函数的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports.hello = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure><p>首先创建一个 hello.cc 文件，编写如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> demo &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> v8::FunctionCallbackInfo;</span><br><span class="line"><span class="keyword">using</span> v8::Isolate;</span><br><span class="line"><span class="keyword">using</span> v8::Local;</span><br><span class="line"><span class="keyword">using</span> v8::Object;</span><br><span class="line"><span class="keyword">using</span> v8::String;</span><br><span class="line"><span class="keyword">using</span> v8::Value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = args.GetIsolate();</span><br><span class="line">  args.GetReturnValue().Set(String::NewFromUtf8(isolate, <span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local&lt;Object&gt; exports)</span> </span>&#123;</span><br><span class="line">  NODE_SET_METHOD(exports, <span class="string">"hello"</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(NODE_GYP_MODULE_NAME, init)</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace demo</span></span><br></pre></td></tr></table></figure><p>文件虽短，但是已经出现了一些我们比较陌生的代码，这里一一介绍一下，对于了解扩展模块基础知识还是很有帮助的。</p><p>首先在开头引入了 <code>node.h</code>，这个是编写 Node.js 扩展时必用的头文件，里面几乎包含了我们所需要的各种库、数据类型。</p><p>其次，看到了很多 <code>using v8:xxx</code> 这样的代码。我们知道，Node.js 是基于 v8 引擎的，而 v8 引擎，就是用 C++ 来写的。我们要开发 C++ 扩展模块，便需要使用 v8 中提供的很多数据类型，而这一系列代码，正是声明了需要使用 v8 命名空间下的这些数据类型。</p><p>然后来看 <code>Method</code> 方法，它的参数类型 <code>FunctionCallbackInfo&lt;Value&gt;&amp; args</code>，这个 args 就是从 JavaScript 中传入的参数，同时，如果想在 <code>Method</code> 中为 JavaScript 返回变量，则需要调用 <code>args.GetReturnValue().Set</code> 方法。</p><p>接下来需要定义扩展模块的初始化方法，这里是 <code>Init</code> 函数，只有一句简单的 <code>NODE_SET_METHOD(exports, &quot;hello&quot;, Method);</code>，代表给 exports 赋予一个名为 <code>hello</code> 的方法，这个方法的具体定义就是 <code>Method</code> 函数。</p><p>最后是一个宏定义：<code>NODE_MODULE(NODE_GYP_MODULE_NAME, init)</code>，第一个参数是希望的扩展模块名称，第二个参数就是该模块的初始化方法。</p><p>为了编译这个模块，我们需要通过npm安装 <code>node-gyp</code> 编译工具。该工具将 Google 的 <code>gyp</code> 工具封装，用来构建 Node.js 扩展。安装这个工具后，我们在源码文件夹下面增加一个名为 <code>bingding.gyp</code> 的配置文件，对于我们这个例子，文件只要这样写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"targets"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"target_name"</span>: <span class="string">"addon"</span>,</span><br><span class="line">      <span class="attr">"sources"</span>: [ <span class="string">"hello.cc"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，运行 <code>node-gyp build</code> 即可编译扩展模块。在这个过程中，<code>node-gyp</code> 还会去指定目录（一般是 ~/.node-gyp）下面搜我们当前 Node.js 版本的一些头文件和库文件，如果不存在，它还会帮我们去 Node.js 官网下载。这样，在编写扩展的时候，通过 <code>#include &lt;&gt;</code>，我们就可以直接使用所有 Node.js 的头文件了。</p><p>如果编译成功，会在当前文件夹的 <code>build/Release/</code> 路径下看到一个 <code>addon.node</code>，这个就是我们编译好的可 require 的扩展模块。</p><p>从上面的例子中，我们能大体看出扩展模块的运作模式，它可以接收来自 JavaScript 的参数，然后中间可以调用 C/C++ 语言的能力去做各种运算、处理，然后最后可以将结果再返回给 JavaScript。</p><p>值得注意的是，不同 Node.js 版本，依赖的 v8 版本不同，导致很多 API 会有差别，因此使用原生 C/C++ 开发扩展的过程中，也需要针对不同版本的 Node.js 做兼容处理。比如说，声明一个函数，在 v6.x 和 v0.12 以下的版本中，分别需要这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Handle&lt;Value&gt; Example(<span class="keyword">const</span> Arguments&amp; args); <span class="comment">// 0.10.x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span><span class="params">(FunctionCallbackInfo&lt;Value&gt;&amp; args)</span></span>; <span class="comment">// 6.x</span></span><br></pre></td></tr></table></figure><p>可以看到，函数的声明，包括函数中参数的写法，都不尽相同。这让人不由得想起了在 Node.js 开发中，为了写 ES6，也是需要使用 Babel 来帮忙进行兼容性转换。那么在 Node.js 扩展开发领域，有没有类似 Babel 这样帮助我们处理兼容性问题的库呢？答案是肯定的，它的名字叫做 NAN (Native Abstraction for Node.js)。它本质上是一堆宏，能够帮助我们检测 Node.js 的不同版本，并调用不同的 API。例如，在 NAN 的帮助下，声明一个函数，我们不需要再考虑 Node.js 版本，而只需要写一段这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;nan.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">NAN_METHOD(Example) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NAN 的宏会在编译的时候自动判断，根据 Node.js 版本的不同展开不同的结果，从而解决了兼容性问题。对 NAN 更详细的介绍，感兴趣的同学可以移步该项目的 github 主页：<a href="https://github.com/nodejs/nan" class="uri" target="_blank" rel="noopener">https://github.com/nodejs/nan</a>。</p><p>介绍了这么多扩展模块的开发，可能有同学会问了，像这些扩展模块实现的功能，看起来似乎用js也可以很快的实现，何必大费周折去开发扩展呢？这就引出了一个问题：C/C++ 扩展的适用场景。</p><p>笔者在这里大概归纳了几类 C/C++ 适用的情景：</p><ol style="list-style-type: decimal"><li>计算密集型应用。我们知道，Node.js 的编程模型是单线程 + 异步 IO，其中单线程导致了它在计算密集型应用上是一个软肋，大量的计算会阻塞 JavaScript 主线程，导致无法响应其他请求。对于这种场景，就可以使用 C/C++ 扩展模块，来加快计算速度，毕竟，虽然 v8 引擎的执行速度很快，但终究还是比不过 C/C++。另外，使用 C/C++，还可以允许我们开多线程，避免阻塞 JavaScript 主线程，社区里目前已经有一些基于扩展模块的 Node.js 多线程方案，其中最受欢迎的可能是一个叫做 <code>thread-a-gogo</code> 的项目，具体可以移步 github：<a href="https://github.com/xk/node-threads-a-gogo" class="uri" target="_blank" rel="noopener">https://github.com/xk/node-threads-a-gogo</a>。</li><li>内存消耗较大的应用。Node.js 是基于 v8 的，而 v8 一开始是为浏览器设计的，所以其在内存方面是有比较严格的限制的，所以对于一些需要较大内存的应用，直接基于 v8 可能会有些力不从心，这个时候就需要使用扩展模块，来绕开 v8 的内存限制，最典型的就是我们常用的 buffer.js 模块，其底层也是调用了 C++，在 C++ 的层面上去申请内存，避免 v8 内存瓶颈。</li></ol><p>关于第一点，笔者这里也分别用原生 Node.js 以及 Node.js 扩展实现了一个测试例子来对比计算性能。测试用例是经典的计算斐波那契数列，首先使用 Node.js 原生语言实现一个计算斐波那契数列的函数，取名为 <code>fibJs</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibJs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibJs(n - <span class="number">1</span>) + fibJs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 C++ 编写一个实现同样功能的扩展函数，取名 <code>fibC</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fibC.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;node.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> v8;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n ==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(<span class="keyword">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">    Isolate* isolate = args.GetIsolate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = args[<span class="number">0</span>]-&gt;NumberValue();</span><br><span class="line">    <span class="keyword">int</span> result = fib(n);</span><br><span class="line">    args.GetReturnValue().Set(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Local &lt; Object &gt; exports, Local &lt; Object &gt; <span class="keyword">module</span>)</span> </span>&#123;</span><br><span class="line">    NODE_SET_METHOD(<span class="keyword">module</span>, <span class="string">"exports"</span>, Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NODE_MODULE(fibC, init)</span><br></pre></td></tr></table></figure><p>在测试中，分别使用这两个函数计算从 1~40 的斐波那契数列:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testSpeed</span>(<span class="params">fn, testName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        fn(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> spend = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">    <span class="built_in">console</span>.log(testName, <span class="string">'spend time: '</span>, spend);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展模块测试</span></span><br><span class="line"><span class="keyword">var</span> fibC = <span class="built_in">require</span>(<span class="string">'./build/Release/fibC'</span>); <span class="comment">// 这里是扩展模块编译产物的存放路径</span></span><br><span class="line">testSpeed(fibC, <span class="string">'c++ test:'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 JavaScript 函数进行测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibJs</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fibJs(n - <span class="number">1</span>) + fibJs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">testSpeed(fibJs, <span class="string">'js test:'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++ test: spend time:  1221</span></span><br><span class="line"><span class="comment">// js test: spend time:  2611</span></span><br></pre></td></tr></table></figure><p>多次测试，扩展模块平均花费时长大约 1.2s，而 JavaScript 模块花费时长大约 2.6s，可见在此场景下，C/C++ 扩展性能还是要快上不少的。</p><p>当然，这几点只是基于笔者的认识。在实际开发过程中，大家在遇到问题的时候，也可以尝试着考虑如果使用 C/C++ 扩展模块，问题是不是能够得到更好的解决。</p><h3 id="结语">结语</h3><p>文章读到这里，我们再回去看一下一开始提出的那些问题，是否在文章分析的过程中都得到了解答？再来回顾一下本文的逻辑脉络：</p><ul><li>首先以一个<code>node index.js</code> 的运行原理开始，指出使用<code>node</code> 运行一个文件，等同于立即执行一次<code>require</code> 。</li><li>然后引出了node中的require方法，在这里，区分了核心模块、内建模块和非核心模块几种情况，分别详述了加载、编译的流程原理。在这个过程中，还分别涉及到了模块路径解析、模块缓存等等知识点的描述。</li><li>最后介绍了大家不太熟悉的c/c++扩展模块的开发，并结合一个性能对比的例子来说明其适用场景。</li></ul><p>事实上，通过学习 Node.js 模块加载流程，有助于我们更深刻的了解 Node.js 底层的运行原理，而掌握了其中的扩展模块开发，并学会在适当的场景下使用，则能够使得我们开发出的 Node.js 应用性能更高。</p><p>学习 Node.js 原理是一条漫长的路径。建议了解了底层模块机制的读者，可以去更深入的学习 v8, libuv 等等知识，对于精通 Node.js，必将大有裨益。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node.js 的出现，让 JavaScript 脱离了浏览器的束缚，进入了广阔的服务端开发领域。而 Node.js 对 CommonJS 模块化规范的引入，则更是让 JavaScript成为了一门真正能够适应大型工程的语言。&lt;/p&gt;
&lt;p&gt;在 Node.js 中使用模块非常简单，我们日常开发中几乎都有过这样的经历：写一段 JavaScript 代码，require 一些想要的包，然后将代码产物 exports 导出。但是，对于 Node.js 模块化背后的加载与运行原理，我们是否清楚呢。首先抛出以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 中的模块支持哪些文件类型？&lt;/li&gt;
&lt;li&gt;核心模块和第三方模块的加载运行流程有什么不同？&lt;/li&gt;
&lt;li&gt;除了 JavaScript 模块以外，怎样去写一个 C/C++ 扩展模块？&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章，就会结合 Node.js 源码，探究一下以上这些问题背后的答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NodeJS" scheme="http://efe.baidu.com/tags/NodeJS/"/>
    
      <category term="模块化" scheme="http://efe.baidu.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>San 3.3.0 发布</title>
    <link href="http://efe.baidu.com/blog/san-3-3-0/"/>
    <id>http://efe.baidu.com/blog/san-3-3-0/</id>
    <published>2017-11-29T16:00:00.000Z</published>
    <updated>2017-12-01T02:39:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://ecomfe.github.io/san/" target="_blank" rel="noopener"><img src="/blog/san-3-3-0/cover.png" alt="San"></a></p><p>先不要脸的求关注</p><iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=san&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe><p>主要升级点如下：</p><ul><li>【新特性】- 支持 template tag 声明自身不渲染元素只渲染内容</li><li>【新特性】- 事件声明参数为空时，默认 $event</li><li>【新特性】- 支持通过 native modifier，直接为组件的根元素绑定事件</li><li>【新特性】- 支持通过 capture modifier，在捕获阶段绑定事件</li><li>【新特性】- 支持 scoped slot</li><li>【新特性】- 支持 transition 机制</li><li>【新特性】- slot 支持 if 和 for 指令</li><li>【新特性】- 组件实例上添加 slot 方法，可以获取组件内部 slot 插入的内容</li><li>【新特性】- 组件实例上添加 nextTick 方法，避免组件实现需要 nextTick 必须显式依赖 san</li><li>【新特性】- main 上暴露 NodeType 枚举对象</li><li>【变更】- parseTemplate 的 ANode 去除 parent 的引用。消除循环引用后可以 JSON.stringify</li><li>【变更】- ANode 上子节点命名由 childs 变更为 children</li><li>【变更】- 组件 LifeCycle 对象静态化，main 上不再暴露 LifeCycle 类</li><li>【优化】- data 的 push 和 unshift 操作返回新数组长度，和 JS Array 保持一致</li><li>【优化】- 增加事件绑定到不存在方法时的错误提示</li><li>【优化】- 当数组上有非数字索引的成员并发生变更时，添加判断使视图更新时不报错，增加健壮性</li><li>【bug修复】- ssr 在多重循环下可能渲染不完整</li><li>【bug修复】- input[type=file] 的 multiple 属性由于低级的拼写问题导致不支持</li><li>【bug修复】- input value 使用双向绑定时，如果绑定值为 undefined，表单内容未自动转为空串</li></ul><p>原定 3.3.0 的完成时间是11月底，我们赶在11月最后一天晚上发布，这充分说明我们有 <del>精雕细琢的工匠精神</del> 拖延症。</p><p>到此应该可以结束了。不过好像少了点什么，所以随便说点东西吧。</p><a id="more"></a><h3 id="主题">主题</h3><p>这半年来，应用 <a href="http://ecomfe.github.io/san/" target="_blank" rel="noopener">San</a> 的项目越来越多，我们也收到越来越多的 issues 和线下反馈，这些是让我们不断进步的源动力。从 <a href="https://github.com/ecomfe/san/blob/master/CHANGELOG.md" target="_blank" rel="noopener">ChangeLog</a> 可以看到，<a href="http://ecomfe.github.io/san/" target="_blank" rel="noopener">San</a> 版本的跳升还是很快的。随着收到需求反馈的不断增加，我们把一些比较大的、需要机制和整体调整的新特性攒了一波，花了近1个月的时间设计开发，做了一个大升级。这次 3.3.0 升级的主题是：</p><p><strong>特征完备</strong></p><h3 id="感谢">感谢</h3><p>按照舞台上的惯例，应该开始感谢了。</p><h4 id="感谢愿意陪我们一起玩的同学">感谢愿意陪我们一起玩的同学</h4><p>感谢给 San 做库、组件、工具等周边的同学，你们让 San 变得越来越好用。没有你们，使用 San 开发项目会很困难的从 0 开始。</p><p>感谢给我们提需求、提bug、吐槽、和我们讨论的同学，你们的真知灼见比人民币更重要。</p><p>感谢在项目里冒着排期失控、质量不可控、担惊受怕、失业等风险，选择了非主流的 San 的同学，你们的支持是我们坚持的理由。</p><h4 id="感谢-vue">感谢 Vue</h4><p>我们经常收到这样的需求：</p><blockquote><p>Vue 里有 xxx 功能</p></blockquote><blockquote><p>你看 Vue 是这样做的</p></blockquote><blockquote><p>我们用 Vue 的时候会写成这样 blabla...</p></blockquote><p>所以很明显可以看到，但 3.3.0 中很多的新特性其实非常 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>-like:</p><ul><li>支持 template tag 声明自身不渲染元素只渲染内容</li><li>支持通过 native modifier，直接为组件的根元素绑定事件</li><li>支持 scoped slot</li><li>支持 transition 机制</li><li>组件实例上添加 nextTick 方法，避免组件实现需要 nextTick 必须显式依赖 san</li></ul><p>我理解，<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a> 最宝贵的财富在于无数的用户在各式各样的应用场景下产生的实践和需求，<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a> 的每一个 feature 都是从实践中来的。相比之下，实现原理和 API 形态并不太重要。</p><p>我们经常在收到一个 feature request 和应用场景描述的时候，才恍然大悟原来是这么玩的、这么玩比较方便比较巧妙，才发现我们原来认为没用的 feature 其实有很重要的应用场景。我们必须承认在这一块我们的积累差了不止一条街，从 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>、从 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a> 的用户给我们的建议中，我们学到很多。</p><p>感谢 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a></p><h3 id="最后">最后</h3><p>最后是一个坏消息：不好意思，体积控制不住了，GZipped <strong>12k</strong> 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://ecomfe.github.io/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;/blog/san-3-3-0/cover.png&quot; alt=&quot;San&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先不要脸的求关注&lt;/p&gt;
&lt;iframe src=&quot;https://ghbtns.com/github-btn.html?user=ecomfe&amp;amp;repo=san&amp;amp;type=star&amp;amp;count=true&quot; frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;170px&quot; height=&quot;20px&quot;&gt;
&lt;/iframe&gt;
&lt;p&gt;主要升级点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【新特性】- 支持 template tag 声明自身不渲染元素只渲染内容&lt;/li&gt;
&lt;li&gt;【新特性】- 事件声明参数为空时，默认 $event&lt;/li&gt;
&lt;li&gt;【新特性】- 支持通过 native modifier，直接为组件的根元素绑定事件&lt;/li&gt;
&lt;li&gt;【新特性】- 支持通过 capture modifier，在捕获阶段绑定事件&lt;/li&gt;
&lt;li&gt;【新特性】- 支持 scoped slot&lt;/li&gt;
&lt;li&gt;【新特性】- 支持 transition 机制&lt;/li&gt;
&lt;li&gt;【新特性】- slot 支持 if 和 for 指令&lt;/li&gt;
&lt;li&gt;【新特性】- 组件实例上添加 slot 方法，可以获取组件内部 slot 插入的内容&lt;/li&gt;
&lt;li&gt;【新特性】- 组件实例上添加 nextTick 方法，避免组件实现需要 nextTick 必须显式依赖 san&lt;/li&gt;
&lt;li&gt;【新特性】- main 上暴露 NodeType 枚举对象&lt;/li&gt;
&lt;li&gt;【变更】- parseTemplate 的 ANode 去除 parent 的引用。消除循环引用后可以 JSON.stringify&lt;/li&gt;
&lt;li&gt;【变更】- ANode 上子节点命名由 childs 变更为 children&lt;/li&gt;
&lt;li&gt;【变更】- 组件 LifeCycle 对象静态化，main 上不再暴露 LifeCycle 类&lt;/li&gt;
&lt;li&gt;【优化】- data 的 push 和 unshift 操作返回新数组长度，和 JS Array 保持一致&lt;/li&gt;
&lt;li&gt;【优化】- 增加事件绑定到不存在方法时的错误提示&lt;/li&gt;
&lt;li&gt;【优化】- 当数组上有非数字索引的成员并发生变更时，添加判断使视图更新时不报错，增加健壮性&lt;/li&gt;
&lt;li&gt;【bug修复】- ssr 在多重循环下可能渲染不完整&lt;/li&gt;
&lt;li&gt;【bug修复】- input[type=file] 的 multiple 属性由于低级的拼写问题导致不支持&lt;/li&gt;
&lt;li&gt;【bug修复】- input value 使用双向绑定时，如果绑定值为 undefined，表单内容未自动转为空串&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原定 3.3.0 的完成时间是11月底，我们赶在11月最后一天晚上发布，这充分说明我们有 &lt;del&gt;精雕细琢的工匠精神&lt;/del&gt; 拖延症。&lt;/p&gt;
&lt;p&gt;到此应该可以结束了。不过好像少了点什么，所以随便说点东西吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MVVM" scheme="http://efe.baidu.com/tags/MVVM/"/>
    
      <category term="San" scheme="http://efe.baidu.com/tags/San/"/>
    
  </entry>
  
  <entry>
    <title>ECharts v3.8 发布：树图、SVG 渲染（beta）、ES Module</title>
    <link href="http://efe.baidu.com/blog/echarts-3-8-0/"/>
    <id>http://efe.baidu.com/blog/echarts-3-8-0/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2019-01-08T08:12:26.887Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECharts 新发布的 <a href="https://github.com/ecomfe/echarts/releases/tag/3.8.0" target="_blank" rel="noopener">3.8 版本</a> 中，新加入了 <a href="http://echarts.baidu.com/option.html#series-tree" target="_blank" rel="noopener">树图</a>，支持 <a href="http://echarts.baidu.com/demo.html#tree-basic" target="_blank" rel="noopener">横向布局</a>、<a href="http://echarts.baidu.com/demo.html#tree-vertical" target="_blank" rel="noopener">纵向布局</a>、<a href="http://echarts.baidu.com/demo.html#tree-radial" target="_blank" rel="noopener">径向布局</a>；新加入了 <a href="http://echarts.baidu.com/tutorial.html#%E4%BD%BF%E7%94%A8%20Canvas%20%E6%88%96%E8%80%85%20SVG%20%E6%B8%B2%E6%9F%93" target="_blank" rel="noopener">SVG 渲染支持（beta 版）</a> 的支持，从而可以根据自己的需要，选择 SVG 或者 Canvas 作为渲染引擎；代码的模块系统改用 ES Module，从而能够受益于 tree shaking 减小 bundle 的体积；同时开放了构建脚本协助用户进行 <a href="http://echarts.baidu.com/tutorial.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%20ECharts" target="_blank" rel="noopener">自定义模块、语言地构建</a>。</p><a id="more"></a><hr><h2 id="树图">树图</h2><p><a href="http://echarts.baidu.com/option.html#series-tree" target="_blank" rel="noopener">树图</a> 主要用来可视化树形数据结构，是一种特殊的层次类型，具有唯一的根节点，左子树，和右子树。点击树的节点，可以展开收缩子树。</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/tree-basic.png" data-src="http://echarts.baidu.com/gallery/view.html?c=tree-basic&amp;edit=1&amp;reset=1" style="width: 90%; height: 400px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/tree-radial.png" data-src="http://echarts.baidu.com/gallery/view.html?c=tree-radial&amp;edit=1&amp;reset=1" style="width: 90%; height: 400px"></div><hr><h2 id="svg-支持">SVG 支持</h2><p>浏览器端图表库大多会选择 SVG 或者 Canvas 进行渲染。对于绘制图表来说，这两种技术往往是可替换的，效果相近。但是在一些场景中，他们的表现和能力又有一定差异。于是，对它们的选择取舍，就成为了一个一直存在的不易有标准答案的话题。</p><p>ECharts 从初始一直使用 Canvas 绘制图表（除了对 IE8- 使用 VML）。而 <a href="https://github.com/ecomfe/echarts/releases" target="_blank" rel="noopener">ECharts v3.8</a> 发布了 SVG 渲染器（beta 版），从而提供了一种新的选择。只须在初始化一个图表实例时，设置 <a href="http://echarts.baidu.com/api.html#echarts.init" target="_blank" rel="noopener">renderer 参数</a> 为 <code>'canvas'</code> 或 <code>'svg'</code> 即可指定渲染器，比较方便。</p><blockquote><p>SVG 和 Canvas 这两种使用方式差异很大的技术，能够做到同时被透明支持，主要归功于 ECharts 底层库 <a href="https://github.com/ecomfe/zrender" target="_blank" rel="noopener">ZRender</a> 的抽象和实现，形成可互换的 SVG 渲染器和 Canvas 渲染器。</p></blockquote><p><br></p><p>一般来说，Canvas 更适合绘制图形元素数量非常大（这一般是由数据量大导致）的图表（如热力图、地理坐标系或平行坐标系上的大规模线图或散点图等），也利于实现某些视觉 <a href="http://echarts.baidu.com/demo.html#lines-bmap-effect" target="_blank" rel="noopener">特效</a>。但是，在不少场景中，SVG 具有重要的优势：它的内存占用更低（这对移动端尤其重要）、渲染性能略高、并且用户使用浏览器内置的缩放功能时不会模糊。例如，我们在一些硬件环境中分别使用 Canvas 渲染器和 SVG 渲染器绘制中等数据量的折、柱、饼，统计初始动画阶段的帧率，得到了一个性能对比图：</p><p><img src="/blog/echarts-3-8-0/2017-11-07-canvas-vs-svg.png" width="90%"></p><p>上图显示出，在这些场景中，SVG 渲染器相比 Canvas 渲染器在移动端的总体表现更好。当然，这个实验并非是全面的评测，在另一些数据量较大或者有图表交互动画的场景中，目前的 SVG 渲染器的性能还比不过 Canvas 渲染器。但是同时有这两个选项，为开发者们根据自己的情况优化性能提供了更广阔的空间。</p><p>选择哪种渲染器，我们可以根据软硬件环境、数据量、功能需求综合考虑。 + 在软硬件环境较好，数据量不大的场景下（例如 PC 端做商务报表），两种渲染器都可以适用，并不需要太多纠结。 + 在环境较差，出现性能问题需要优化的场景下，可以通过试验来确定使用哪种渲染器。比如有这些经验： + 在须要创建很多 ECharts 实例且浏览器易崩溃的情况下（可能是因为 Canvas 数量多导致内存占用超出手机承受能力），可以使用 SVG 渲染器来进行改善。大略得说，如果图表运行在低端安卓机，或者我们在使用一些特定图表如 <a href="https://ecomfe.github.io/echarts-liquidfill/example/" target="_blank" rel="noopener">水球图</a> 等，SVG 渲染器可能效果更好。 + 数据量很大、较多交互时，可以选用 Canvas 渲染器。</p><p>我们强烈欢迎开发者们 <a href="https://github.com/ecomfe/echarts/issues/new" target="_blank" rel="noopener">反馈</a> 给我们使用的体验和场景，帮助我们更好的做优化。</p><p>SVG 渲染的使用 <a href="http://echarts.baidu.com/tutorial.html#%E4%BD%BF%E7%94%A8%20Canvas%20%E6%88%96%E8%80%85%20SVG%20%E6%B8%B2%E6%9F%93" target="_blank" rel="noopener">参见教程</a>。</p><hr><h2 id="es-module">ES Module</h2><p>从 v3.8 开始，ECharts 源代码的模块系统改用 ES Module，从而可以受益于 tree shaking，减小构建所得 bundle 的体积。并且 ECharts 提供了构建脚本（<code>echarts/build/build.js</code>），方便开发者使用命令行定制 bundle，可以选择模块、选择默认的语言。参见教程 <a href="http://echarts.baidu.com/tutorial.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%20ECharts" target="_blank" rel="noopener">自定义构建</a>。</p><p><br></p><p>更多的升级信息，参见 <a href="http://echarts.baidu.com/changelog.html" target="_blank" rel="noopener">changelog</a>。</p><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script>(function () {    if (typeof jQuery === 'undefined') {        return;    }    var $ = jQuery;    var env = window['MD_ENV'];    var $ = jQuery;    var useThumb = env && (env.os.phone || env.os.tablet);    var blockList = $('.ec-lazy');    var $win = $(window);    blockList.each(function (index, block) {        block = $(block);        var src = block.attr('data-src');        block.attr('data-src', src);    });    // Lazy load.    $win.on('scroll', showBlock);    $(showBlock);    function initThumb(block, $block, blockThumb, blockSrc) {        $block.css('lineHeight', $block.height() + 'px');        block.innerHTML = [            '<img style="width:100%;height:auto;margin:0;padding:0;vertical-align:middle;" src="', blockThumb, '"/>',            // for vertial middle            '<div style="vertical-align: middle; height: 100%; width: 0"></div>',            '<div style="cursor:pointer;thumb-btn;position:absolute;bottom:10px;width:100%;height:22px;line-height:22px;text-align:center;">',                '<em style="font-style:normal;border-radius:3px;padding:3px 5px;margin:3px 5px;color:white;background:#337ab7;font-size:12px;line-height:1.5;">点击图片加载真实图表</em>',            '</div>',            '<div class="ec-lazy-block-mask" style="cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;margin:0;"></div>'        ].join('');        $block.find('.ec-lazy-block-mask').on('click', function () {            initIFrame(block, $block, blockThumb, blockSrc);        });    }    function initIFrame(block, $block, blockThumb, blockSrc) {        block.innerHTML = [            '<iframe style="overflow:hidden;width:100%;height:100%;margin:0;padding:0;" src="' , blockSrc, '">',            'frameborder="no" border="0" marginwidth="0" marginheight="0"',            'scrolling="no" hspace="0" vspace="0"></iframe>'        ].join('');    }    function showBlock() {        blockList.each(function (idx, block) {            var $block = $(block);            var blockSrc = $block.attr('data-src');            var blockThumb = $block.attr('data-thumb');            if (!blockSrc) {                return;            }            $block.css({                position: 'relative',                overflow: 'hidden',                textAlign: 'center',                padding: 0            });            var winScrollTop = $win.scrollTop();            var blockTop = block.offsetTop;            var winHeight = $win.height();            var winBottom = winScrollTop + winHeight;            var blockBottom = blockTop + $block.height();            if (winBottom >= blockTop && winBottom <= (blockBottom + winHeight)) {                $block.attr('data-src', '');                (useThumb && blockThumb)                    ? initThumb(block, $block, blockThumb, blockSrc)                    : initIFrame(block, $block, blockThumb, blockSrc);            }        });    }})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECharts 新发布的 &lt;a href=&quot;https://github.com/ecomfe/echarts/releases/tag/3.8.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.8 版本&lt;/a&gt; 中，新加入了 &lt;a href=&quot;http://echarts.baidu.com/option.html#series-tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树图&lt;/a&gt;，支持 &lt;a href=&quot;http://echarts.baidu.com/demo.html#tree-basic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;横向布局&lt;/a&gt;、&lt;a href=&quot;http://echarts.baidu.com/demo.html#tree-vertical&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;纵向布局&lt;/a&gt;、&lt;a href=&quot;http://echarts.baidu.com/demo.html#tree-radial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;径向布局&lt;/a&gt;；新加入了 &lt;a href=&quot;http://echarts.baidu.com/tutorial.html#%E4%BD%BF%E7%94%A8%20Canvas%20%E6%88%96%E8%80%85%20SVG%20%E6%B8%B2%E6%9F%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SVG 渲染支持（beta 版）&lt;/a&gt; 的支持，从而可以根据自己的需要，选择 SVG 或者 Canvas 作为渲染引擎；代码的模块系统改用 ES Module，从而能够受益于 tree shaking 减小 bundle 的体积；同时开放了构建脚本协助用户进行 &lt;a href=&quot;http://echarts.baidu.com/tutorial.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%84%E5%BB%BA%20ECharts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义模块、语言地构建&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>使用 ECharts 与 Ionic 创建原生应用</title>
    <link href="http://efe.baidu.com/blog/echarts-with-ionic/"/>
    <id>http://efe.baidu.com/blog/echarts-with-ionic/</id>
    <published>2017-08-28T16:00:00.000Z</published>
    <updated>2017-11-30T10:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在这个教程中，我们将使用 <a href="http://ionicframework.com/" target="_blank" rel="noopener">Ionic</a> 创建原生应用，并用 <a href="http://echarts.baidu.com" target="_blank" rel="noopener">ECharts</a> 创建饼图和水球图。Ionic 项目开发语言是 TypeScript，而 ECharts 的官方版本是基于 JavaScript 的，本教程将带你轻松实现在 TypeScript 中创建 ECharts 图表。</p><p>最终，我们将实现这样的效果：</p><p><img class="single-img" src="/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-bottle.gif" alt="运行结果"></p><a id="more"></a><p>这篇教程将会教你：</p><ul><li>安装 Ionic</li><li>在 TypeScript 中使用 ECharts</li><li>在 Ionic 项目中创建 ECharts 图表</li><li>在 Ionic 项目中创建 ECharts 水球图</li></ul><p>它不会教你：</p><ul><li><a href="http://echarts.baidu.com" target="_blank" rel="noopener">ECharts</a> 是什么</li><li><a href="http://ionicframework.com/" target="_blank" rel="noopener">Ionic</a> 是什么</li><li><a href="https://angular.io/" target="_blank" rel="noopener">Angular</a> 是什么</li><li><a href="https://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 是什么</li></ul><h2 id="新建-ionic-项目">新建 Ionic 项目</h2><p>Ionic 官网有详细的<a href="http://ionicframework.com/docs/intro/installation/" target="_blank" rel="noopener">安装教程</a>，这里我们简单介绍一下我们的操作步骤。</p><p>首先，安装全局的 Ionic 和 Cordova npm 包，前者是用来在命令行操作 Ionic 的，后者是提供从网页到原生应用的底层支持的库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g ionic cordova</span><br></pre></td></tr></table></figure><p>然后就可以创建项目了，我们的当前操作目录在 <code>~/Workspace</code>，想创建一个名为 <code>pretty-charts</code> 的项目，执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ionic start pretty-charts</span><br></pre></td></tr></table></figure><p>这样就会自动下载项目的模板，并且一键安装各种 npm 包之类的。是不是超简单的！</p><p>现在，我们可以 <code>cd</code> 到 <code>pretty-charts</code> 目录下运行项目。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> pretty-charts</span><br><span class="line">$ ionic serve</span><br></pre></td></tr></table></figure><p><code>ionic serve</code> 会编译你的代码（什么？你还没写？没关系，模板都帮你写好了），并且起一个本地的服务器，自动打开一个浏览器运行代码。看到的效果类似这样：</p><p><img class="single-img" src="/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-init.png" alt="初始化项目运行结果"></p><blockquote><p>目前 Ionic 3 的运行需要 Node 6.0+，可以通过 nvm 安装并切换 Node 版本。</p><p>首先运行 <code>node -v</code> 查看 Node 版本，如果不是 6.0+，可以运行 <code>npm i -g nvm; nvm install 6; nvm use 6</code>。</p></blockquote><h2 id="在-typescript-中引入-echarts">在 TypeScript 中引入 ECharts</h2><p>之前我有写过一篇教程介绍如何用 typings 1.x 在 TypeScript 中引入 ECharts，想了解原理的可以参考<a href="http://zhangwenli.com/blog/2016/08/24/using-echarts-with-typescript/" target="_blank" rel="noopener">这篇教程</a>。下面我们使用的方法是基于 typings 2.x 的。</p><p>首先我们安装 typings 库，以及 ECharts：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install typings echarts --global</span><br></pre></td></tr></table></figure><p>然后，安装 ECharts 的 TypeScript 定义文件，这个文件来自社区贡献。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/echarts --save</span><br></pre></td></tr></table></figure><p>现在，我们可以在 TypeScript 文件中访问 ECharts 库了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br></pre></td></tr></table></figure><p>typings 实际上是为 JavaScript 的库提供了一个接口声明的作用，有点类似 C++ 的头文件的意思，但不对其作检查。具体来说，我们刚才下载的文件来自 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/echarts/index.d.ts" target="_blank" rel="noopener">DefinitelyTyped/types/echarts/index.d.ts</a>，但是这个接口是否和 ECharts 吻合是不会有东西去检查的。</p><p>比如我们在项目的 <code>src/pages/home.ts</code> 中，引入并使用 ECharts，可以发现 <code>echarts</code> 这个变量是正确能访问的，但是如果我们访问 <code>echarts.version</code> 的话，就会编译报错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'page-home'</span>,</span><br><span class="line">  templateUrl: <span class="string">'home.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomePage &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> navCtrl: NavController</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(echarts); <span class="comment">// This is ok</span></span><br><span class="line">    <span class="built_in">console</span>.log(echarts.version); <span class="comment">// Compile-time error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为在 typings 定义的文件中，不存在 version 这个变量。而我们安装的当前版本的 ECharts 3.7.0 其实是有这个变量的，因此这是 TypeScript 编译器的误报。</p><p>对于这种情况，我们可以提 Pull Request，或者用这样的方式让 TypeScript 不对 ECharts 做类型检查：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'page-home'</span>,</span><br><span class="line">  templateUrl: <span class="string">'home.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomePage &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> navCtrl: NavController</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> ec = echarts <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(ec.version); <span class="comment">// '3.7.0'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，你就可以按一般使用 ECharts 的方法使用它了。</p><h2 id="初始化图表">初始化图表</h2><p>我们在 <code>home.html</code> 中创建一个 DIV 元素作为图表的容器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ion-content</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"chart"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ion-content</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>home.scss</code> 中将其 CSS 设为：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">page-home &#123;</span><br><span class="line">    <span class="selector-id">#chart</span> &#123;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，我们不能在 <code>HomePage</code> 的构造函数中初始化图表，因为这时候页面还没有构建， <code>document.getElementById('chart')</code> 返回的是 <code>null</code>。</p><p>正确的做法是，在 <code>ionViewDidEnter</code> 这个 Ionic 特定的函数中初始化图表，它将在进入这个页面后调用。这时候页面中已经有这个 DIV 并且正确的宽高了。整个 <code>home.ts</code> 文件是这样的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'page-home'</span>,</span><br><span class="line">  templateUrl: <span class="string">'home.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomePage &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ionViewDidEnter() &#123;</span><br><span class="line">    <span class="keyword">const</span> ec = echarts <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'chart'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(container.offsetWidth, container.offsetHeight);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们可以创建一个饼图了：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ec = echarts <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'chart'</span>);</span><br><span class="line"><span class="keyword">const</span> chart = ec.init(container);</span><br><span class="line">chart.setOption(&#123;</span><br><span class="line">    series: &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'pie'</span>,</span><br><span class="line">        data: [&#123;</span><br><span class="line">            name: <span class="string">'A'</span>,</span><br><span class="line">            value: <span class="number">10</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: <span class="string">'B'</span>,</span><br><span class="line">            value: <span class="number">20</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            name: <span class="string">'C'</span>,</span><br><span class="line">            value: <span class="number">30</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img class="single-img" src="/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-pie.png" alt="饼图"></p><h2 id="使用水球图">使用水球图</h2><p>ECharts 水球图是作为扩展存在的，因此不在 ECharts 项目中，但是使用起来也是意外地简单呢！</p><p>首先，我们使用 npm 安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save echarts-liquidfill</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Component &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> echarts <span class="keyword">from</span> <span class="string">'echarts'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts-liquidfill'</span>;</span><br><span class="line"><span class="meta">@Component</span>(&#123;</span><br><span class="line">  selector: <span class="string">'page-home'</span>,</span><br><span class="line">  templateUrl: <span class="string">'home.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HomePage &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  ionViewDidEnter() &#123;</span><br><span class="line">    <span class="keyword">const</span> ec = echarts <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'chart'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> chart = ec.init(container);</span><br><span class="line">    chart.setOption(&#123;</span><br><span class="line">      series: &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>, <span class="number">0.2</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能得到水球图啦！</p><p><img class="single-img" src="/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-liquidfill.png" alt="水球图"></p><p>是不是超简单的？</p><p>如果我们再配置一下水球图，就能得到更好玩的结果啦：</p><p><img class="single-img" src="/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-bottle.gif" alt="水球图"></p><p>图标来自 <a href="https://www.flaticon.com/" title="Flaticon" target="_blank" rel="noopener">www.flaticon.com</a> 的 <a href="http://www.freepik.com" title="Freepik" target="_blank" rel="noopener">Freepik</a>，基于 <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons BY 3.0" target="_blank">CC 3.0 BY</a> 发布。</p><p>这里，我们使用 SVG Path 定义了水球图的形状，并且在 HTML 中加入瓶子的图片，就能得到一个奶瓶啦！完整代码请参见 <a href="https://github.com/Ovilia/echarts-with-ionics/tree/master/src/pages/home" target="_blank" rel="noopener">GitHub 项目</a>。</p><p>是不是很酷呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在这个教程中，我们将使用 &lt;a href=&quot;http://ionicframework.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ionic&lt;/a&gt; 创建原生应用，并用 &lt;a href=&quot;http://echarts.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts&lt;/a&gt; 创建饼图和水球图。Ionic 项目开发语言是 TypeScript，而 ECharts 的官方版本是基于 JavaScript 的，本教程将带你轻松实现在 TypeScript 中创建 ECharts 图表。&lt;/p&gt;
&lt;p&gt;最终，我们将实现这样的效果：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;single-img&quot; src=&quot;/blog/echarts-with-ionic/2017-08-29-echarts-with-ionic-bottle.gif&quot; alt=&quot;运行结果&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="教程" scheme="http://efe.baidu.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Ionic" scheme="http://efe.baidu.com/tags/Ionic/"/>
    
  </entry>
  
  <entry>
    <title>ECharts v3.7 发布：富文本标签、可滚动图例</title>
    <link href="http://efe.baidu.com/blog/echarts-3-7-0/"/>
    <id>http://efe.baidu.com/blog/echarts-3-7-0/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2019-01-08T08:12:36.934Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECharts 新发布的 <a href="https://github.com/ecomfe/echarts/releases/tag/3.7.0" target="_blank" rel="noopener">3.7 版本</a> 中，广泛地增加了标签的表现力。可以支持定制文本块的样式，也支持对文本片段应用特定的样式，如设置颜色、大小、背景、图片、对齐方式等，从而可以做出丰富的效果。另外增加了可滚动的图例，从而对图例过多显示不下的问题，提供了一种解决方案。</p><p><img src="/blog/echarts-3-7-0/banner.png" width="100%"></p><a id="more"></a><hr><h2 id="富文本标签">富文本标签</h2><p>原先 echarts 中的文本标签，只能对整块统一进行样式设置，并且仅仅支持颜色和字体的设置，从而导致不易于制作表达能力更强的文字描述信息。</p><p>echarts v3.7 以后，支持了富文本标签，能够：</p><ul><li>能够定制文本块整体的样式（如背景、边框、阴影等）、位置、旋转等。</li><li>能够对文本块中个别片段定义样式（如颜色、字体、高宽、背景、阴影等）、对齐方式等。</li><li>能够在文本中使用图片做小图标或者背景。</li><li>特定组合以上的规则，可以做出简单表格、分割线等效果。</li></ul><p>例如：</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/pie-rich-text.png" data-src="http://echarts.baidu.com/gallery/view.html?c=pie-rich-text&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/treemap-obama.png" data-src="http://echarts.baidu.com/gallery/view.html?c=treemap-obama&amp;edit=1&amp;reset=1" style="width: 100%; height: 550px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bar-rich-text.png" data-src="http://echarts.baidu.com/gallery/view.html?c=bar-rich-text&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div><p><br></p><p>其他一些例子：</p><p><a href="http://echarts.baidu.com/gallery/view.html?c=map-labels&amp;edit=1&amp;reset=1" target="_blank" rel="noopener">Map Labels</a>, <a href="http://echarts.baidu.com/gallery/view.html?c=pie-nest&amp;edit=1&amp;reset=1" target="_blank" rel="noopener">Pie Labels</a>, <a href="http://echarts.baidu.com/gallery/view.html?c=gauge-car&amp;edit=1&amp;reset=1" target="_blank" rel="noopener">Gauge</a>.</p><p><br></p><p>为了支持这些样式设置，echarts 提供了丰富的文本配置属性，包括：</p><ul><li>字体基本样式设置：<code>fontStyle</code>, <code>fontWeight</code>, <code>fontSize</code>, <code>fontFamily</code>。</li><li>文字颜色：<code>color</code>。</li><li>文字描边：<code>textBorderColor</code>, <code>textBorderWidth</code>。</li><li>文字阴影：<code>textShadowColor</code>, <code>textShadowBlur</code>, <code>textShadowOffsetX</code>, <code>textShadowOffsetY</code>。</li><li>文本块或文本片段大小：<code>lineHeight</code>, <code>width</code>, <code>height</code>, <code>padding</code>。</li><li>文本块或文本片段的对齐：<code>align</code>, <code>verticalAlign</code>。</li><li>文本块或文本片段的边框、背景（颜色或图片）：<code>backgroundColor</code>, <code>borderColor</code>, <code>borderWidth</code>, <code>borderRadius</code>。</li><li>文本块或文本片段的阴影：<code>shadowColor</code>, <code>shadowBlur</code>, <code>shadowOffsetX</code>, <code>shadowOffsetY</code>。</li><li>文本块的位置和旋转：<code>position</code>，<code>distance</code>, <code>rotate</code>。</li></ul><p>详情参见教程：<a href="http://echarts.baidu.com/tutorial.html#%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">富文本标签</a></p><hr><h2 id="可滚动图例">可滚动图例</h2><p>有不少人会遇到这种问题：图例项数过多，导致覆盖住下面的图，或者甚至超出可视区域，难看而不可接受。之前遇到这种问题时，会建议大家自己使用 HTML 来实现外置的图例，调用 echarts 提供的图例相关 API 完成和 echarts 交互。但是，自己实现，毕竟有开发量，所以，终于在这个版本中，给出了一种能翻页图例控件，为这类问题提供了一种可选择的解决方案。</p>水平的图例：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/radar2.png" data-src="http://echarts.baidu.com/gallery/view.html?c=radar2&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div>垂直的图例：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/pie-legend.png" data-src="http://echarts.baidu.com/gallery/view.html?c=pie-legend&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div><p><strong>PS：上面这个是饼图使用的反面教材</strong></p><p>具体设置，可参见：<a href="http://echarts.baidu.com/option.html#legend.type" target="_blank" rel="noopener">legend.type</a>。</p><hr><h2 id="标签文本配置的扁平化">标签文本配置的扁平化</h2><p>在 echarts 中有众多的 <code>textStyle</code> 设置，例如 <a href="http://echarts.baidu.com/option.html#series-bar.label.normal.textStyle" target="_blank" rel="noopener">series-bar.label.normal.textStyle</a>、<a href="http://echarts.baidu.com/option.html#xAxis.axisLabel.textStyle" target="_blank" rel="noopener">xAxis.axisLabel.textStyle</a> 等等。这些 <code>textStyle</code> 有些层级过深和语法冗余，导致不方便，所以进行了扁平化，去掉了他们的 <code>textStyle</code> 这个层级。</p><p>也就是说，从前是这种写法：<code>label.normal.textStyle.fontSize</code>、<code>axisLabel.textStyle.fontSize</code>。</p><p><code>v3.7</code> 之后，推荐这种写法 <code>label.normal.fontSize</code>、<code>axisLabel.fontSize</code>。</p><p>当然，之前的写法仍然被兼容。</p><p>有这些地方进被扁平化了：</p><ul><li>axisPointer<del>.textStyle.xxx =&gt; axisPointer.xxx</del></li><li>xAxis.axisLabel<del>.textStyle</del>.xxx =&gt; xAxis.axisLabel.xxx</li><li>yAxis.axisLabel<del>.textStyle</del>.xxx =&gt; yAxis.axisLabel.xxx</li><li>radar.axisLabel<del>.textStyle</del>.xxx =&gt; radar.axisLabel.xxx</li><li>singleAxis.axisLabel<del>.textStyle</del>.xxx =&gt; singleAxis.axisLabel.xxx</li><li>radiusAxis.axisLabel<del>.textStyle</del>.xxx =&gt; radiusAxis.axisLabel.xxx</li><li>angleAxis.axisLabel<del>.textStyle</del>.xxx =&gt; angleAxis.axisLabel.xxx</li><li>parallel.parallelAxisDefault.axisLabel<del>.textStyle</del>.xxx =&gt; parallel.parallelAxisDefault.xxx</li><li>parallelAxis.axisLabel<del>.textStyle</del>.xxx =&gt; parallelAxis.axisLabel.xxx</li><li>series.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; series.label[normal|emphasis].xxx</li><li>series.data.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; series.data.label[normal|emphasis].xxx</li><li>series-gauge.axisLabel<del>.textStyle</del>.xxx =&gt; series-gauge.axisLabel.xxx</li><li>series-gauge.title<del>.textStyle</del>.xxx =&gt; series-gauge.title.xxx</li><li>series-gauge.detail<del>.textStyle</del>.xxx =&gt; series-gauge.detail.xxx</li><li>series-treemap.upperLabel[normal|emphasis]<del>.textStyle</del>.xxx =&gt; series-treemap.upperLabel[normal|emphasis].xxx</li><li>calendar.dayLabel<del>.textStyle</del>.xxx =&gt; calendar.dayLabel.xxx</li><li>series-graph.edgeLabel[normal|emphasis]<del>.textStyle</del>.xxx =&gt; series-graph.edgeLabel[normal|emphasis].xxx</li><li>calendar.dayLabel<del>.textStyle</del>.xxx =&gt; calendar.dayLabel.xxx</li><li>calendar.monthLabel<del>.textStyle</del>.xxx =&gt; calendar.monthLabel.xxx</li><li>calendar.yearLabel<del>.textStyle</del>.xxx =&gt; calendar.yearLabel.xxx</li><li>markPoint.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markPoint.label[normal|emphasis].xxx</li><li>markPoint.data.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markPoint.data.label[normal|emphasis].xxx</li><li>markLine.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markLine.label[normal|emphasis].xxx</li><li>markLine.data.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markLine.data.label[normal|emphasis].xxx</li><li>markArea.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markArea.label[normal|emphasis].xxx</li><li>markArea.data.label[normal|emphasis]<del>.textStyle</del>.xxx =&gt; markArea.data.label[normal|emphasis].xxx</li><li>tooltip.axisPointer.crossStyle<del>.textStyle</del>.xxx =&gt; tooltip.axisPointer.crossStyle.xxx</li><li>axisPointer.label<del>.textStyle</del>.xxx =&gt; axisPointer.label.xxx</li><li>timeline.label<del>.textStyle</del>.xxx =&gt; timeline.label.xxx</li><li>radar.name<del>.textStyle</del>.xxx =&gt; radar.name.xxx</li></ul><hr><p>此外，还有一些其他的细节增强和 BUG FIX，例如：</p><ul><li><p>[+] 对于时间坐标轴（即 <a href="http://echarts.baidu.com/option.html#xAxis.type" target="_blank" rel="noopener">axis.type</a> 为 <code>'time'</code>）支持了 <a href="http://echarts.baidu.com/option.html#xAxis.minInterval" target="_blank" rel="noopener">minInterval</a>。对于时间坐标轴和数值坐标轴（即 <a href="http://echarts.baidu.com/option.html#xAxis.type" target="_blank" rel="noopener">axis.type</a> 为 <code>'value'</code>）支持了 <a href="http://echarts.baidu.com/option.html#xAxis.maxInterval" target="_blank" rel="noopener">maxInterval</a>，从而能控制缩放（如 dataZoom）时刻度的最大最小范围。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#xAxis.axisLine.onZeroAxisIndex" target="_blank" rel="noopener">xAxis.axisLine.onZeroAxisIndex</a>，从而能在多轴并且需要轴 <code>onZero</code> 的场景下，灵活设置轴互相的对应关系。参见 <a href="https://github.com/ecomfe/echarts/issues/5069" target="_blank" rel="noopener">#5069</a>。</p></li><li><p>[+] 支持了 <code>自定义系列(custom series)</code> 不使用 <a href="http://echarts.baidu.com/option.html#series-custom.coordinateSystems" target="_blank" rel="noopener">坐标系</a>。</p></li><li><p>[+] 支持了柱状图标签的旋转。参见 <a href="http://echarts.baidu.com/option.html#series-bar.label.normal.rotate" target="_blank" rel="noopener">rotate</a>、<a href="http://echarts.baidu.com/option.html#series-bar.label.normal.align" target="_blank" rel="noopener">align</a>、<a href="http://echarts.baidu.com/option.html#series-bar.label.normal.verticalAlign" target="_blank" rel="noopener">verticalAlign</a>。参见 <a href="https://github.com/ecomfe/echarts/issues/5309" target="_blank" rel="noopener">#5309</a>。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#radar.indicator.color" target="_blank" rel="noopener">radar.indicator.color</a>，从而雷达每个标签能设置不同颜色。参见 <a href="https://github.com/ecomfe/echarts/issues/6128" target="_blank" rel="noopener">#6128</a>。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#dataZoom.rangeMode" target="_blank" rel="noopener">dataZoom.rangeMode</a>，从而能在数据更新时固定缩放区域。参见 <a href="https://github.com/ecomfe/echarts/issues/6040" target="_blank" rel="noopener">#6128</a>。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/api.html#action.legend.legendToggleSelect" target="_blank" rel="noopener">action.legend.legendToggleSelect</a>, <a href="http://echarts.baidu.com/api.html#action.legend.legendSelect" target="_blank" rel="noopener">action.legend.legendSelect</a>, <a href="http://echarts.baidu.com/api.html#action.legend.legendUnSelect" target="_blank" rel="noopener">action.legend.legendUnSelect</a> 中使用 <code>dataIndex</code>。参见 <a href="https://github.com/ecomfe/echarts/issues/4242" target="_blank" rel="noopener">#4242</a>。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#series-map.label.formatter" target="_blank" rel="noopener">map.label.formatter</a>，从而方便于在地图系列中使用富文本标签。参见：<a href="http://echarts.baidu.com/demo.html#map-labels" target="_blank" rel="noopener">地图标签</a>。</p></li></ul><p>更多的升级信息，参见 <a href="http://echarts.baidu.com/changelog.html" target="_blank" rel="noopener">changelog</a>。</p><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script>(function () {    if (typeof jQuery === 'undefined') {        return;    }    var $ = jQuery;    var env = window['MD_ENV'];    var $ = jQuery;    var useThumb = env && (env.os.phone || env.os.tablet);    var blockList = $('.ec-lazy');    var $win = $(window);    blockList.each(function (index, block) {        block = $(block);        var src = block.attr('data-src');        block.attr('data-src', src);    });    // Lazy load.    $win.on('scroll', showBlock);    $(showBlock);    function initThumb(block, $block, blockThumb, blockSrc) {        $block.css('lineHeight', $block.height() + 'px');        block.innerHTML = [            '<img style="width:100%;height:auto;margin:0;padding:0;vertical-align:middle;" src="', blockThumb, '"/>',            // for vertial middle            '<div style="vertical-align: middle; height: 100%; width: 0"></div>',            '<div style="cursor:pointer;thumb-btn;position:absolute;bottom:10px;width:100%;height:22px;line-height:22px;text-align:center;">',                '<em style="font-style:normal;border-radius:3px;padding:3px 5px;margin:3px 5px;color:white;background:#337ab7;font-size:12px;line-height:1.5;">点击图片加载真实图表</em>',            '</div>',            '<div class="ec-lazy-block-mask" style="cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;margin:0;"></div>'        ].join('');        $block.find('.ec-lazy-block-mask').on('click', function () {            initIFrame(block, $block, blockThumb, blockSrc);        });    }    function initIFrame(block, $block, blockThumb, blockSrc) {        block.innerHTML = [            '<iframe style="overflow:hidden;width:100%;height:100%;margin:0;padding:0;" src="' , blockSrc, '">',            'frameborder="no" border="0" marginwidth="0" marginheight="0"',            'scrolling="no" hspace="0" vspace="0"></iframe>'        ].join('');    }    function showBlock() {        blockList.each(function (idx, block) {            var $block = $(block);            var blockSrc = $block.attr('data-src');            var blockThumb = $block.attr('data-thumb');            if (!blockSrc) {                return;            }            $block.css({                position: 'relative',                overflow: 'hidden',                textAlign: 'center',                padding: 0            });            var winScrollTop = $win.scrollTop();            var blockTop = block.offsetTop;            var winHeight = $win.height();            var winBottom = winScrollTop + winHeight;            var blockBottom = blockTop + $block.height();            if (winBottom >= blockTop && winBottom <= (blockBottom + winHeight)) {                $block.attr('data-src', '');                (useThumb && blockThumb)                    ? initThumb(block, $block, blockThumb, blockSrc)                    : initIFrame(block, $block, blockThumb, blockSrc);            }        });    }})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECharts 新发布的 &lt;a href=&quot;https://github.com/ecomfe/echarts/releases/tag/3.7.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.7 版本&lt;/a&gt; 中，广泛地增加了标签的表现力。可以支持定制文本块的样式，也支持对文本片段应用特定的样式，如设置颜色、大小、背景、图片、对齐方式等，从而可以做出丰富的效果。另外增加了可滚动的图例，从而对图例过多显示不下的问题，提供了一种解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-3-7-0/banner.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>San - 一个传统的MVVM组件框架</title>
    <link href="http://efe.baidu.com/blog/san-a-traditional-mvvm-component-framework/"/>
    <id>http://efe.baidu.com/blog/san-a-traditional-mvvm-component-framework/</id>
    <published>2017-06-21T16:00:00.000Z</published>
    <updated>2017-06-22T04:29:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/san-a-traditional-mvvm-component-framework/logo.svg" height="220"></p><p>这一年多来，其实受到过不少质疑，比如“咦，你们又在发明轮子了？”。每当此时我只能嘿嘿嘿一笑，毕竟你做的东西看起来还只是个垃圾而已，而看起来我们有很多成熟的东西可以选了：<a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>、<a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a>、<a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>、<a href="https://www.polymer-project.org/" target="_blank" rel="noopener">Polymer</a>等等。在今天，我们觉得 <a href="https://ecomfe.github.io/san/" target="_blank" rel="noopener">San</a> 经过了一些项目的验证（踩坑）和进化（填坑），能够出来见人时，我们打算出来说说为啥要造轮子，造的是个啥样的轮子。</p><p>根据厚脸皮的惯例，先求Star。接下来是广告，可能你能从广告里得到一点启发。</p><iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=san&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe><h3 id="为什么要做-san">为什么要做 San</h3><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM</a> 并不是什么新鲜事物，在 Web 上的应用我们也远不是先驱。从几年前，我们有些团队在 <a href="https://angular.io/" target="_blank" rel="noopener">Angular</a>1 开始一些实践，也有些团队接触了 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a>，但是让我印象最深刻的还是 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue</a>，并不是因为多高深的技术，而是因为真的“好用”。我们在一些要求不那么高（兼容性、性能等）的应用中实践一些流行技术，并享受一些便利。将近2年前，我们对实践过的东西进行了一些总结，有些东西已经比较常识了：</p><ul><li>组件化</li><li>声明式视图</li><li>view=f(data)</li><li>数据到视图的渲染引擎</li><li>异步渲染</li><li>......</li></ul><a id="more"></a><p>但是由于 IE8- 占有率仍然可观，在 to C 的应用中，我们只能老老实实的 <a href="http://jquery.com/" target="_blank" rel="noopener">JQuery</a>、挨个 DOM 操作。兼容性是横在我们面前最大的问题。随着时间流逝，总有一天兼容性将不再是问题，但你真的要等到几年后所有落后都淘汰吗？任何时候我们都会发现有一些东西将要被淘汰，有一些东西将要来，但如果你站着不动，还不如去当一块叉烧咯。</p><p>说白了，不折腾会死的精神让我们开了新坑，初衷仅仅是因为 <strong>兼容性</strong> ，这种看起来不大又可笑的理由。但是它确实绕不开，它也可能会带来其他问题，比如移动端和PC端无法使用相同的组件架构。</p><h3 id="为什么叫-san">为什么叫 San</h3><p>在 2010 年左右，为了应对 SPA 类型的各种业务系统，我们写了个 MVC 的框架叫 ER（Enterprise RIA），看起来是个 2。主席<a href="https://www.zhihu.com/people/justineo/answers" target="_blank" rel="noopener">Justineo</a>说既然新坑要比老坑更先进，那就叫 3 吧。一帮起名困难症患者觉得貌似很有道理，于是就这么定了。</p><p>所以 San 不是什么的缩写，就是 3 而已......虽然名字很随意，但是造轮子的过程我们是认真的</p><h3 id="把-san-做成什么样">把 San 做成什么样</h3><p>既然要自己做了，那我们希望完整的表达我们的想法和原则，不是东拼西凑的追随。</p><h4 id="怎样都能用">怎样都能用</h4><p>你想怎样引用一个 Library？</p><ul><li>直接下下来</li><li>npm install</li><li>CDN</li></ul><p>产品开发是什么环境？</p><ul><li>啥都没，裸的，怎样开发怎样上线</li><li>有些简单的 bundle 和 compress</li><li>模块化管理，不过是古老的 AMD</li><li>主流代表，WebPack + Babel</li></ul><p>我们不关心你从哪里来，要到哪里去，我们只想给你提供一个舒适的港湾。这个广告词是不是恶心到大家了...... <strong>怎样都能用</strong> 确实是我们的目标，提供 CDN、支持 AMD 和 Global Object、npm publish 也都是很简单的事情，更难抉择的是 “你们怎么解决兼容性问题”。</p><h4 id="通过方法操作组件数据解决兼容性">通过方法操作组件数据，解决兼容性</h4><p>在 San 组件中，对数据的变更需要通过 <code>set</code> 或 <code>splice</code> 等方法。<a href="https://ecomfe.github.io/san/tutorial/data-method/" target="_blank" rel="noopener">数据操作</a>文档详细描述了这一点。这意味着：</p><ul><li>用最简单的形式，解决兼容性问题</li><li>San 的开发体验不可能做的比 Vue 更好</li><li>数据操作的过程可控。实际上，从 3.1.0 开始，数据变更在内部是 Immutable 的</li><li>change tracking好做了。我们并不认为 v-dom 是万金油，并且 San 是面向 Web 设计的，我们并没期望它跨平台。所以少掉 v-dom 这一层是一件好事</li></ul><p>我们也考虑过让使用者自己通过 Immutable 的方式操作数据，然后再怼回来，但这样对使用者的成本会变高，而且使用者未必会理解为啥要这样干，所以还是封起来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.data.set(<span class="string">'user'</span>, userName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"></span><br><span class="line">setData(<span class="built_in">Object</span>.assign(&#123;&#125;, data, &#123;<span class="attr">user</span>: userName&#125;));</span><br></pre></td></tr></table></figure><p>但是，把数据封起来意味着获取数据成本也变高了，特别是想一次获取多个数据的时候。所以我们把获取数据的 get 方法实现为，无参的时候返回整个数据对象，如果你用 ESNext 开发可以方便的使用解构。但是，操作数据还是要通过 <code>set</code> 或 <code>splice</code> 等方法的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;name, email&#125; = <span class="keyword">this</span>.data.get();</span><br></pre></td></tr></table></figure><h4 id="组件形态">组件形态</h4><p>虽然我们很欣赏 Vue，但是我们并不认同 component = data。在 Vue 中，数据直接置于组件下，methods被规约。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#example-3'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// methods被规约</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">        reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们更习惯 method 直接置于组件下，数据被规约（其实已经被封装）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">san.defineComponent(&#123;</span><br><span class="line">    template: <span class="string">'&lt;div&gt;...&lt;button type="button" on-click="submit"&gt;submit&lt;/button&gt;&lt;/div&gt;'</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// method 直接置于组件下</span></span><br><span class="line">    submit: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> title = <span class="keyword">this</span>.data.get(<span class="string">'title'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!title) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendData(&#123;<span class="attr">title</span>: title&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过，这是一个理念问题，并没有谁好谁坏。</p><h4 id="组件声明">组件声明</h4><p>我们认为组件应该是一个 class（不要较真，就是 function）。在 ESNext 中，我们可以利用 extends 构造组件之间的继承关系。这样看起来更自然。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">'san'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> template = <span class="string">'&lt;p&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/p&gt;'</span>;</span><br><span class="line"></span><br><span class="line">    initData() &#123; </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'San'</span>&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ESNext 是无法声明 prototype property 的。所以，对于 template / filters / components 等属性，San 提供了 static property 的支持。</p><p>对于不愿意使用 ESNext 的产品，我们提供 defineComponent 方法，能够方便快捷的声明组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> HelloComponent = san.defineComponent(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p&gt;Hello &#123;&#123;name&#125;&#125;!&lt;/p&gt;'</span>,</span><br><span class="line"></span><br><span class="line">    initData: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">name</span>: <span class="string">'San'</span>&#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="组件反解">组件反解</h4><p>我们希望 San 能够从带有特定标记的 HTML 中，解析出组件结构来，通过组件来响应和管理后续的用户交互等操作，我们管这事叫做 <a href="https://ecomfe.github.io/san/tutorial/reverse/" target="_blank" rel="noopener">组件反解</a>。 （什么，你说叫反序列化？也行啊，开心就好）</p><ul><li>后端直出 HTML 在首屏时间是有优势的，特别是内容为主的应用</li><li>使用 NodeJS 提供在线 Web 服务不一定在任何地方都行得通，至少在我厂很多地方是行不通的。NodeJS 也不是万金油</li></ul><p>所以我们先制定了 <code>特定标记</code> 的协议，基于此实现了组件反解的功能。后来实现的 NodeJS 服务端渲染功能也是基于 <strong>组件反解</strong> 的，输出符合协议的 HTML。</p><p>另外，对于服务端渲染，恐怕大家最关心的是性能。<a href="https://ecomfe.github.io/san/tutorial/ssr/" target="_blank" rel="noopener">San的服务端渲染</a>经过测试，比号称最快的 JS 模板引擎 <a href="http://aui.github.io/art-template/" target="_blank" rel="noopener">art-template</a> 慢30%-40%，慢的部分主要是因为要额外生成前端可被辨识和反解的标记。已经是 string-based 模板引擎的性能级别了。</p><h4 id="k">10k</h4><p>在各种 Library 不在乎体积的今天，大体积的副作用其实并不少，除了网络传输以外，<a href="http://www.infoq.com/cn/articles/javascript-start-up-performance" target="_blank" rel="noopener">移动端 JS Parse 的时间其实并不可忽视</a>。所以我设定了个目标，不包含开发调试支持的版本，GZip 后体积不能超过 10k。为什么是 10k 呢，拍脑袋而已，可能是 mission impossible，不去试试谁知道呢？</p><p>最开始的简陋版本确实不太大，但是由于增加兼容性的处理、增加新 feature、代码拆分，让我们不止一次体积超过 10k。每次回头去找代码有什么可以优化的地方，到后来可优化的地方越来越少，也差点被当成强迫症患者送去医院。不过到最后竟然真的做到了。</p><p>其实这也不是什么很有技术含量的事情，为此我们直接手写 ES5 代码而不是 ESNext + Babel，在很多人看来还是挺 low B 的。具体是不是 10k 也没什么意义，只是态度而已。我们希望 San 的使用者不会受到体积的困扰，我们也希望体积强迫症患者能有更多的选择。</p><h4 id="性能">性能</h4><p>在我们刚开始做 San 的时候，很多流行的方案还是有一些性能问题的（比如Angular的更新、Vue的初始渲染等等）。但是世界变化那么快，1年多过去了，现在大家的性能其实都还不错，谁比谁笨呢？San 的性能也还不错，但也没有一骑绝尘，大家都差不多，不同场景也各有优势。感兴趣的同学自己测吧。</p><h3 id="还有些什么">还有些什么</h3><h4 id="应用状态管理">应用状态管理</h4><p>这年头，一个方案里没有应用状态管理，别人看你都像残废。所以我们提供了 <a href="https://github.com/ecomfe/san-store" target="_blank" rel="noopener">san-store</a>。它还是有自己的特点的：</p><ul><li>名字有特点。在大家都叫 nnnx 的时候，我们希望传达 store 做为全局唯一的应用状态源的观念，就叫 store了</li><li>抽象有不同。我们还是希望尽量好用好理解。redux 的模式我们嫌烦琐，为了假装有节操又不能抄 vuex，所以我们提供了更简单的抽象，只有Action。</li><li>应用状态数据的操作，我们通过 <a href="https://github.com/ecomfe/san-update" target="_blank" rel="noopener">san-update</a> 完成</li></ul><h4 id="router">router</h4><p>这也是一个没有就残废的东西，但想想也没啥好说的，有需要的自己看吧。<a href="https://github.com/ecomfe/san-router" target="_blank" rel="noopener">san-router</a></p><h4 id="组件库">组件库</h4><p>组件库是减少实际业务开发工作量、解放生产力的根本。</p><ul><li><a href="https://material.io/guidelines/" target="_blank" rel="noopener">Material Design</a> 是认知度比较高的一套视觉体系，我们基于它开发了一个<a href="https://ecomfe.github.io/san-mui/" target="_blank" rel="noopener">MUI组件库</a>。</li><li><a href="https://weui.io/" target="_blank" rel="noopener">WeUI</a> 是微信输出的、Mobile 友好的一套视觉体系，但是目前没有 San 的实现，欢迎感兴趣的同学来一套，质量好的话我们会在官网推荐喔。</li><li><a href="https://ant.design/" target="_blank" rel="noopener">AntDesign</a> 是蚂蚁输出的、适合各种管理系统的一套视觉体系，但是目前没有 San 的实现，也欢迎感兴趣的同学来一套，质量好的话我们会在官网推荐喔。</li><li>如果你的应用拥有自己的视觉体系，自己开发组件库是免不了的</li></ul><p>曾经有人和我说，你们应该推自己的组件库啊，其实大家做应用的时候并不 care 是什么，只要好看好用就行。可是我厂是没有自己的视觉交互体系的，我能怎么办，我也很绝望啊。</p><h4 id="devtool">DevTool</h4><p>DevTool 在写这篇广告的时候还没有 ready，快了，一周以内吧。请关注 <a href="https://ecomfe.github.io/san/" target="_blank" rel="noopener">San WebSite</a></p><h3 id="最后">最后</h3><p>到这里，应该不难看出，San 有一些 <strong>传统</strong> 的地方：</p><ul><li>还在兼容 Old IE</li><li>还在考虑不使用 babel transform 的业务开发场景</li><li>还在为体积纠结</li><li>还想保持后端无关，而不是推 NodeJS</li></ul><p>如果拿车来比喻，我们想造的是一台陆巡。相比轿车甚至多数SUV，它没有那么好开，看不到很多 2.0T 的车尾灯；相比牧马人和 benz G，他越野能力和通过性也没那么强。但是它很可靠，能稳稳当当、舒适地带你到任何想去的地方。</p><p>既然你都能有耐心看到这，不介意关注下？ ^_^</p><iframe src="https://ghbtns.com/github-btn.html?user=ecomfe&amp;repo=san&amp;type=star&amp;count=true" frameborder="0" scrolling="0" width="170px" height="20px"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/san-a-traditional-mvvm-component-framework/logo.svg&quot; height=&quot;220&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一年多来，其实受到过不少质疑，比如“咦，你们又在发明轮子了？”。每当此时我只能嘿嘿嘿一笑，毕竟你做的东西看起来还只是个垃圾而已，而看起来我们有很多成熟的东西可以选了：&lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;、&lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React&lt;/a&gt;、&lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular&lt;/a&gt;、&lt;a href=&quot;https://www.polymer-project.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Polymer&lt;/a&gt;等等。在今天，我们觉得 &lt;a href=&quot;https://ecomfe.github.io/san/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;San&lt;/a&gt; 经过了一些项目的验证（踩坑）和进化（填坑），能够出来见人时，我们打算出来说说为啥要造轮子，造的是个啥样的轮子。&lt;/p&gt;
&lt;p&gt;根据厚脸皮的惯例，先求Star。接下来是广告，可能你能从广告里得到一点启发。&lt;/p&gt;
&lt;iframe src=&quot;https://ghbtns.com/github-btn.html?user=ecomfe&amp;amp;repo=san&amp;amp;type=star&amp;amp;count=true&quot; frameborder=&quot;0&quot; scrolling=&quot;0&quot; width=&quot;170px&quot; height=&quot;20px&quot;&gt;
&lt;/iframe&gt;
&lt;h3 id=&quot;为什么要做-san&quot;&gt;为什么要做 San&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM&lt;/a&gt; 并不是什么新鲜事物，在 Web 上的应用我们也远不是先驱。从几年前，我们有些团队在 &lt;a href=&quot;https://angular.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Angular&lt;/a&gt;1 开始一些实践，也有些团队接触了 &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React&lt;/a&gt;，但是让我印象最深刻的还是 &lt;a href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue&lt;/a&gt;，并不是因为多高深的技术，而是因为真的“好用”。我们在一些要求不那么高（兼容性、性能等）的应用中实践一些流行技术，并享受一些便利。将近2年前，我们对实践过的东西进行了一些总结，有些东西已经比较常识了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组件化&lt;/li&gt;
&lt;li&gt;声明式视图&lt;/li&gt;
&lt;li&gt;view=f(data)&lt;/li&gt;
&lt;li&gt;数据到视图的渲染引擎&lt;/li&gt;
&lt;li&gt;异步渲染&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="MVVM" scheme="http://efe.baidu.com/tags/MVVM/"/>
    
      <category term="San" scheme="http://efe.baidu.com/tags/San/"/>
    
  </entry>
  
  <entry>
    <title>在 ECharts GL 中绘制三维地图</title>
    <link href="http://efe.baidu.com/blog/building-realistic-map-with-echarts-gl/"/>
    <id>http://efe.baidu.com/blog/building-realistic-map-with-echarts-gl/</id>
    <published>2017-06-13T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>ECharts 前段时间发布了超亮眼的 GL，相对于之前已经圈粉无数的 ECharst-X 而言，ECharst GL更是帅到爆，无论是性能、颜值、类型都有了巨大的飞跃。但是对于小编这样的设计师来说是不是更易上手呢？答案是肯定的，我们除了能够根据数据画出诸如三维地图等三维的可视化图之外，只需要在项目中加入几个简单的配置项，就能配制出想要的风格的高质量画面效果。</p><p>这篇教程就希望通过在 Gallery 里绘制一个有丰富的光效、阴影的写实风格的三维地图的例子，简单介绍一些ECharts GL与画质相关的配置项，最终效果见 <a href="http://gallery.echartsjs.com/editor.html?c=xBkY4tpszb" class="uri" target="_blank" rel="noopener">http://gallery.echartsjs.com/editor.html?c=xBkY4tpszb</a>（下图为最后的效果）。涉及到太高深专业的算法、代码、什么什么的小设计师我实在是不会，所以这个仅仅能当 GL 入门级教程使用哦～</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/banner.png"></div><a id="more"></a><h2 id="绘制一个基础的三维地图">绘制一个基础的三维地图</h2><p>首先我们在 Gallery 中用 ECharts GL 画一个基础的三维地图。注意因为 GL 是 ECharts 的一个扩展，所以我们需要在 Gallery 中额外引入 GL 的脚本文件。 「引入文件」只需要在 Gallery中新建作品，然后在「脚本」的配置中加入这行地址就行了。</p><p><a href="http://echarts.baidu.com/resource/echarts-gl-latest/dist/echarts-gl.min.js" class="uri" target="_blank" rel="noopener">http://echarts.baidu.com/resource/echarts-gl-latest/dist/echarts-gl.min.js</a></p><p>如果要绘制世界地图的话还需要引入上面「常用脚本」的世界地图文件。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/scripts.png"></div><p>做好准备工作后我们就可以开始画一个三维的世界地图了，GL 中画三维地图的配置项跟画普通的二维地图一样，只是系列名称从原来的<code>map</code>改成<code>map3D</code>。</p><p>我们先用下面的最基础配置项，基于引入的脚本，生成一个最基础的三维地图系列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'map3D'</span>,</span><br><span class="line">        map: <span class="string">'world'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>是不是很简单，当然画出来的效果也是非常基础和简陋的。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-basic.png"></div><p>接下来就我们需要做的就是一步一步的添加光照、阴影、后期的配置项把这个三维地图画得更漂亮。</p><h2 id="添加更丰富的灯光">添加更丰富的灯光</h2><p>GL 中大部分组件都支持灯光的配置，这些灯光会影响到组件中的所有图形，灯光的配置项需要统一在组件<code>light</code>属性下设置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">light: &#123;</span><br><span class="line">    main: &#123;</span><br><span class="line">        intensity: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ambient: &#123;</span><br><span class="line">        intensity: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况下组件中默认会有一个主光源<code>main</code>和一个全局的环境光<code>ambient</code>。主光源起到了主要的照明作用，可以让我们刚才画出来的三维地图产生基础的明暗对比，从而使图形产生真实的立体感。全局的环境光可以为整个场景提供全局照亮和统一材质的效果。（添加光照效果如下图）</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-light.png"></div><p>我们可以通过<code>intensity</code>属性设置不同光源的强度。例如在上面的代码中我们将主光源的强度设成<code>2</code>，环境光源的强度设成<code>0</code>后可以得到更加强烈的明暗对比。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-light-high-contrast.png"></div><p>默认的环境光只是单纯的对所有图形都加上一个固定的亮度，所以会显得很平淡，如果把主光源去掉（<code>intensity</code>设为<code>0</code>）的话，整个地图场景会变成灰色。所以为了更丰富的光照效果，我们可以使用 GL 提供的更为强大的<code>ambientCubemap</code>作为环境光源。</p><p><code>ambientCubemap</code>是指使用一张全景贴图作为环境光源。一般全景的环境光贴图大概是下面这样。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/hdr.png"></div><p>大家使用手机的全景模式中就可以拍出类似的全景照片。不过小编建议去寻找专业的 <a href="https://zh.wikipedia.org/zh-hans/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F" target="_blank" rel="noopener">HDR</a> 格式的全景图资源。这里推荐一个有不少免费的HDR全景图资源的网站 <a href="http://www.hdrlabs.com/sibl/archive.html" class="uri" target="_blank" rel="noopener">http://www.hdrlabs.com/sibl/archive.html</a>。</p><p>找到合适的全景图片后，我们可以在 Gallery 的<code>导入数据</code>中上传该图片。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/asset-hdr.png"></div><p>得到在 Gallery 上该图片地址链接后插入到<code>ambientCubemap</code>的<code>texture</code>属性中。 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">light: &#123;</span><br><span class="line">    main: &#123;</span><br><span class="line">        intensity: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ambient: &#123;</span><br><span class="line">        intensity: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ambientCubemap: &#123;</span><br><span class="line">        diffuseIntensity: <span class="number">1</span>,</span><br><span class="line">        texture: <span class="string">'/asset/get/s/data-1497251035660-HkVJTnsMW.hdr'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>设置了<code>texture</code>属性后 GL 就会自动启用环境光贴图作为环境光源。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-ambientcubemap.png"></div><p>因为全景贴图的每个像素都会被计算到光照里，所以相比普通的环境光，使用环境光贴图会让整个光照会显得更真实和丰富。</p><p>为了得到更真实的环境光效果，注意此处建议使用<code>.hdr</code>格式的图片，因为 <a href="https://zh.wikipedia.org/zh-hans/%E9%AB%98%E5%8A%A8%E6%80%81%E8%8C%83%E5%9B%B4%E6%88%90%E5%83%8F" target="_blank" rel="noopener">HDR</a> 也就是高动态范围图像，它比其他格式的图像有更大亮度的数据存储。对比一下同一张图片<code>HDR</code>和<code>PNG</code>格式照亮的不同效果。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-hdr-compare.png"></div><h2 id="添加阴影">添加阴影</h2><p>有光的地方就会有阴影，阴影给了光照更多的层次，失去了阴影的光照是没有灵魂的，是平淡乏味的。</p><p>在 GL 中可以简单的加上<code>shadow: true</code>为主光源添加阴影。同时为了让三维地图有一种放在地面上的立体模型的感觉，我们再显示一个地面<code>groundPlane</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">light: &#123;</span><br><span class="line">    main: &#123;</span><br><span class="line">        intensity: <span class="number">1</span>,</span><br><span class="line">        shadow: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ambient: &#123;</span><br><span class="line">        intensity: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ambientCubemap: &#123;</span><br><span class="line">        diffuseIntensity: <span class="number">1</span>,</span><br><span class="line">        texture: <span class="string">'/asset/get/s/data-1491896094618-H1DmP-5px.hdr'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">groundPlane: &#123;</span><br><span class="line">    show: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-shadow.png"></div><p>通过阴影还可以更容易得感受到光照的方向，我们可以通过设置主光源<code>alpha</code>、<code>beta</code>两个属性设置不同的光照角度，来查看阴影的变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main: &#123;</span><br><span class="line">    intensity: <span class="number">1</span>,</span><br><span class="line">    shadow: <span class="literal">true</span>,</span><br><span class="line">    alpha: <span class="number">150</span>,</span><br><span class="line">    beta: <span class="number">70</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-shadow-long.png"></div><p>这样就可以实现之前设计圈非常流行的一种长阴影的风格。</p><h2 id="更丰富的颜色">更丰富的颜色</h2><p>到这里我们得到的效果跟最初那个简陋的画面已经是天壤之别了，小编作为一个设计师是很钟情于白模的效果的，但是如果你手里有一份数据的话更是锦上添花。 数据的上传和转换可以通过echarts提供的表格数据转换工具实现， <a href="http://echarts.baidu.com/spreadsheet.html" class="uri" target="_blank" rel="noopener">http://echarts.baidu.com/spreadsheet.html</a>，数据部分内容不在此多述。如果暂时没有现成数据，可以直接先复制教程实例中的数据，见左侧代码区域<code>var regionData = [{……}];</code>内的全部内容，直接复制粘贴即可进行之后操作。</p><p><img src="/blog/building-realistic-map-with-echarts-gl/data.png" width="500px" alt=""></p><p>将这份数据导入并写入配置项里，</p><p><img src="/blog/building-realistic-map-with-echarts-gl/data-assign.png" width="430px" alt=""></p><p>接下来，我们可以使用 ECharts 中视觉映射「visualMap」组件将地图中的每块区域赋予不同的颜色。</p><p>在 ECharts GL 中使用 visualMap 和在ECharts中并没有任何的不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">visualMap: &#123;</span><br><span class="line">    show: <span class="literal">false</span>,</span><br><span class="line">    min: <span class="number">0</span>,</span><br><span class="line">    max: <span class="number">15</span>,</span><br><span class="line">    inRange: &#123;</span><br><span class="line">        color: [<span class="string">'#313695'</span>, <span class="string">'#4575b4'</span>, <span class="string">'#74add1'</span>, <span class="string">'#abd9e9'</span>, <span class="string">'#e0f3f8'</span>, <span class="string">'#ffffbf'</span>, <span class="string">'#fee090'</span>, <span class="string">'#fdae61'</span>, <span class="string">'#f46d43'</span>, <span class="string">'#d73027'</span>, <span class="string">'#a50026'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样子每个国家根据不同数据就呈现出不同的颜色啦。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/map3D-data.png"></div><h2 id="后期处理">后期处理</h2><p>看到后期可能大家第一个想到的就是使用 PS 调色，小编这次主要用到的确实是调色。但其实GL 中除了调色之外，还有例如景深 、描边等诸多的后期效果能让整个画面呈现出你需要的效果，大家之后可以大胆的尝试。</p><p>不知道大家是否能感受到其实此时得到的图片整体明度偏暗，色相偏蓝。就如我们在拍完照片后发现色调和曝光不理想需要再次调整图片一样，我们也需要对这张的画面进行后期处理和调色。</p><p>后期处理的配置项都是在组件的<code>postEffect</code>下。首先可以通过 enable 属性开启。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postEffect: &#123;</span><br><span class="line">    enable: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启后 GL 会自动对整个画面调整曝光到合适的颜色。</p><p>当然如果这个画面并不能让我们满意的话，我们还可以通过<code>postEffect</code>下的<code>colorCorrection</code>配置项去手动的调整颜色。<code>colorCorrection</code>下有常见的曝光<code>exposure</code>、亮度<code>brightness</code>、对比度<code>contrast</code>和饱和度<code>saturation</code>选项。</p><p>但是这次小编要教大家使用这里面更强大的颜色查找表功能<code>lookupTexture</code>。这个功能可以让我们在 PS 等自己用着顺手的图像处理软件里处理好图片之后再到 GL 里复现我们在 PS 里调整的颜色曲线。</p><p>小编给大家提供了一张初始的颜色查找表，大家把下面这张查找表的图片下载下来后和你的作品截图一起放入 Photoshop 中（可以把作品截图拖入查找表图层的上方，注意需要保持查找表大小不变，作品截图是为了让我们直观的预览调整的效果，调到满意之后，删除作品图层，只保存查找表，之后在GL中载入查找表，查找表的颜色映射会直接在GL中复现）。</p><p><img src="/blog/building-realistic-map-with-echarts-gl/lookup.png" width="300px" alt=""></p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/ps.png"></div><p>点击左下角<code>创建新的填充或调整工具</code>来选择自己需要调整的配置项，此时两个图层是可以同时调整的，这里可以自由调整各项参数来实现自己想要的效果。我在此使用的是<code>颜色查找</code>下自带的<code>Candlelight.cube</code>将图片调整成了一种蜡烛光照的复古风格，又调整了亮度和对比度使其更清晰。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/ps-adjusted.png"></div><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/ps-adjusted2.png"></div><p>调整完成之后，隐藏作品截图的图层，只需保存颜色查找表（如下图）</p><p><img src="/blog/building-realistic-map-with-echarts-gl/lookup-adjusted.png" width="300px" alt=""></p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/asset-lookup.png"></div><p>将该图在 Gallery 内上传数据，得到在 Gallery 上该图片地址链接后插入到<code>colorCorrection</code>的 <code>lookupTexture</code>中即可。</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/code-lookup.png"></div><p>到此，在 ECharts GL 中配置一个三维地图的步骤就完成啦，还想解锁更多 GL 技能的话， 可以直接去 ECharts 官网查看 GL 超多酷炫的实例，或者去查看GL的配置项手册 <a href="http://echarts.baidu.com/option-gl.html" class="uri" target="_blank" rel="noopener">http://echarts.baidu.com/option-gl.html</a> 尽情的尝试吧～</p><div class="figure"><img src="/blog/building-realistic-map-with-echarts-gl/banner.png"></div><h2 id="总结">总结</h2><p>本文我们介绍了如何在 ECharts GL 中配置出一张好看的写实风格三维地图。小编要偷偷地告诉你，用 ECharts GL 生成的效果图你还可以直接用来做图片素材哦，如果你还在为 PPT 或者自己的设计作品找不到合适的配图素材发愁的话，快来试试直接在 Gallery 里用 ECharts GL 直接生成一张吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ECharts 前段时间发布了超亮眼的 GL，相对于之前已经圈粉无数的 ECharst-X 而言，ECharst GL更是帅到爆，无论是性能、颜值、类型都有了巨大的飞跃。但是对于小编这样的设计师来说是不是更易上手呢？答案是肯定的，我们除了能够根据数据画出诸如三维地图等三维的可视化图之外，只需要在项目中加入几个简单的配置项，就能配制出想要的风格的高质量画面效果。&lt;/p&gt;
&lt;p&gt;这篇教程就希望通过在 Gallery 里绘制一个有丰富的光效、阴影的写实风格的三维地图的例子，简单介绍一些ECharts GL与画质相关的配置项，最终效果见 &lt;a href=&quot;http://gallery.echartsjs.com/editor.html?c=xBkY4tpszb&quot; class=&quot;uri&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gallery.echartsjs.com/editor.html?c=xBkY4tpszb&lt;/a&gt;（下图为最后的效果）。涉及到太高深专业的算法、代码、什么什么的小设计师我实在是不会，所以这个仅仅能当 GL 入门级教程使用哦～&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/blog/building-realistic-map-with-echarts-gl/banner.png&quot;&gt;
&lt;/div&gt;
    
    </summary>
    
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="GL" scheme="http://efe.baidu.com/tags/GL/"/>
    
      <category term="教程" scheme="http://efe.baidu.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ECharts v3.6 发布：自定义系列、极坐标柱状图</title>
    <link href="http://efe.baidu.com/blog/echarts-3-6-0/"/>
    <id>http://efe.baidu.com/blog/echarts-3-6-0/</id>
    <published>2017-05-24T16:00:00.000Z</published>
    <updated>2019-01-08T08:12:47.076Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECharts 新发布的 <a href="https://github.com/ecomfe/echarts/releases/tag/3.6.0" target="_blank" rel="noopener">3.6 版本</a>中，新增了 <a href="http://echarts.baidu.com/option.html#series-custom" target="_blank" rel="noopener">自定义系列（custom series）</a>，能让用户定制渲染逻辑，从而在已有坐标系中创造新的图表。此外还有极坐标柱状图、自定义维度映射、dataZoom 等其他一些增强。</p><p><img src="/blog/echarts-3-6-0/banner.png" width="100%"></p><a id="more"></a><h2 id="自定义系列">自定义系列</h2><p>图表的类型多种多样，有些大众有些小众，echarts 难于内置得支持所有类型的图表。所以推出了 <a href="http://echarts.baidu.com/option.html#series-custom" target="_blank" rel="noopener">自定义系列（custom series）</a>。</p><p>自定义系列可以自定义系列中的图形元素渲染。从而能扩展出不同的图表。同时，echarts 会统一管理图形的创建删除、动画、与其他组件（如 <a href="http://echarts.baidu.com/option.html#dataZoom" target="_blank" rel="noopener">dataZoom</a>、<a href="http://echarts.baidu.com/option.html#visualMap" target="_blank" rel="noopener">visualMap</a>）的联动，使用户不必纠结这些细节。</p><strong>例如，下面的例子使用 custom series 扩展出了 x-range 图：</strong><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-profile.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-profile&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><p>可以注意到，里面须用户自定义的渲染逻辑，在 <code>renderItem</code> 这个函数中，并不十分复杂。但是得到的功能是比较完备的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    ...,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'custom'</span>,</span><br><span class="line">        renderItem: <span class="function"><span class="keyword">function</span> (<span class="params">params, api</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> categoryIndex = api.value(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">var</span> start = api.coord([api.value(<span class="number">1</span>), categoryIndex]);</span><br><span class="line">            <span class="keyword">var</span> end = api.coord([api.value(<span class="number">2</span>), categoryIndex]);</span><br><span class="line">            <span class="keyword">var</span> height = api.size([<span class="number">0</span>, <span class="number">1</span>])[<span class="number">1</span>] * <span class="number">0.6</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                type: <span class="string">'rect'</span>,</span><br><span class="line">                shape: echarts.graphic.clipRectByRect(&#123;</span><br><span class="line">                    x: start[<span class="number">0</span>],</span><br><span class="line">                    y: start[<span class="number">1</span>] - height / <span class="number">2</span>,</span><br><span class="line">                    width: end[<span class="number">0</span>] - start[<span class="number">0</span>],</span><br><span class="line">                    height: height</span><br><span class="line">                &#125;, &#123;</span><br><span class="line">                    x: params.coordSys.x,</span><br><span class="line">                    y: params.coordSys.y,</span><br><span class="line">                    width: params.coordSys.width,</span><br><span class="line">                    height: params.coordSys.height</span><br><span class="line">                &#125;),</span><br><span class="line">                style: api.style()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        data: data</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>下面的两个例子使用 custom series 扩展出了 error-chart 图：</strong><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-error-bar.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-error-bar&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-error-scatter.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-error-scatter&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div><p><strong>下面是其他一些例子：</strong></p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-bar-trend.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-bar-trend&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-profit.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-profit&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/custom-hexbin.png" data-src="http://echarts.baidu.com/gallery/view.html?c=custom-hexbin&amp;edit=1&amp;reset=1" style="width: 100%; height: 500px"></div><h2 id="极坐标柱状图">极坐标柱状图</h2><p>极坐标中的柱状图，可以按径向排布或者切向排布。</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bar-polar-stack.png" data-src="http://echarts.baidu.com/gallery/view.html?c=bar-polar-stack&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bar-polar-stack-radial.png" data-src="http://echarts.baidu.com/gallery/view.html?c=bar-polar-stack-radial&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><p>使用时，只需要将系列的 <code>coordinateSystem</code> 设置为 <code>'polar'</code>，将原先笛卡尔坐标系中使用的 <code>xAxis</code> 和 <code>yAxis</code> 替换成 <code>radiusAxis</code> 和 <code>angleAxis</code>，就能使用极坐标系的柱状图了。</p><h2 id="其他">其他</h2><p>此外，</p><ul><li>支持了<a href="http://echarts.baidu.com/option.html#series-scatter.encode" target="_blank" rel="noopener">encode</a> 设定，可以指定 <a href="http://echarts.baidu.com/option.html#series-scatter.data" target="_blank" rel="noopener">data</a> 中哪些维度映射到坐标系中哪个轴，或者哪些维度在 <a href="http://echarts.baidu.com/option.html#tooltip" target="_blank" rel="noopener">tooltip</a> 以及 <a href="http://echarts.baidu.com/option.html#series-scatter.label" target="_blank" rel="noopener">label</a> 中显示。</li><li>支持了 <a href="http://echarts.baidu.com/option.html#series-scatter.dimensions" target="_blank" rel="noopener">dimensions</a> 设定，能指定 <a href="http://echarts.baidu.com/option.html#series-scatter.data" target="_blank" rel="noopener">data</a> 中每个维度的名称和类型。名称可以显示在默认 <a href="http://echarts.baidu.com/option.html#tooltip" target="_blank" rel="noopener">tooltip</a> 中。</li><li><code>dataZoom</code> 组件进行了增强。比如，支持了『按住 <code>'ctrl'</code>/<code>'alt'</code>/<code>'shift'</code> 和滚轮时才能出发缩放平移』功能，避免和页面的滚动冲突（参见 <a href="http://echarts.baidu.com/option.html#dataZoom-inside.moveOnMouseMove" target="_blank" rel="noopener">moveOnMouseMove</a> 和 <a href="http://echarts.baidu.com/option.html#dataZoom-inside.zoomOnMouseWheel" target="_blank" rel="noopener">zoomOnMouseWheel</a>。另外支持了 <a href="http://echarts.baidu.com/option.html#dataZoom.minSpan" target="_blank" rel="noopener">minSpan</a> 和 <a href="http://echarts.baidu.com/option.html#dataZoom.maxSpan" target="_blank" rel="noopener">maxSpan</a> 等细节配置。</li></ul><p>更多的升级信息，参见 <a href="http://echarts.baidu.com/changelog.html" target="_blank" rel="noopener">changelog</a>。</p><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script>(function () {    if (typeof jQuery === 'undefined') {        return;    }    var $ = jQuery;    var env = window['MD_ENV'];    var $ = jQuery;    var useThumb = env && (env.os.phone || env.os.tablet);    var blockList = $('.ec-lazy');    var $win = $(window);    blockList.each(function (index, block) {        block = $(block);        var src = block.attr('data-src');        block.attr('data-src', src);    });    // Lazy load.    $win.on('scroll', showBlock);    $(showBlock);    function initThumb(block, $block, blockThumb, blockSrc) {        $block.css('lineHeight', $block.height() + 'px');        block.innerHTML = [            '<img style="width:100%;height:auto;margin:0;padding:0;vertical-align:middle;" src="', blockThumb, '"/>',            // for vertial middle            '<div style="vertical-align: middle; height: 100%; width: 0"></div>',            '<div style="cursor:pointer;thumb-btn;position:absolute;bottom:10px;width:100%;height:22px;line-height:22px;text-align:center;">',                '<em style="font-style:normal;border-radius:3px;padding:3px 5px;margin:3px 5px;color:white;background:#337ab7;font-size:12px;line-height:1.5;">点击图片加载真实图表</em>',            '</div>',            '<div class="ec-lazy-block-mask" style="cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;margin:0;"></div>'        ].join('');        $block.find('.ec-lazy-block-mask').on('click', function () {            initIFrame(block, $block, blockThumb, blockSrc);        });    }    function initIFrame(block, $block, blockThumb, blockSrc) {        block.innerHTML = [            '<iframe style="overflow:hidden;width:100%;height:100%;margin:0;padding:0;" src="' , blockSrc, '">',            'frameborder="no" border="0" marginwidth="0" marginheight="0"',            'scrolling="no" hspace="0" vspace="0"></iframe>'        ].join('');    }    function showBlock() {        blockList.each(function (idx, block) {            var $block = $(block);            var blockSrc = $block.attr('data-src');            var blockThumb = $block.attr('data-thumb');            if (!blockSrc) {                return;            }            $block.css({                position: 'relative',                overflow: 'hidden',                textAlign: 'center',                padding: 0            });            var winScrollTop = $win.scrollTop();            var blockTop = block.offsetTop;            var winHeight = $win.height();            var winBottom = winScrollTop + winHeight;            var blockBottom = blockTop + $block.height();            if (winBottom >= blockTop && winBottom <= (blockBottom + winHeight)) {                $block.attr('data-src', '');                (useThumb && blockThumb)                    ? initThumb(block, $block, blockThumb, blockSrc)                    : initIFrame(block, $block, blockThumb, blockSrc);            }        });    }})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECharts 新发布的 &lt;a href=&quot;https://github.com/ecomfe/echarts/releases/tag/3.6.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.6 版本&lt;/a&gt;中，新增了 &lt;a href=&quot;http://echarts.baidu.com/option.html#series-custom&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义系列（custom series）&lt;/a&gt;，能让用户定制渲染逻辑，从而在已有坐标系中创造新的图表。此外还有极坐标柱状图、自定义维度映射、dataZoom 等其他一些增强。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-3-6-0/banner.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>ECharts 统计扩展教程</title>
    <link href="http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/"/>
    <id>http://efe.baidu.com/blog/echarts-statistical-extension-tutorial/</id>
    <published>2017-05-08T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>你是否想了解一组样本数据的分布情况？你是否想根据用户的数值属性将用户分成不同的群体？你是否想预测两个变量的变化趋势？—— 什么？不需要？不要再违心了，小编已经听到来自你们内心深处的呐喊，今天就为大家推荐一款神器 —— <a href="https://github.com/ecomfe/echarts-stat/" target="_blank" rel="noopener">ECharts 统计扩展</a>，这是一个用来进行数据分析的扩展工具，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 <a href="http://echarts.baidu.com/" target="_blank" rel="noopener">ECharts</a> 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。下面我们就一起来学习一下这些功能。</p><p><img src="/blog/echarts-statistical-extension-tutorial/echarts-statistical-logarithmic-regression.png" width="100%"></p><a id="more"></a><h2 id="首先引入-javascript-文件">首先引入 JavaScript 文件</h2><p>如果大家不仅要对数据进行分析，还要将分析的结果呈现出来，那就需要在下载引入扩展文件的同时，下载引入 ECharts 文件。如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ecStat.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//具体可视分析的代码</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除此之外，还需要指定一个具有高度和宽度的 DOM 元素，作为图表的容器，用来放置将被绘制的图表。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">style</span>=<span class="string">"width=100%; height=100%"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后传入该 DOM 元素，初始化 ECharts 图表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'main'</span>));</span><br></pre></td></tr></table></figure><p>完成了上面的准备工作，下面将一一介绍统计扩展的功能。</p><h2 id="直方图">直方图</h2><p>直方图主要用来反映一组样本数据的分布情况，可以近似估计一个数值类变量的概率分布。直方图是一种特殊的柱状图，它的任意两个 bar 之间不允许有间隙，这是因为整个数轴范围被分割成了一个个连续的、相互邻接的小区间。这个分割过程就是由统计扩展做的，用户只需要传入一维的数据，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> girth = [<span class="number">8.3</span>, <span class="number">8.6</span>, <span class="number">8.8</span>, <span class="number">10.5</span>, <span class="number">10.7</span>, <span class="number">10.8</span>, <span class="number">11.0</span>, <span class="number">11.0</span>, <span class="number">11.1</span>, <span class="number">11.2</span>, <span class="number">11.3</span>, <span class="number">11.4</span>, <span class="number">11.4</span>, <span class="number">11.7</span>, <span class="number">12.0</span>, <span class="number">12.9</span>, <span class="number">12.9</span>, <span class="number">13.3</span>, <span class="number">13.7</span>, <span class="number">13.8</span>, <span class="number">14.0</span>, <span class="number">14.2</span>, <span class="number">14.5</span>, <span class="number">16.0</span>, <span class="number">16.3</span>, <span class="number">17.3</span>, <span class="number">17.5</span>, <span class="number">17.9</span>, <span class="number">18.0</span>, <span class="number">18.0</span>, <span class="number">20.6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bins = ecStat.histogram(girth, <span class="string">'scott'</span>);</span><br></pre></td></tr></table></figure><p>这里的第二个参数 <code>'scott'</code> 是用来指定切割 bin 的方法，有四个选项，分别是 <code>'squareRoot'</code> 、 <code>'scott'</code> 、 <code>'freedmanDiaconis'</code> 、 <code>'sturges'</code> ，其中 <code>'squareRoot'</code> 是默认的计算方法，也是Excel中直方图使用的计算 bin 的方法 ，有关这四种计算方法的详细介绍，请参见 <a href="https://en.wikipedia.org/wiki/Histogram#Mathematical_definition" target="_blank" rel="noopener">wikipedia</a>。使用处理后的 <code>bins.data</code> 配置 ECharts 柱状图中的 <code>option.data</code> 就可以得到如下的直方图。由于篇幅的问题，这里就不再赘述具体的 <code>option</code> 配置，感兴趣的读者可以点击下方的 <code>代码</code> 按钮，进入 ECharts Gallery 中查看。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xBk5VZddJW&amp;v=4"></iframe><h2 id="聚类分析">聚类分析</h2><p>聚类分析用于将原数据集聚合成多个特性不同的数据簇，每个数据簇内的数据对象具有某些相似的特征。通过 ECharts 不仅可以可视化聚类的结果，还可以可视化聚类的过程。具体的使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = ecStat.clustering.hierarchicalKMeans(data, clusterNumber, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其中 <code>data</code> 是用户传入的二维数值数组， <code>clusterNumber</code> 是由用户设定的数据簇的个数，最后一个 <code>boolean</code> 类型的变量是用来指定，静态地可视化聚类的结果，还是动态地可视化聚类的过程。若值为 <code>false</code> 则为前者，反之，则为后者。</p><p>静态可视化聚类的结果：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xSkBOEaGtx&amp;v=10"></iframe><p>动态可视化聚类的过程：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xHyr-esMtg&amp;v=4"></iframe><p>同样，感兴趣的读者可以点击上方实例的 <code>代码</code> 按钮，进入 ECharts Gallery 中查看具体的代码，以及 <code>option</code> 的配置。</p><h2 id="回归分析">回归分析</h2><p>回归分析就是根据数据集中自变量和因变量的值，拟合出一条曲线，反映它们的变化趋势。在统计扩展中我们实现了四种回归算法，分别是线性回归、指数回归、对数回归、以及多项式回归。使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myRegression = ecStat.regression(regressionType, data, order);</span><br></pre></td></tr></table></figure><p>其中，<code>regressionType</code> 指的是回归类型，有四种取值，分别是 <code>'linear'</code> 、<code>'exponential'</code> 、<code>'logarithmic'</code> 、<code>'polynomial'</code> 。<code>data</code> 是用户传入的二维数值数组，分别是自变量和因变量的样本值。最后一个参数 <code>order</code> 用于多项式回归，用来指定多项式的阶数。</p><p>线性回归：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xS1bQ2AMKe&amp;v=6"></iframe><p>指数回归：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xHyaNv0fFe&amp;v=5"></iframe><p>对数回归：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xry3aWkmYe&amp;v=4"></iframe><p>多项式回归：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=xB16yW0MFl&amp;v=3"></iframe><h2 id="常用汇总统计">常用汇总统计</h2><p>除了上面提到的数据分析方法之外，统计扩展还包括了常用的汇总统计，如分位数、样本方差、标准差、中位数、平均数、求和、最大值、最小值等。具体的用法，这里就不在展开了，详情请参见 GitHub 上的<a href="https://github.com/ecomfe/echarts-stat#statistics" target="_blank" rel="noopener">详细文档</a>。</p><p>最后的最后，提醒大家一句，在参照完 <code>Gallery</code> 上 <code>option</code> 的设置之后，一定要记得 <code>setOption</code> ，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chart.setOption(option);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你是否想了解一组样本数据的分布情况？你是否想根据用户的数值属性将用户分成不同的群体？你是否想预测两个变量的变化趋势？—— 什么？不需要？不要再违心了，小编已经听到来自你们内心深处的呐喊，今天就为大家推荐一款神器 —— &lt;a href=&quot;https://github.com/ecomfe/echarts-stat/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts 统计扩展&lt;/a&gt;，这是一个用来进行数据分析的扩展工具，包含的功能有直方图、聚类、回归、以及常用的汇总统计。通过统计扩展和 &lt;a href=&quot;http://echarts.baidu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts&lt;/a&gt; 的结合，可以使大家方便地实现可视分析，也就是将数据分析的结果，通过可视化直观地呈现出来。下面我们就一起来学习一下这些功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-statistical-extension-tutorial/echarts-statistical-logarithmic-regression.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
  </entry>
  
  <entry>
    <title>那些年我们一起学过的直方图</title>
    <link href="http://efe.baidu.com/blog/echarts-histogram-tutorial/"/>
    <id>http://efe.baidu.com/blog/echarts-histogram-tutorial/</id>
    <published>2017-05-07T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>某天下午小编正在安安静静地撸代码，突然听说在我们的 <a href="http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all" target="_blank" rel="noopener">gallery</a> 上，有用户提出，<a href="http://echarts.baidu.com/index.html" target="_blank" rel="noopener">ECharts</a> 不支持直方图，什么？这怎么能忍？于是小编将珍藏已久的机械键盘拿出来，摆好姿势，通宵达旦地为用户大大们加好了直方图，并于上周四悄悄上线了，对，我们就是这么低调。然而，很多大大们表示，直方图还是柱状图？傻傻分不清。小编深感这年头光有图怕是不行了，必须得有个教程，要做到图文并茂。下面小编就从直方图是什么，为什么要用直方图，以及如何使用 <a href="http://echarts.baidu.com/index.html" target="_blank" rel="noopener">ECharts</a> 制作直方图三个方面，为各位大大们上点干货。</p><a id="more"></a><h2 id="直方图是什么">直方图是什么</h2><p>直方图主要用来反映一组样本数据的分布情况。从图的形式来看，它属于柱状图的一种，但它和柱状图相比还是有很多不同之处的。首先，直方图的任意两个 bar 之间不允许有间隙，这是因为原始样本值被分割成一系列连续的、相互邻接的小区间，每一个小区间都是左闭右开的，除了最后一个，如<code>[x0, x1), [x1,x2), [x2,x3]</code>，在直方图中小区间又被称为“bin”。其中bin的高度是由落入该区间中样本值的个数决定的；其次，在 ECharts 中绘制双数值轴（这里的双数值轴指的是 x 轴和 y 轴都是数值类型的）柱状图，用户需要传入二维的数组，如<code>array1 = [[1, 2], [3, 4]]</code>，而绘制直方图，用户只需要传入一维的数组，如<code>array2 = [1, 2, 3, 4]</code>，然后由<a href="https://github.com/ecomfe/echarts-stat" target="_blank" rel="noopener">ECharts 统计扩展</a>将一维的样本值分割成一个个具体的bin，并计算输出每一个bin的绘制信息，然后选用 ECharts 柱状图绘制具体的直方图。</p><h2 id="为什么要用直方图">为什么要用直方图</h2><p>前面已经提到了，直方图主要用来反映样本数据的分布，如下图，这是使用著名的<a href="https://en.wikipedia.org/wiki/Iris_flower_data_set" target="_blank" rel="noopener">虹膜花数据集</a>中的花瓣长度这一维度所作的直方图。从图中可以直观地看出该维度样本数据不符合正态分布，有多个峰值，具有明显的差异。这说明不同种类虹膜花的花瓣长度，受多个因素的影响，同时也表明在进一步的数据分析中，所有基于正态分布假设的分析，都不适合该维度数据。</p><div class="figure"><img src="/blog/echarts-histogram-tutorial/echarts-histogram-petal-length-iris.png" alt="petal-width"><p class="caption">petal-width</p></div><p>除此之外，直方图还可以用来进行数据审查。所谓的数据审查，是指在数据预处理之前，通过直方图直观地审视样本数据中的每个维度，检查是否有异常值的同时，了解值的分布。如图，这是记录 31 颗黑樱桃树周长的样本数据，从图中可以明显地看出有三个异常值，因为树的周长肯定大于 0 ，不会出现小于 0 的负数，而<code>[-5, 0)</code>这个区间内有三个样本值，这就需要通过数据清洗将异常值过滤掉。</p><div class="figure"><img src="/blog/echarts-histogram-tutorial/echarts-histogram-girth-of-tree.png" alt="girth-tree"><p class="caption">girth-tree</p></div><h2 id="如何使用-echarts制作直方图">如何使用 <a href="http://echarts.baidu.com/index.html" target="_blank" rel="noopener">ECharts</a>制作直方图</h2><p>ECharts 是一个强大的可视化图表库，并不是一个统计分析的工具，所以我们将处理原始数据并分割成一个个具体的bin这一部分放在了 ECharts 的<a href="https://github.com/ecomfe/echarts-stat" target="_blank" rel="noopener">统计扩展</a>中实现。这就需要我们在引入 <code>echarts.js</code> 的同时，引入统计扩展对应的 <code>ecStat.js</code>，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ecStat.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> height = [<span class="number">70</span>, <span class="number">65</span>, <span class="number">63</span>, <span class="number">72</span>, <span class="number">81</span>, <span class="number">83</span>, <span class="number">66</span>, <span class="number">75</span>, <span class="number">80</span>, <span class="number">75</span>, <span class="number">79</span>, <span class="number">76</span>, <span class="number">76</span>, <span class="number">69</span>, <span class="number">75</span>, <span class="number">74</span>, <span class="number">85</span>, <span class="number">86</span>, <span class="number">71</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">80</span>, <span class="number">74</span>, <span class="number">72</span>, <span class="number">77</span>, <span class="number">81</span>, <span class="number">82</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">87</span>];</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> bins = ecStat.histogram(height);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用统计扩展处理过后的数据，配置 ECharts 柱状图中的 option，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    color: [<span class="string">'rgb(25, 183, 207)'</span>],</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: <span class="string">'3%'</span>,</span><br><span class="line">        right: <span class="string">'3%'</span>,</span><br><span class="line">        bottom: <span class="string">'3%'</span>,</span><br><span class="line">        containLabel: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: [&#123;</span><br><span class="line">        type: <span class="string">'value'</span>,</span><br><span class="line">        <span class="comment">//这个一定要设，不然barWidth和bins对应不上</span></span><br><span class="line">        scale: <span class="literal">true</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    yAxis: [&#123;</span><br><span class="line">        type: <span class="string">'value'</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'bar'</span>,</span><br><span class="line">        barWidth: <span class="string">'99.3%'</span>,</span><br><span class="line">        label: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                show: <span class="literal">true</span>,</span><br><span class="line">                position: <span class="string">'insideTop'</span>,</span><br><span class="line">                formatter: <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> params.value[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        data: bins.data</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就得到了如下的直方图：</p><div class="figure"><img src="/blog/echarts-histogram-tutorial/echarts-histogram-height-of-tree.png" alt="height-tree"><p class="caption">height-tree</p></div><p>这里不得不说的是，由于历史遗留的问题，ECharts 中的柱状图并不能完美地支持直方图的绘制，所以不得不使用一些小的 trick，如设置 <code>xAxis</code> 的 <code>scale</code> 为 <code>true</code>，调整 <code>barWidth</code> 的值等。不过，大家不用担心，作为一个良心以及正义感爆棚的团队，我们即将发布一款新的自定义图表类型。经小编亲测，该图表类型可以画出狂拽酷炫屌炸天的直方图，敬请期待哦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某天下午小编正在安安静静地撸代码，突然听说在我们的 &lt;a href=&quot;http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gallery&lt;/a&gt; 上，有用户提出，&lt;a href=&quot;http://echarts.baidu.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts&lt;/a&gt; 不支持直方图，什么？这怎么能忍？于是小编将珍藏已久的机械键盘拿出来，摆好姿势，通宵达旦地为用户大大们加好了直方图，并于上周四悄悄上线了，对，我们就是这么低调。然而，很多大大们表示，直方图还是柱状图？傻傻分不清。小编深感这年头光有图怕是不行了，必须得有个教程，要做到图文并茂。下面小编就从直方图是什么，为什么要用直方图，以及如何使用 &lt;a href=&quot;http://echarts.baidu.com/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts&lt;/a&gt; 制作直方图三个方面，为各位大大们上点干货。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="教程" scheme="http://efe.baidu.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="直方图" scheme="http://efe.baidu.com/tags/%E7%9B%B4%E6%96%B9%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Vitual DOM 的内部工作原理</title>
    <link href="http://efe.baidu.com/blog/the-inner-workings-of-virtual-dom/"/>
    <id>http://efe.baidu.com/blog/the-inner-workings-of-virtual-dom/</id>
    <published>2017-04-13T16:00:00.000Z</published>
    <updated>2017-04-17T06:08:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://medium.com/@rajaraodv/the-inner-workings-of-virtual-dom-666ee7ad47cf" target="_blank" rel="noopener">The Inner Workings Of Virtual DOM</a></p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/1.png" alt="Preact VDOM 工作流程图"><p class="caption">Preact VDOM 工作流程图</p></div><p>虚拟DOM (VDOM，也称为 VNode) 是非常神奇的，同时也是复杂难懂的。 <a href="https://facebook.github.io/react/" target="_blank" rel="noopener">React</a>，<a href="https://preactjs.com/" target="_blank" rel="noopener">Preact</a> 以及其他类似的 JS 库都使用了虚拟 DOM 技术作为内核。可惜我找不到任何靠谱的文章或者文档可以简单又清楚解释清虚拟DOM的内部细节。所以，我就想到自己动手写一篇。</p><blockquote><p>注：这是一篇很长的博客。为了让内容更容易理解，我添加了很多图片。这也导致这篇博客看上去更长了。</p></blockquote><blockquote><p>在这篇博客中，我是基于 <a href="https://github.com/developit/preact/" target="_blank" rel="noopener">Preact</a> 的代码和 VDOM 机制来介绍的。因为 Preact 代码量更少，你在以后也可以不费力地自己看看源码。<strong>但是我觉得绝大部分的概念也同样适用于 React。</strong></p></blockquote><blockquote><p>我希望读者通过这篇博客可以更好地理解虚拟DOM，并期待你们可以为 React 和 Preact 等开源项目提供贡献。</p></blockquote><p>在这篇博客中，我会通过一个简单的例子来仔细地介绍虚拟DOM的每个场景，给大家虚拟DOM是如何工作的。特别地，我会介绍以下内容：</p><ol style="list-style-type: decimal"><li>Babel 和 JSX</li><li>创建 VNode -- 单个虚拟 DOM 元素</li><li>处理组件和子组件</li><li>初始渲染和创建 DOM 元素</li><li>再次渲染</li><li>删除 DOM 元素</li><li>替换 DOM 元素</li></ol><a id="more"></a><h2 id="演示程序">演示程序</h2><p>演示程序是一个简单的<a href="http://codepen.io/rajaraodv/pen/BQxmjj" target="_blank" rel="noopener">可筛选的搜索程序</a>，包含了两个组件 <strong>FilteredList</strong> 和 <strong>List</strong>。List 组件会渲染一个城市列表（默认情况是 California 和 New York）。示例还有一个搜索框，可以根据搜索框的输入内容来筛选列表。十分直接了当。</p><blockquote><p>在线示例： <a href="http://codepen.io/rajaraodv/pen/BQxmjj" class="uri" target="_blank" rel="noopener">http://codepen.io/rajaraodv/pen/BQxmjj</a></p></blockquote><h2 id="概览">概览</h2><p>首先，我们用 JSX（html in js）来编写组件。我们会使用 <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> 将组件转译成纯 JS 。接着 Preact 的 <strong>『h』</strong> <a href="https://github.com/dominictarr/hyperscript" target="_blank" rel="noopener">hyperscript</a> 函数会将组件再转化成 VDOM 树（也就是 VNode）。最终， Preact 的虚拟 DOM 算法，按照 VDOM 生成真实的 DOM 元素，完成我们的应用。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/the-big-picture.png" alt="概览"><p class="caption">概览</p></div><p>在我们深入 VDOM 生命周期的细节之前，先来理解一下 JSX；它提供了整个框架的起点。</p><h3 id="babel-和-jsx">1. Babel 和 JSX</h3><p>在 React、Preact 以及类似的框架中，并没有 HTML；取而代之，<strong>所有都是 JS</strong>。所以我们甚至需要在 JavaScript 中来编写 HTML。但是，只用纯 JS 来写 DOM 简直就是恶梦！</p><p>拿我们的演示程序来说，我们必须这样写 HTML：</p><blockquote><p>我一会儿来再解释 『h』</p></blockquote><p><img src="/blog/the-inner-workings-of-virtual-dom/pure-js-filtered-list.png"> <img src="/blog/the-inner-workings-of-virtual-dom/pure-js-list.png"></p><p>这就是我们需要引入 JSX 的原因。本质上来说，JSX 就是让我们愉快地在 JS 中写 HTML！同时，也允许我们在花括号里 {} 使用 JS。</p><p>如下所示，JSX 可以帮助我们很容易地编写组件</p><p><img src="/blog/the-inner-workings-of-virtual-dom/jsx-filtered-list.png"> <img src="/blog/the-inner-workings-of-virtual-dom/jsx-list.png"></p><h3 id="jsx-树转化为-javascript">2. JSX 树转化为 JavaScript</h3><p>JSX 很酷，但是它不是可用的 JS，而最终我们需要真实的 DOM。JSX 只能帮助我们简洁地表达真实 DOM，没有办法再完成其他的事情。</p><p>所以我们需要一个方法来把 JSX 转化成对应的 JSON 对象（VDOM，同时它也是一棵树）。只有这样我们最终才能使用它作为输入来创建真实 DOM。我们需要一个函数来实现它。</p><p>在 Preact 中，这个函数就是 『<a href="https://github.com/developit/preact/blob/master/src/h.js" target="_blank" rel="noopener">h 函数</a>』。它与 React 中的 『<a href="https://facebook.github.io/react/docs/react-api.html#createelement" target="_blank" rel="noopener">React.createElement</a>』是等效的。</p><blockquote><p>『h』代表着 <a href="https://github.com/dominictarr/hyperscript" target="_blank" rel="noopener">hyperscript</a> —— 最先开始在 JS 中编写 HTML 的框架之一。</p></blockquote><p>但如何把 JSX 转化成 『h』函数呢？这就是引入 <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> 的原因了。Babel 会找到所有的 JSX 结点并把它们转化成『h』函数调用。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/convert-jsx-to-js.png" alt="babel-convert-jsx-to-js"><p class="caption">babel-convert-jsx-to-js</p></div><h3 id="babel-jsx-react-vs-preact">3. Babel JSX (React vs Preact)</h3><p>默认条件下，Babel 会把 JSX 转译成 React.createElement 调用，因为它默认就是支持的 React。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/babel-jsx-convert-example.png" alt="左边是 JSX，右边是转译成 React 版的 JS"><p class="caption">左边是 JSX，右边是转译成 React 版的 JS</p></div><p>但我们可以通过添加『Babel Pragma』参数，很容易地把这个函数名换成任何我们想要的，比如 Preact 使用的 『h』：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Option <span class="number">1</span>:</span><br><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"transform-react-jsx"</span>, &#123;<span class="string">"pragma"</span>: <span class="string">"h"</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Option <span class="number">2</span>:</span><br><span class="line"><span class="comment">// 在每个 JSX 文件的第一行添加这一行注释</span></span><br><span class="line"><span class="comment">/** @jsx h*/</span></span><br></pre></td></tr></table></figure><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/babel-jsx-convert-example-h.png" alt="使用 Babel Pragma 来指定 h 函数"><p class="caption">使用 Babel Pragma 来指定 h 函数</p></div><h3 id="挂载到真实-dom-的主入口">4. 挂载到真实 DOM 的主入口</h3><p>不仅是在组件的『render』函数中的代码需要被转译成『h』函数，初始的挂载入口也需要。</p><p><strong>这就是开始执行的位置，一切的开始！</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount to real DOM</span></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">FilteredList</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(‘app’));</span><br><span class="line"><span class="comment">// Converted to "h":</span></span><br><span class="line">render(h(FilteredList), <span class="built_in">document</span>.getElementById(‘app’));</span><br></pre></td></tr></table></figure><h3 id="h函数的返回值">5.『h』函数的返回值</h3><p>『h』函数使用 JSX 的返回值作为参数，创建了一个叫『VNode』的东西（React 的『createElement』创建 ReactElement）。一个 Preact 的『VNode』（或者是 React 的 『Element』）只是一个 JS 对象，代表着一个 DOM 结点，其中包含了它的属性和子结点。</p><p>VNode 大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    nodeName: <span class="string">''</span>,</span><br><span class="line">    attributes: &#123;&#125;,</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子，我的演示程序中搜索框 Input 的 VNode 应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    nodeName: <span class="string">'input'</span>,</span><br><span class="line">    attributes: &#123;</span><br><span class="line">        type: <span class="string">'text'</span>,</span><br><span class="line">        placeholder: <span class="string">'Search'</span>,</span><br><span class="line">        onChange: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>『h』函数不会创建整个树！它只会为指定的结点创建一个 JS 对象。但由于『render』方法已经得到了树结构的 DOM JSX，最终产出的结果就会是一个带有子结点、孙结点的 VNode，看上去就是一棵树。</p></blockquote><blockquote><p><strong>相关的代码</strong></p><p>『h』: <a href="https://github.com/developit/preact/blob/master/src/h.js" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/h.js</a></p><p>『VNode』: <a href="https://github.com/developit/preact/blob/master/src/vnode.js" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vnode.js</a></p><p>『render』: <a href="https://github.com/developit/preact/blob/master/src/render.js" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/render.js</a></p><p>『buildComponentFromVNode』: <a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102</a></p></blockquote><h2 id="preact-的虚拟-dom-算法流程图">Preact 的虚拟 DOM 算法流程图</h2><p>下面的流程图中展示了 Preact 是如何创建、更新、删除组件以及其子组件的。同时它也展示了诸如 <code>componentWillMount</code> 等生命周期事件是何时被调用的。</p><blockquote><p>注：这个图看上去很复杂，不要担心，我们会逐个分章节一步一步地详细介绍。</p></blockquote><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart.png"></div><p>是的，很难一次全部读懂它。所以让我们把它分解成多个章节，一步一步来介绍。</p><blockquote><p>注：当我们讨论生命周期中的某部分时，我会在图中用黄色高亮区域把它们标注出来。</p></blockquote><h3 id="场景1应用程序的创建">场景1：应用程序的创建</h3><h4 id="为给定的组件创建-vnode-virtual-dom">1.1 为给定的组件创建 VNode (Virtual DOM)</h4><p>图中的高亮区域展示了创建组件 VNode(Vitual DOM) 树的循环。注意这里没有创建子组件的 VNode，那是另外一个循环。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-initial-create.png" alt="黄色高亮的部分展示了 VNode 的创建过程"><p class="caption">黄色高亮的部分展示了 VNode 的创建过程</p></div><p>下面这张图展示了我们的应用首次加载时发生了什么。框架完成时得到了 <code>FilteredList</code> 组件的一个带有子结点和属性的 VNode。</p><blockquote><p>注：在这个过程中，<code>componentWillMount</code> 和 <code>render</code> 这两个生命周期方法被调用了（注意上图中的绿色框体）。</p></blockquote><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/initial-create.png"></div><blockquote><p>相关代码</p><p>绝大部分的生命周期事件，诸如：componentWillMount，render 都可以在这里找到：<a href="https://github.com/developit/preact/blob/master/src/vdom/component.js#L101" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/component.js#L101</a></p></blockquote><h4 id="如果不是组件那么创建一个真实-dom">1.2 如果不是组件，那么创建一个真实 DOM</h4><p>在这一步中，我们会为父结点（div）创建真实的 DOM 元素，并且遍历处理子结点（<code>input</code> 和 <code>List</code>）。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-not-a-component.png" alt="高亮的部分展现了为子组件创建真实 DOM 的处理过程"><p class="caption">高亮的部分展现了为子组件创建真实 DOM 的处理过程</p></div><p>如下图所示，现在我们就得到了 <code>div</code>：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/create-a-real-dom.png"></div><blockquote><p>相关代码</p><p>document.createElement: <a href="https://github.com/developit/preact/blob/master/src/dom/recycler.js" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/dom/recycler.js</a></p></blockquote><h4 id="重复子结点">1.3 重复子结点</h4><p>现在，这个循环是对每个子结点重复以上动作。在我们的应用中，我们将会重复 <code>input</code> 和 <code>List</code>。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-repeat-for-children.png" alt="重复处理每个子结点"><p class="caption">重复处理每个子结点</p></div><h4 id="处理子结点并添加将其添加到父结点">1.4 处理子结点并添加将其添加到父结点</h4><p>在这一步中，我们会处理叶子结点。由于 <code>input</code> 拥有父结点 <code>div</code>，我们就把 input 作为子结点添加到 <code>div</code> 中。接着 <code>input</code> 的处理流程结束，继续处理 <code>List</code>（ <code>div</code>的第二个子结点）。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-append-to-parent.png" alt="完成对子结点的处理"><p class="caption">完成对子结点的处理</p></div><p>此时，我们的应用是这样的：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/append-to-parent.png"></div><blockquote><p>注意：在创建 <code>input</code> 之后，由于它没有任何子结点，因此对它的处理结束。但这里并不是立即继续循环并创建 <code>List</code>。而是先将 <code>input</code> 添加到父结点 <code>div</code>，而后再返回处理 <code>List</code>。</p><p>相关代码：</p><p>appendChild: <a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js</a></p></blockquote><h4 id="处理子组件">1.5 处理子组件</h4><p>控制流程返回到步骤 1.1，对 <code>List</code> 组件开始新的一轮处理。由于 <code>List</code> 是一个组件，所以它也会调用 <code>List</code> 的 <strong>render</strong> 方法来获取到新的 VNode，如下所示：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-process-child-component.png" alt="对每个子组件重复以上所有的处理"><p class="caption">对每个子组件重复以上所有的处理</p></div><p>当处理 <code>List</code> 组件的循环完成时，我们可以得到 List 的 VNode，如下所示：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/process-child-component.png" alt="process-child-component"><p class="caption">process-child-component</p></div><blockquote><p>相关代码：</p><p>buildComponentFormVNode: <a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L102</a></p></blockquote><h4 id="对所有子结点重复步骤-1.1-到-1.4">1.6 对所有子结点重复步骤 1.1 到 1.4</h4><p>现在再次对所有的子结点重复以上处理。一旦到达叶子结点时，就把它添加到父元素上并重复整个过程。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-repeat-for-all-children.png" alt="一直重复此流程，直到所有结点都被创建并添加到 DOM 树"><p class="caption">一直重复此流程，直到所有结点都被创建并添加到 DOM 树</p></div><p>下边个张图展示了每个子结点是如何被添加的（提示：深度优先）</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/how-real-dom-tree-created.png" alt="DOM 是如何被创建的"><p class="caption">DOM 是如何被创建的</p></div><h4 id="结束">1.7 结束</h4><p>此时，我们就完成了整个的处理过程。这里只需要地调用所有组件的 <code>componentDidMount</code> 方法（自子组件开始，至父组件结束），然后停止。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-stop-processing.png"></div><blockquote><p>重要提示：一旦所有的工作都完成时，我们会将真实 DOM 对象的引用添加到每个相应的组件实例上。这些引用将会帮助完成后续的操作（创建、更新、删除），对比并避免重复创建相同的 DOM 结点。</p></blockquote><h3 id="场景2删除叶子结点">场景2：删除叶子结点</h3><p>假设我们在 input 中输入 <code>cal</code> 然后回车。这将移除第二个列表结点，另一个叶子结点（New York）则到被保留下来。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/app-remove-leaf-node.png"></div><p>好，接下来让我们看一下这一场景的处理流程。</p><h4 id="以之前一样创建-vnode">2.1 以之前一样，创建 VNode</h4><p>在初始渲染之后的每个变化都称为一个 <code>更新(update)</code> 。对于 <code>更新</code> 周期中的创建 VNode 工作，与前边讲到 <code>创建</code> 周期中的非常类似，就是再来一次创建 VNode。</p><p>既然是更新（不是创建）一个组件，那么每个组件以及子组件的 <code>componentWillReceiveProps</code>，<code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code> 事件将会被触发。</p><p><strong>额外的，更新周期，不会再次创建 DOM 元素，因为它们已经存在了</strong></p><blockquote><p>译者注</p><p>如果 DOM 元素可复用就不会再次创建。不可复用的情况主要是指标签名发生变化。这种情况下，我们仍然会创建新的 DOM 元素，并且会把旧有的 DOM 回收掉。</p><p>例如从 div 变为 section，那么就会创建一个新的 section 元素，替换原有 div，而 div 会被回收；</p></blockquote><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/flowchart-2.1.png" alt="组件更新的处理流程"><p class="caption">组件更新的处理流程</p></div><blockquote><p>相关代码</p><p>removeNode: <a href="https://github.com/developit/preact/blob/master/src/dom/index.js#L9" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/dom/index.js#L9</a></p><p>insertBefore: <a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L253" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L253</a></p></blockquote><h4 id="使用真实-dom-结点引用-避免重复创建结点">2.2 使用真实 DOM 结点引用 &amp; 避免重复创建结点</h4><p>之前有提到过，在初始化过程中完成创建之后，每个组件都会有一个指向到对应的真实的 DOM 树结点的引用。下边的图片展示了我们演示 app 当前状态的引用关系。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/2.1-dom-refenerences.png" alt="DOM 与组件实例之间的引用关系"><p class="caption">DOM 与组件实例之间的引用关系</p></div><p>每当我们创建一个新 VNode 时，它的每个属性都会与对应结点的真实 DOM 属性做对比。如果真实 DOM 所有属性都与新的 VNode 一致，那么就会继续处理下一个结点。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/2.3-same-dom-vnode.png" alt="更新过程中 DOM 结点已经存在的处理流程"><p class="caption">更新过程中 DOM 结点已经存在的处理流程</p></div><blockquote><p>译者注</p><p>实际上，这里的逻辑并不是简单地把 VNode 与 DOM 的 <code>attributes</code> 作对比。</p><p>在 preact 中，每个 DOM 都有一个 <code>Symbol(__preactattr__)</code> 的属性，这里称之为<code>属性缓存</code>。这个属性的值就是我们的 VNode 的所有属性（不包含 children）。我们是用这个<code>属性缓存</code>与 VNode 作对比的。</p><p>具体的 diff 过程大概是这样的：</p><p>首先，我们会先在 DOM 上找 <code>Symbol(__preactattr__)</code> 的属性；如果这个属性不存在，那么我们会遍历 DOM 上所有的 <code>attributes</code> 来生成它。</p><p>接着，我们一一对比 <code>VNode</code> 和 <code>属性缓存</code> 的所有属性。如果两者完全一致，那么我们不会对 DOM 做任何更新操作；如果 VNode 与这个属性存在差异，我们则会更新 DOM 属性，并同时更新属性缓存。注意，这里 VNode 的属性对比完成时，也同时完成了对 DOM 的更新。</p><p>相关代码：</p><ol style="list-style-type: decimal"><li><p>生成缓存：<a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L143" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L143</a></p></li><li><p>使用属性缓存：<a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L139" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L139</a></p></li><li><p>对比属性缓存与 VNode 属性：<a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L305" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L305</a></p></li></ol></blockquote><h4 id="移除多余的-dom-结点">2.3 移除多余的 DOM 结点</h4><p>下边这张图展示了真实 DOM 与 VNode 之间的差异：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/2.3-deferences-between-dom-vnode.png" alt="VNode 与 DOM 间的差"><p class="caption">VNode 与 DOM 间的差</p></div><p>由于真实 DOM 比 VNode 多了一个 <code>New York</code> 结点，在下边的图中高亮的部分中我们会把它移除掉。同时，在所有过程完成之后，还会触发生命周期中的 <code>componentWillUnmount</code> 事件。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/2.3-flowchart.png" alt="Remove DOM node lifecycle"><p class="caption">Remove DOM node lifecycle</p></div><blockquote><p>相关代码</p><p>unmountComponent: <a href="https://github.com/developit/preact/blob/master/src/vdom/component.js#L250" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/component.js#L250</a></p></blockquote><h3 id="场景-3移除整个组件">场景 3：移除整个组件</h3><p>假设我们在筛选框中输入 <strong>blabla</strong>。那么 &quot;California&quot; 或者 &quot;New York&quot; 都匹配不上，所以我们根本不会去渲染子组件 &quot;List&quot;。这意味着，我们需要卸载整个组件。</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/3-demo.png" alt="如果没有结果，那么列表组件会被移除"><p class="caption">如果没有结果，那么列表组件会被移除</p></div><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/3-code.png" alt="FilteredList 的 “render” 的方法"><p class="caption">FilteredList 的 “render” 的方法</p></div><p>移除一个组件与移除一个结点类似。当我们移除一个有组件引用的 DOM 结点时，会触发组件的生命周期处理函数 &quot;componentWillUnmount&quot;，接着递归地删除所有的子孙 DOM 结点。所有的元素都被删除时，会触发引用组件的生命周期处理函数 &quot;componentDidUnmount&quot;。</p><p>下面这张图片展示了 DOM 结点与组件实例之间的引用关系：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/3-component-reference.png" alt="DOM 结点与组件实例之间的引用关系"><p class="caption">DOM 结点与组件实例之间的引用关系</p></div><p>下面的流程图中高亮的部分展示了移除/卸载组件的处理过程：</p><div class="figure"><img src="/blog/the-inner-workings-of-virtual-dom/3-remove-component.png" alt="移除并卸载组件"><p class="caption">移除并卸载组件</p></div><blockquote><p>相关代码</p><p>unmountComponent: <a href="https://github.com/developit/preact/blob/master/src/vdom/component.js#L250" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/component.js#L250</a></p></blockquote><h2 id="子结点-diff-算法">子结点 diff 算法</h2><blockquote><p>译者注：对于子结点的 diff 计算是 virtual dom 算法中至关重要的一个环节。但原文没有涉及到其中的细节，因此译者补充这一小节。</p></blockquote><p>在处理完 VNode 的自身属性后，会对子结点进行 diff 计算；为了提高这个计算的性能，我们在框架中强制要求每个子 VNode 都必须有一个属性 <code>key</code>，字符串类型，并且每个 <code>key</code> 互不相同。我们需要使用 key 来构建索引，加速子 VNode 的匹配过程。</p><p>子结点 diff 的过程大概是这样的：</p><ol style="list-style-type: decimal"><li><p>首先，先将当前子 VNode 按属性 key 为键、VNode 为值，构建成一个 Map；</p><p>这里就是为什么 <code>key</code> 一定要互不相同的原因。如果 key 有冲突，那么这个 Map 就无法构建了。</p></li><li>遍历所有新的子 VNode；<ol style="list-style-type: decimal"><li>使用新子 VNode 的 <code>key</code>，找到在 Map 中的当前子 VNode；</li><li><p>将两者做 diff；</p><p>实际上是递归整个 diff 算法。没找到对应 VNode 就是新增结点，找到了就是更新结点。</p></li><li><p>将此 VNode 的 <code>key</code> 从 Map 中移除；</p></li></ol></li><li><p>最后，把 Map 中剩余的 VNode 全部卸载。</p><p>这里是场景 2.3 和场景 3 中移除结点的触发点。</p></li></ol><blockquote><p>相关代码 innerDiffNode：<a href="https://github.com/developit/preact/blob/master/src/vdom/diff.js#L182" class="uri" target="_blank" rel="noopener">https://github.com/developit/preact/blob/master/src/vdom/diff.js#L182</a></p></blockquote><h2 id="最后">最后</h2><p>我希望这篇文章可以充分地让大家了解 Virtual DOM 是如何工作的，至少是 preact。</p><p>请注意我只提到了主要的一些场景，并没有涉及到代码中某些的优化处理。</p><p>同时，如果你发现了任何问题，请告诉我。我非常乐意更正！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://medium.com/@rajaraodv/the-inner-workings-of-virtual-dom-666ee7ad47cf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The Inner Workings Of Virtual DOM&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/blog/the-inner-workings-of-virtual-dom/1.png&quot; alt=&quot;Preact VDOM 工作流程图&quot;&gt;&lt;p class=&quot;caption&quot;&gt;Preact VDOM 工作流程图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;虚拟DOM (VDOM，也称为 VNode) 是非常神奇的，同时也是复杂难懂的。 &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React&lt;/a&gt;，&lt;a href=&quot;https://preactjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Preact&lt;/a&gt; 以及其他类似的 JS 库都使用了虚拟 DOM 技术作为内核。可惜我找不到任何靠谱的文章或者文档可以简单又清楚解释清虚拟DOM的内部细节。所以，我就想到自己动手写一篇。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：这是一篇很长的博客。为了让内容更容易理解，我添加了很多图片。这也导致这篇博客看上去更长了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;在这篇博客中，我是基于 &lt;a href=&quot;https://github.com/developit/preact/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Preact&lt;/a&gt; 的代码和 VDOM 机制来介绍的。因为 Preact 代码量更少，你在以后也可以不费力地自己看看源码。&lt;strong&gt;但是我觉得绝大部分的概念也同样适用于 React。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;我希望读者通过这篇博客可以更好地理解虚拟DOM，并期待你们可以为 React 和 Preact 等开源项目提供贡献。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这篇博客中，我会通过一个简单的例子来仔细地介绍虚拟DOM的每个场景，给大家虚拟DOM是如何工作的。特别地，我会介绍以下内容：&lt;/p&gt;
&lt;ol style=&quot;list-style-type: decimal&quot;&gt;
&lt;li&gt;Babel 和 JSX&lt;/li&gt;
&lt;li&gt;创建 VNode -- 单个虚拟 DOM 元素&lt;/li&gt;
&lt;li&gt;处理组件和子组件&lt;/li&gt;
&lt;li&gt;初始渲染和创建 DOM 元素&lt;/li&gt;
&lt;li&gt;再次渲染&lt;/li&gt;
&lt;li&gt;删除 DOM 元素&lt;/li&gt;
&lt;li&gt;替换 DOM 元素&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://efe.baidu.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://efe.baidu.com/tags/React/"/>
    
      <category term="VitualDOM" scheme="http://efe.baidu.com/tags/VitualDOM/"/>
    
      <category term="Preact" scheme="http://efe.baidu.com/tags/Preact/"/>
    
  </entry>
  
  <entry>
    <title>ECharts GL 1.0 alpha 发布</title>
    <link href="http://efe.baidu.com/blog/echarts-gl-alpha/"/>
    <id>http://efe.baidu.com/blog/echarts-gl-alpha/</id>
    <published>2017-04-11T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>距离 ECharts-X 最近一个版本已经过去了两年多时间，期间我们不断被开发者在各种渠道询问 ECharts-X 为什么还不升级新版本，是不是不再维护了等等，对于这些问题我们只能回答我们还没准备好。尽管这两年时间 ECharts X 没什么动静，但是其它的工作，像 ECharts 3 的架构大改动和后续版本的迭代升级，以及其它 WebGL 产品的开发，都是对新版本架构和技术上的积累。现在我们终于可以说我们准备得差不多了，ECharts-X 的下一代，ECharts-GL 发布 1.0 alpha。</p><p><img src="/blog/echarts-gl-alpha/buildings2.jpg" width="100%"></p><a id="more"></a><p><a href="https://github.com/ecomfe/echarts-gl" target="_blank" rel="noopener">ECharts GL</a> 是 ECharts 的 WebGL 扩展，其中提供了三维散点图，飞线图，柱状图，曲面图，地球等多种三维可视化方式。并且增加 <code>scatterGL</code>，<code>graphGL</code> 系列类型用于二维的散点图，关系图的加速绘制和布局。</p><p>先来一张 Gallery 上 <a href="https://github.com/ecomfe/echarts-gl" target="_blank" rel="noopener">ECharts GL</a> 的示例图片集。</p><div class="figure"><img src="/blog/echarts-gl-alpha/demos.jpg"></div><p>下面会一一介绍 ECharts GL 的特性，如果你已经等不及想尝鲜了，可以直接在 Gallery 上查看编辑 ECharts GL 的示例。</p><ul><li><p><a href="http://gallery.echartsjs.com/explore.html#tags=echarts-gl" target="_blank" rel="noopener">GL 的 Gallery 示例</a></p></li><li><p><a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html" target="_blank" rel="noopener">GL 的配置项手册</a></p></li></ul><h2 id="一更便捷的安装和引入">一、更便捷的安装和引入</h2><p>大家用过 ECharts-X 的话，或许曾被其繁琐的引入方式困扰过，甚至可能因为尝试了很多次都没办法正确引入而选择放弃。</p><p>ECharts-GL 中大大简化了引入方式，在标签引入的环境下。你可以从 <a href="https://github.com/ecomfe/echarts-gl/tree/master/dist" target="_blank" rel="noopener">GitHub</a> 上获取 ECharts GL 后直接引入构建好的文件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script data-src=<span class="string">"echarts/dist/echarts.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script data-src=<span class="string">"echarts-gl/dist/echarts-gl.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果你用 webpack 和 npm 作为开发环境。也只需要在 <code>npm install echarts-gl</code> 之后再<code>require</code>引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'echarts-gl'</span>);</span><br></pre></td></tr></table></figure><h2 id="二更多三维可视化类型">二、更多三维可视化类型。</h2><p>除了老版本的<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#globe" target="_blank" rel="noopener">地球</a>用于地理数据可视化，ECharts GL 新增了三维的<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#grid3D" target="_blank" rel="noopener">笛卡尔坐标系</a>、<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#geo3D" target="_blank" rel="noopener">地理坐标系</a>，并且在这些新的三维坐标系基础上提供了六个新的系列类型，包括 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatter3D" target="_blank" rel="noopener">散点图 scatter3D</a>、<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-line3D" target="_blank" rel="noopener">折线图 line3D</a>、<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-bar3D" target="_blank" rel="noopener">柱状图 bar3D</a>、<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-surface" target="_blank" rel="noopener">曲面图 surface</a>、<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-lines3D" target="_blank" rel="noopener">飞线图 lines3D</a>以及<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-map3D" target="_blank" rel="noopener">地图 map3D</a></p><p>这些新的系列类型以及组件类型都是使用 WebGL 绘制，因此能够保证高质量，高性能的展示出你想要的三维可视化作品。</p><p>同时我们在配置项的设计上尽量沿用了 ECharts 的风格，保证简洁统一。比如下面这个配置就能画出一个简单的三维散点图。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    grid3D: &#123;&#125;,</span><br><span class="line">    xAxis3D: &#123;&#125;,</span><br><span class="line">    yAxis3D: &#123;&#125;,</span><br><span class="line">    zAxis3D: &#123;&#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'scatter3D'</span>,</span><br><span class="line">        symbolSize: <span class="number">50</span>,</span><br><span class="line">        data: [[<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">            opacity: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里跟 ECharts 有点区别，GL 中尝试了更扁平的 option 设计，使用场景更少的 emphasis 属性将会单独移出来，而原先 normal 这个层级将被移除，itemStyle 下的属性相当于原先 itemStyle.normal 下的属性。如果这次尝试没问题，接下来 ECharts 新的大版本也会使用这种更扁平的设计。 具体配置结构见 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatter3D.itemStyle" class="uri" target="_blank" rel="noopener">https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatter3D.itemStyle</a></p></blockquote><p>大部分 GL 中的三维组件和系列都会带上<code>3D</code>后缀以便跟 ECharts 中的组件系列区分开。</p><p>下面这个更复杂点的例子使用<code>scatter3D</code>可视化了三维的 <a href="https://en.wikipedia.org/wiki/Simplex_noise" target="_blank" rel="noopener">Simplex Noise</a></p><p><a href="http://gallery.echartsjs.com/editor.html?c=xBkWoZOjTe" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/simplex-noise.jpg" alt=""> </a></p><p>除了三维的散点图，你也可以在笛卡尔坐标系上画 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-line3D" target="_blank" rel="noopener">折线图 line3D</a>，<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-bar3D" target="_blank" rel="noopener">柱状图 bar3D</a>，<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-surface" target="_blank" rel="noopener">曲面图 surface</a>。</p><p>其中 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-line3D" target="_blank" rel="noopener">line3D</a>，<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-bar3D" target="_blank" rel="noopener">bar3D</a> 也是对 ECharts 中的折线图，柱状图扩展到了三维的版本。而 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-surface" target="_blank" rel="noopener">surface</a> 是 ECharts GL 里全新的三维图。</p><p>你可以像下面这样用 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-surface" target="_blank" rel="noopener">surface</a> 画函数曲面。</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xHkcYXm9pe" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/surface.png" alt=""> </a></p><p>也可以像这样用曲面去可视化像图片像素这样的数据</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xBk5PSvqpx" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/image-pixels.jpg" alt=""> </a></p><p>甚至你可以用参数方程构建出下面这样有趣的参数曲面</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xHku9OE96l" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/parametric-surface.jpg" alt=""> </a></p><p>除了三维笛卡尔坐标系，像柱状图，散点图也可以显示在<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#globe" target="_blank" rel="noopener">地球</a>，<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#geo3D" target="_blank" rel="noopener">三维地理坐标系</a>上。</p><p>比如下面这个例子就是在地球上通过散点图绘制世界人口。</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xS1moC0s6x" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/high-quality-2.jpg" style="width:100%;" alt=""> </a></p><p>你可以大胆的组合不同坐标系和系列，制作出更具创造力的可视化作品！</p><h2 id="三高品质的画面">三、高品质的画面</h2><p>在很多场景里，高品质的画面是一个很重要的需求，例如：</p><ul><li><p>在大屏中，需要提供炫酷的，一下能够抓住人眼球的特效。</p></li><li><p>生成需要放在文章或者 PPT 中的截图，需要高质量的渲染，不能有廉价三维效果的感觉。</p></li></ul><p>ECharts GL 提供了一系列诸如<a href="http://localhost/echarts-doc/public/cn/option-gl.html#geo3D.postEffect.depthOfField" target="_blank" rel="noopener">景深</a>，<a href="http://localhost/echarts-doc/public/cn/option-gl.html#geo3D.postEffect.bloom" target="_blank" rel="noopener">光晕</a>，<a href="http://localhost/echarts-doc/public/cn/option-gl.html#geo3D.postEffect.colorCorrection" target="_blank" rel="noopener">颜色纠正</a>，<a href="http://localhost/echarts-doc/public/cn/option-gl.html#geo3D.postEffect.SSAO" target="_blank" rel="noopener">阴影</a>，<a href="http://localhost/echarts-doc/public/cn/option-gl.html#geo3D.light.ambientCubemap" target="_blank" rel="noopener">基于物理的渲染</a> 等等开箱即用的配置项让你去方便的提升自己可视化作品的渲染效果。</p><p>在这些配置项的基础上，你可以实现这样带景深的微缩模型的效果：</p><p><img src="/blog/echarts-gl-alpha/high-quality-1.jpg" style="width:100%;" alt=""></p><p>或者这样的基于物理渲染的金属零件的效果：</p><p><img src="/blog/echarts-gl-alpha/high-quality-3.jpg" style="width:100%;" alt=""></p><p>或者这样 Bling Bling 的影视广告特效：</p><p><img src="/blog/echarts-gl-alpha/high-quality-5.jpg" style="width:100%;" alt=""></p><p>又或者这样的大规模建筑群：</p><p><img src="/blog/echarts-gl-alpha/high-quality-4.jpg" style="width:100%;" alt=""></p><p>想要了解更多的效果，可以逛逛我们的<a href="http://gallery.echartsjs.com/explore.html#tags=echarts-gl" target="_blank" rel="noopener">示例集</a></p><h2 id="四二维可视化的加速">四、二维可视化的加速</h2><p>除了三维的可视化，ECharts GL 还内置 <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatterGL" target="_blank" rel="noopener">scatterGL</a>, <a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatterGL" target="_blank" rel="noopener">graphGL</a> 两个系列，能够大幅度的优化常见的二维散点图和关系图的绘制和布局性能。</p><p>散点图也是比较常见的会有大数据量的系列类型。ECharts 尽管能绘制像微博签到图那样上十万的散点图，但是很难做到流畅的交互。拖拽、缩放等操作都会有卡顿。</p><p>在 ECharts GL 里利用 WebGL 加速绘制后，可以无压力得绘制和实时的交互十万个数据的散点图了。</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xHJkXhU9Tg" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/weibo-checkin.jpg" alt=""></a></p><p>而且实现这一切只需要把原先的<code>scatter</code>类型改为<code>scatterGL</code>类型，不需要再做其它的改动！</p><p>对于<a href="https://ecomfe.github.io/echarts-doc/public/cn/option-gl.html#series-scatterGL" target="_blank" rel="noopener">关系图 graphGL</a>除了绘制上有加速之外，我们还在 WebGL 中实现了<a href="https://github.com/gephi/gephi/wiki/Force-Atlas-2" target="_blank" rel="noopener">力引导布局</a>。在高端的显卡上 GPU 布局相对于 CPU 布局甚至能有上百倍的性能提升。</p><p>下面是在<code>GTX1070</code>和<code>i7 4GHz</code>的电脑中对一个<code>两万</code>个节点，近<code>五万</code>条边的关系图一次布局的迭代的性能对比。</p><p><img src="/blog/echarts-gl-alpha/gpu-layout-perf.png" width="400px" alt=""></p><p>以及对这个关系图实时布局的视频。</p><video controls width="100%" src="/blog/echarts-gl-alpha/graphGL.mp4"></video><p><code>2500</code>个节点的网格图使用 GPU 布局的例子（只支持 PC 端）。</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xrJchBL9ag" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/grid.jpg" alt=""></a></p><p>这里特别感谢 Gephi 提供了 Force Atlas2 这样在大规模关系数据上能够有稳定优良的布局结果的算法。</p><h2 id="五与-echarts-交互组件的结合">五、与 ECharts 交互组件的结合</h2><p>ECharts GL 作为一个扩展，并不是独立的，它提供的系列和组件能够和 ECharts 中的大部分组件组合使用。你可以使用 <a href="http://echarts.baidu.com/option.html#visualMap" target="_blank" rel="noopener">visualMap</a> 组件对 GL 中的系列进行颜色，大小，不透明的编码，可以用 <a href="http://echarts.baidu.com/option.html#tooltip" target="_blank" rel="noopener">tooltip</a> 组件显示 GL 中图形的数据信息，也可以用 <a href="http://echarts.baidu.com/option.html#legend" target="_blank" rel="noopener">legend</a> 筛选出想要展示的系列等等。</p><p>例如下面这个例子用 <a href="http://echarts.baidu.com/option.html#visualMap" target="_blank" rel="noopener">visualMap</a> 组件对柱状图做了颜色的映射，而且能够通过控件筛选出区间内的数据</p><p><a href="http://gallery.echartsjs.com/editor.html?c=xSyMekmcTx" target="_blank" rel="noopener"> <img src="/blog/echarts-gl-alpha/visual-map.jpg" alt=""></a></p><p>当然除此之外，你也可以在一个实例里任意混搭使用 ECharts GL 的组件以及 ECharts 的组件。</p><h2 id="六移动端兼容">六、移动端兼容</h2><p>现在很多移动端的浏览器已经支持 WebGL 了，特别是像 iOS 系统对 WebGL 的扩展特性等支持得非常完善。所以用 ECharts GL 制作的大部分例子都能在 iOS 上流畅无压力的运行。在交互上 ECharts GL 也对移动端做了兼容处理，支持平移，双指缩放等等。</p><p>如果你现在不是在手机上浏览这篇文章，可以稍后在手机上打开 <a href="http://gallery.echartsjs.com/" class="uri" target="_blank" rel="noopener">http://gallery.echartsjs.com/</a> 看看效果。</p><p>下面是在 iPhone 6 上实时预览前面示例中参数曲面的效果。</p><video controls width="100%" src="/blog/echarts-gl-alpha/mobile.mp4"></video><h2 id="更多">更多</h2><p>ECharts GL 1.0 alpha 只是个开始，在正式版发布之前，我们还会对画面，交互的细节，动画，性能等等做更多的优化。大家使用过程中有任何的问题或者建议都可以在 GitHub 上跟我们反馈， 我们也非常期待大家能够利用 ECharts GL 做出让我们想象不到的作品。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;距离 ECharts-X 最近一个版本已经过去了两年多时间，期间我们不断被开发者在各种渠道询问 ECharts-X 为什么还不升级新版本，是不是不再维护了等等，对于这些问题我们只能回答我们还没准备好。尽管这两年时间 ECharts X 没什么动静，但是其它的工作，像 ECharts 3 的架构大改动和后续版本的迭代升级，以及其它 WebGL 产品的开发，都是对新版本架构和技术上的积累。现在我们终于可以说我们准备得差不多了，ECharts-X 的下一代，ECharts-GL 发布 1.0 alpha。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-gl-alpha/buildings2.jpg&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="GL" scheme="http://efe.baidu.com/tags/GL/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>React Native Code Push iOS</title>
    <link href="http://efe.baidu.com/blog/react-native-code-push-ios/"/>
    <id>http://efe.baidu.com/blog/react-native-code-push-ios/</id>
    <published>2017-04-09T16:00:00.000Z</published>
    <updated>2017-04-10T01:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近研究了下 React Native 的 Code Push 热更新，先来 iOS 版本~</p><a id="more"></a><ol style="list-style-type: decimal"><li><p>安装 code-push-cli 工具</p><p><code>npm install code-push-cli@latest -g</code></p></li><li><p>初始化 react native 工程</p><p><code>react-native init CodePushExample</code></p></li><li><p>在工程内安装 react-native-code-push</p><p><code>cd CodePushExample &amp;&amp; yarn add react-native-code-push</code></p></li><li><p>Add Link</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># react-native 0.27+</span></span><br><span class="line">react-native link react-native-code-push</span><br><span class="line"></span><br><span class="line"><span class="comment"># react-native &lt;0.27</span></span><br><span class="line">rnpm link react-native-code-push</span><br></pre></td></tr></table></figure><p><img src="/blog/react-native-code-push-ios/14842860020237.jpg" width="100%" height="100%"></p><blockquote><p>? What is your CodePush deployment key for Android</p><p>? What is your CodePush deployment key for iOS</p></blockquote><p>均先按回车忽略</p></li><li><p>修改代码，把 <code>index.ios.js</code> 和 <code>index.android.js</code> 里面的代码改为 <code>require('./demo');</code>，同时在同级增加 <code>demo.js</code>，内容如当前 repo 所示。</p></li><li><p>用 xcode 打开 <code>CodePushExample/ios/CodePushExample.xcodeproj</code>，同时把 <code>CodePushExample/node_modules/react-native-code-push/ios/CodePush.xcodeproj</code> 这个文件拖入到 xcode 工程 Project navigator 的 Libraries 中。 <img src="/blog/react-native-code-push-ios/14842869760170.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842870115096.jpg" width="100%" height="100%"></p></li><li><p>在 xcode 项目面板中选择根节点 <code>CodePushExample</code>，然后选择 <code>Build Phases</code> tab，把 Libraries/CodePush.xcodeproj/Products/libCodePush.a 拖入到 Link Binary With Libraries 中（注意，如果在 Libraries/CodePush.xcodeproj/Products/libCodePush.a 时候红色字体显示，说明 CodePush.xcodeproj 尚未 build，需要先 build）</p><p><img src="/blog/react-native-code-push-ios/14842873616006.jpg" width="100%" height="100%"></p></li><li><p>点击 Link Binary With Libraries 里面的加号，在弹出框中选择 libz.tbd，然后加入 iOS 10.2/libz.tbd</p><p><img src="/blog/react-native-code-push-ios/14842876200900.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842876827942.jpg" width="100%" height="100%"></p></li><li><p>在 Build Settings tab 里，搜索 <code>Header Search Paths</code>，然后编辑，添加 <code>$(SRCROOT)/../node_modules/react-native-code-push/ios</code>，下拉框中选择 <code>recursive</code></p><p><img src="/blog/react-native-code-push-ios/14842878430684.jpg" width="100%" height="100%"></p></li><li><p>执行 <code>code-push register</code></p><p><img src="/blog/react-native-code-push-ios/14842926044159.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842926201047.jpg" width="100%" height="100%"></p></li><li><p>执行 <code>code-push login</code></p><p><img src="/blog/react-native-code-push-ios/14842927576256.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842927646508.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842927893539.jpg" width="100%" height="100%"> <img src="/blog/react-native-code-push-ios/14842928483218.jpg" width="100%" height="100%"></p></li><li><p>执行 <code>code-push app add &lt;appname&gt;-ios</code></p><p>这里的 <appname> 不需要和项目的名称相同，后面加上 <code>-ios</code> 只是为了名字上与 android 版本作区分。如我在这里使用的是如下名称</appname></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push app add wlexample-ios</span><br></pre></td></tr></table></figure><p>执行结果如下： <img src="/blog/react-native-code-push-ios/14842932307722.jpg" width="100%" height="100%"></p><p>我们可以通过这个命令查询发布的信息 <code>code-push deployment ls wlexample-ios -k</code> <img src="/blog/react-native-code-push-ios/14842933123165.jpg" width="100%" height="100%"></p></li><li><p>xcode 修改 Info.plist，如下：</p><p><img src="/blog/react-native-code-push-ios/14842934651681.jpg" width="100%" height="100%"></p><ul><li>修改 <code>CodePushDeploymentKey</code> 的值为第 12 步生成的 <strong>Production</strong> 的 Deployment Key</li><li>添加 <code>Staging</code> 项，值为第 12 步生成的 <strong>Staging</strong> 的 Deployment Key</li><li>修改 <code>Bundle versions string, short</code> 的值为 <code>x.x.x</code> 三位形式</li></ul></li><li><p>关闭 <code>Dead Code Stripping</code></p><p><img src="/blog/react-native-code-push-ios/14842939189125.jpg" width="100%" height="100%"></p></li><li><p>运行程序，注意使用 <code>Release</code> Build</p><p><img src="/blog/react-native-code-push-ios/14842937573518.jpg" width="100%" height="100%"> 初次运行是这样的结果：</p><div class="figure"><img src="/blog/react-native-code-push-ios/14842947420429.gif"></div><p>查询发布信息 <code>code-push deployment ls wlexample-ios -k</code>，结果如下 <img src="/blog/react-native-code-push-ios/14842946090807.jpg" width="100%" height="100%"></p></li><li><p>现在让我们修改源代码，如下修改</p><div class="figure"><img src="/blog/react-native-code-push-ios/14842948563587.gif"></div></li><li><p>发布更新，注意名字和我们之前 <code>code-push app add</code> 时的名字一致</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-push release-react wlexample-ios ios -d Production</span><br></pre></td></tr></table></figure><p><img src="/blog/react-native-code-push-ios/14842950991102.jpg" width="100%" height="100%"></p><p>再次查询发布信息 <code>code-push deployment ls wlexample-ios -k</code> <img src="/blog/react-native-code-push-ios/14842951376848.jpg" width="100%" height="100%"></p></li><li><p>在模拟器中重启程序。<strong>不需要在 xcode 中重新 build 了</strong></p><div class="figure"><img src="/blog/react-native-code-push-ios/14842952679367.gif"></div></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近研究了下 React Native 的 Code Push 热更新，先来 iOS 版本~&lt;/p&gt;
    
    </summary>
    
    
      <category term="practice" scheme="http://efe.baidu.com/tags/practice/"/>
    
      <category term="React Native" scheme="http://efe.baidu.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>How you create your own Native Bridge - JSVM and the first adventure</title>
    <link href="http://efe.baidu.com/blog/how-to-create-you-own-native-bridge-c2/"/>
    <id>http://efe.baidu.com/blog/how-to-create-you-own-native-bridge-c2/</id>
    <published>2017-04-04T16:00:00.000Z</published>
    <updated>2017-04-05T01:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：https://medium.com/<span class="citation">@kureevalexey/how-to-create-your-own-native-bridge-bfa050e708fc</span>#.ykryuzmun</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/1.png" alt="JSVM and the first adventure"><p class="caption">JSVM and the first adventure</p></div><p>What do you know about JavaScript engines? Did you ever try to embed one? In this chapter I’m going to guide you through the dark spooky forest of hosted objects, virtual machines, interpreters and other evil spirits that we call JavaScript engines.</p><p>你之前对 JS 引擎是否有过了解？有没有试着在自己的项目里面嵌入一个 JS 引擎玩玩儿？在这篇文章里面，我会给你一些指引，以便可以顺利通过含有 Hosted Objects, Virtual Machines, Interpreters 以及一些其它稀奇古怪玩意儿的『魔法森林』。（<em>不太准确</em>）</p><p>I know that it may look scary, but don’t forget that a journey of a thousand miles starts with a single step. In our case it’ll be a step into code parsing. At this stage our JavaScript source is getting converted to a structure called abstract syntax tree (AST). There are many different techniques to parse your code (LL(k), LR(k) etc) and convert it to AST, but for the sake of simplicity I want to keep it out of this article.</p><p>我知道这听起来很疯狂，不过我们要牢记『千里之行，始于足下』。对我们来说，第一步就是代码解析，也就是把原始的 JS 代码转化成抽象语法树（AST）的表示形式。业界已经有很多不同的方案可以把原始代码转化成抽象语法树，例如 LL(k), LR(k) 等等，不够为了简单起见，这篇文章里面我不会涉及相关的内容。</p><a id="more"></a><blockquote><p>Although, for those who are interested, I got all my knowledge about parsers (and compiler theory in general) from the Dragon Book. I just can’t recommend it enough. 不过对于感兴趣的读者，我所有对解析器编译器的知识都是来自传说中的那本『龙书』。 I just can’t recommend it enough. (<em>如何翻译</em>)</p></blockquote><p>However, I will tell you more about the abstract syntax tree concept. An AST is a structural representation of your code in a tree format where every node represents a language construct (e.g. expressions, statements, variables, literals etc). You can play with it using ESPrima praser demo page or ASTExplorer. 尽管如此，我还是想对 AST 多说一句。简单来说 AST 是代码另外一种结构化的表达形式，树中的每个节点可以表达编程语言中一种构型(<em>不太准确</em>)，比如：表达式，语句，变量，字面量等等。你可以借助 ESPrima 或者 ASTExplorer 来直观的看到 AST 的表达形式。</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/2.png" alt="Abstract syntax tree inside ChakraCore forest"><p class="caption">Abstract syntax tree inside ChakraCore forest</p></div><p>First of all, a JavaScript engine has to parse (tokenize) a source code to produce an array of tokens. These tokens are supplied to a syntactic analysis tool that builds an AST based on a given language grammar. Once an AST is built, JavaScript engine will compile it either to machine code directly (V8 behaves this way) or to intermediate representation, which is an another level of abstraction over machine code.</p><p>首先，JS 引擎会把我们的代码进行词法解析，得到一组 Token，之后这些 Token 会交给语法分析器来构造抽象语法树（AST）。一旦抽象语法树（AST）构造成功之后，JS 引擎就会直接把它编译成机器码（比如 V8 就是这么做的）或者转化成 IR 的表达形式（也就是机器码只上的另外一种抽象形式）</p><p>In this experiment I committed to use ChakraCore which uses a bytecode as it’s intermediate language. But it can’t be executed straight away: our target machine doesn’t know how to process it.</p><p>在我们使用的 ChakraCore 中，它的 IR 表达形式是字节码，但是字节码无法被直接执行，最终还是需要被转化成机器码才可以。</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/3.png" alt="A bytecode river"><p class="caption">A bytecode river</p></div><p>In order to bridge the gap, ChakraCore includes a bytecode interpreter. On ChakraCore’s bytecode each instruction starts with a 1-byte bytecode that represents which operation should be executed (a.k.a. opcode), and therefore the interpreter may have up to 256 instructions. Some bytecodes may take multiple bytes, and may be arbitrarily complicated</p><p>为了能够执行字节码，ChakraCore （很多其它 JS 引擎）引入了字节码解释器。ChakraCore 设计字节码指令的时候，开始的第一个字节用来定义应该执行何种操作（也就是常说的 <code>opcode</code>），然后解释器可以执行最多 256 个指令。有些指令操作可能需要多个字节才能够表达，而且可能异常复杂（<em>不太准确</em>）</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/4.png" alt="On the way to the “Interpreter” ship"><p class="caption">On the way to the “Interpreter” ship</p></div><p>That was a very short overview of the JS execution flow. Probably you noticed that in this article we don’t talk about inner code optimizations (like JIT or AoT). Although it’s a very interesting topic, I decided to omit it in order to make this article easier to grasp.</p><p>上述内容就是关于 JS 引擎如何执行 JS 的一个简单介绍，这里面并没有涉及到一些代码优化方面的内容（比如 JIT 或者 AoT 之类的技术），尽管如此，这也是一个很有意思的课题，不过我还是决定尽快结束这部分的内容，以便可以进入正题。</p><h2 id="embedding-chakracore">Embedding ChakraCore</h2><h2 id="准备嵌入-chakracore">准备嵌入 ChakraCore</h2><p>Now, when we have some knowledge about ChakraCore, we can start embedding it into our application. So first of all we need to install ChakraCore dependencies:</p><p>到现在为止，我们对 ChakraCore 已经有了基本的了解，所以要着手把它嵌入到我们的 Cocoa 应用中去了。 第一步要做的事情是安装相关的依赖，以便可以把 ChakraCore 编译出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ xcode-select --install</span><br><span class="line">$ brew install cmake icu4c</span><br></pre></td></tr></table></figure><p>And ChakraCore itself. I will show how to include it as a submodule: 然后获取 ChakraCore 的源代码，并且把它设置成我们项目的一个子模块（其实不是必须的，只是为了方便起见）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir modules &amp;&amp; <span class="variable">$_</span></span><br><span class="line">$ git submodule add https://github.com/Microsoft/ChakraCore</span><br></pre></td></tr></table></figure><p>Then build it from the source: 最后执行如下命令来编译源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ChakraCore</span><br><span class="line">$ ./build.sh --static --icu=/usr/<span class="built_in">local</span>/Cellar/icu4c/&lt;version&gt;/include --<span class="built_in">test</span>-build -j=2</span><br></pre></td></tr></table></figure><p>Once these steps are done, we can include it into our application: 如果一切顺利的话，我们就可以在前一篇文章里面提到的项目中引用编译的产物了：</p><ol style="list-style-type: decimal"><li>Open the project we created in the previous chapter</li><li>用 XCode 打开前一篇文章里面提到的项目</li><li>Select ExampleBridge project in the Project navigator and switch to the target:</li><li>选择 ExampleBridge 项目，然后在项目属性中切换到 <code>target</code> 配置项目：</li></ol><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/5.png" alt="ExampleBridge target is selected"><p class="caption">ExampleBridge target is selected</p></div><p>Link your compiled ChakraCore files: 链接一下 ChakraCore 的编译产物：</p><ul><li>libChakra.Pal.a</li><li>libChakra.Common.Core.a</li><li>libChakra.Jsrt.a</li></ul><p>And your icu4u files (from /usr/local/Cellar/icu4c/<version>/include): 以及 icu4u 的几个库文件（地址是 /usr/local/Cellar/icu4c/<version>/include）：</version></version></p><ul><li>libicudata.a</li><li>libicui18n.a</li><li>libicuuc.a</li></ul><p>Your result should look like this: 最终的结果看起应该是这样子的：</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/6.png" alt="All libraries are linked properly"><p class="caption">All libraries are linked properly</p></div><blockquote><p>Note: order of these dependencies is very important! 注意：链接库的顺序很重要，别弄错了！</p></blockquote><h2 id="getting-started-with-chakracore">Getting started with ChakraCore</h2><h2 id="开始使用-chakracore">开始使用 ChakraCore</h2><p>We come to the very interesting part of our journey. To the place where we need all our knowledge about JavaScript engines and the way they work. Yes, dear reader, you’re right! We’re about to start using ChakraCore! 终于开始介绍最有意思的部分了，为了能理解后续的内容，我们需要前面的背景知识以便对 JS 引擎的工作原理有一个基本的了解。幸运的是，我们做到了，下面就开始介绍如何来使用 ChakraCore。</p><h3 id="bootstrapping-chakracore">Bootstrapping ChakraCore</h3><h3 id="初始化-chakracore">初始化 ChakraCore</h3><p>First of all, open your ChakraProxy.m file and find the NSLog statement that we added in the previous chapter. Let’s replace it by something that makes more sense: 首先，打开 <code>ChakraProxy.m</code> 文件找到 <code>NSLog</code> 这一行，然后把它替换成下面的几句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@implementation ChakraProxy</span><br><span class="line"></span><br><span class="line">-(void)run &#123;</span><br><span class="line">    unsigned currentSourceContext = 0;</span><br><span class="line">    </span><br><span class="line">    NSString *filepath = [[NSBundle mainBundle] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</span><br><span class="line">    NSError *error;</span><br><span class="line">    NSString *fileContents = [NSString stringWithContentsOfFile:filepath encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    if (error) &#123;</span><br><span class="line">        NSLog(@&quot;Error reading file: %@&quot;, error.localizedDescription);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const char *script = [fileContents cStringUsingEncoding:NSASCIIStringEncoding];</span><br><span class="line">    </span><br><span class="line">    // Create a runtime</span><br><span class="line">    JsCreateRuntime(JsRuntimeAttributeNone, nullptr, &amp;runtime);</span><br><span class="line">    </span><br><span class="line">    // Create a context</span><br><span class="line">    JsCreateContext(runtime, &amp;context);</span><br><span class="line">    JsSetCurrentContext(context);</span><br><span class="line">    </span><br><span class="line">    // Run script</span><br><span class="line">    JsRunScriptUtf8(script, currentSourceContext++, &quot;&quot;, nullptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>I don’t expect you to be familiar with Objective C, so let me guide you through this code: 我不指望你对 Objective C 能有多熟悉，所以还是需要简单的介绍一下上面的代码是做啥的：</p><ul><li>Line 6–8: Read a content of main.js file from the bundle. <a href="https://developer.apple.com/reference/foundation/bundle" target="_blank" rel="noopener">More about bundles here</a>.</li><li><p>第 6 行 - 第 8 行：从 <a href="https://developer.apple.com/reference/foundation/bundle" target="_blank" rel="noopener">Bundle</a> 里面读取 main.js 的内容。</p></li><li>Line 14: ChakraCore is an engine, written in C++, so it doesn’t understand NSString format. However, we used Objective C approach to read a file content and now we have to deal with NSString to const char* conversion. So, that’s how we do it.</li><li><p>第 14 行：因为 ChakraCore 是 C++ 开发的，它提供的接口不支持 NSString 类型的参数，所以我们通过 Objective C 读取了文件内容之后，还需要把 NSString 类型转化为 const char * 类型，以便可以正常调用 ChakraCore 提供的 API。</p></li><li>Line 24: That’s my custom C++ function. I use it in order to reduce a cognitive payload of run method and move a function description to the different section of this article.</li><li><p>第 24 行：调用自定义的 C++ 函数 <code>JsRunScriptUtf8</code>，目的是为了减少 <code>run</code> 方法的代码行数，另外也为了后面也可以单独介绍这个函数的实现。</p></li></ul><p>Hope it doesn’t look very complex to you. Anyway, there are still some unclear places in this code: 希望上面的内容没有那么复杂，不过上面的代码里面还是有几个没有澄清的概念：</p><h3 id="runtime">Runtime</h3><h3 id="运行时runtime">运行时（Runtime）</h3><p>Runtime (line 17) represents a complete JavaScript execution environment. Each runtime that is created has its own isolated garbage-collected heap and, by default, its own just-in-time (JIT) compiler thread and garbage collector (GC) thread. (see <a href="https://github.com/Microsoft/ChakraCore/wiki/JavaScript-Runtime-%28JSRT%29-Overview#concepts" target="_blank" rel="noopener">ChakraCore JSRT overview</a>) 第 17 行的运行时（Runtime）代表的是一个 JS 的执行环境。运行时之间是相互隔离的，每个运行时（Runtime）有自己的 GC 堆栈，自己的 JIT 编译线程 和 GC 垃圾回收线程，更多的内容请参考 <a href="https://github.com/Microsoft/ChakraCore/wiki/JavaScript-Runtime-%28JSRT%29-Overview#concepts" target="_blank" rel="noopener">ChakraCore JSRT overview</a></p><h3 id="execution-context">Execution Context</h3><h3 id="执行上下文execution-context">执行上下文（Execution Context）</h3><p>Context (line 20–21) is an execution environment that allows separate, unrelated, JavaScript applications to run in a single instance of runtime. You must explicitly specify the context in which you want any JavaScript code to be run. (see <a href="https://github.com/v8/v8/wiki/Embedder%27s%20Guide#contexts" target="_blank" rel="noopener">V8 Embedder’s Guide</a>)</p><p>第 20 行 - 第 21 行 的执行上下文（Execution Context）允许在同一个运行时（Runtime）中执行独立的，不相关的 JS 代码。（<em>不太准确</em>）当执行 JS 代码的时候，必须显示的声明在哪个执行上下文中去运行。更多的内容请参考<a href="https://github.com/v8/v8/wiki/Embedder%27s%20Guide#contexts" target="_blank" rel="noopener">V8 Embedder’s Guide</a></p><h3 id="extending-global-scope">Extending global scope</h3><h3 id="扩展全局对象">扩展全局对象</h3><p>Now, when ChakraCore is set up, it’s time to build a bridge. In the previous chapter I briefly mentioned that we’re going to use hosted objects to expose C++ functions to JavaScript. So let’s write a function that will do it for us: ChakraCore 初始化之后，我们就需要考虑如何把 <code>bridge</code> 构造出来。在前一篇文章里面，我简单的提到了使用 <code>Hosted Object</code> 来把 C++ 的一些函数暴露给 JS，所以我们考虑通过 <code>SetupGlobalEnvironment</code> 来完成这部分工作，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JsErrorCode SetupGlobalEnvironment() &#123;</span><br><span class="line">    JsValueRef globalObject;</span><br><span class="line">    JsGetGlobalObject(&amp;globalObject);</span><br><span class="line">    </span><br><span class="line">    JsValueRef bridgeObject;</span><br><span class="line">    JsCreateObject(&amp;bridgeObject);</span><br><span class="line">    </span><br><span class="line">    ChakraUtils::setObjectProperty(globalObject, &apos;bridge&apos;, bridgeObject);</span><br><span class="line">    ChakraUtils::setObjectFunctionProperty(bridgeObject, &apos;render&apos;, render);</span><br><span class="line">    </span><br><span class="line">    return JsNoError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you rewrite the code above to JavaScript, it’ll look like this: 如果用 JS 来实现上面的逻辑，代码可能看起来是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function SetupGlobalEnvironment() &#123;</span><br><span class="line">  var globalObject = JsGetGlobalObject();</span><br><span class="line">  var bridge = &#123;</span><br><span class="line">    render: render,</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  globalObject.bridge = bridge;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>As you can see from the snippet above, we use a special ChakraCore function JsGetGlobalObject to get context’s “global” object. Once it is there, we extend it by a custom hosted object called “bridge” to expose our C++ “render” function to JS. This approach is similar to the one we used in our web applications back in a day. I’m talking about namespaces, when you move all your application modules under window.app or a similar object in order to scope them by an organic global variable. In this code we do the same, but instead of modules we expose a custom C++ function. You are probably wondering why in the code above I use ChakraUtils. It’s a self-written wrapper over a standard ChakraCore API. I won’t go though the code, but you can find my implementation on the github. 从上面的代码可以看到，我们调用了 ChakraCore 提供的 JsGetGlobalObject API 来获取执行上下文（Execution Context）中全局 （<code>global</code>）对象，然后在它上面添加了一个名字是 <code>bridge</code> 的对象，在 <code>bridge</code> 这个对象上面通过 C++ 扩展了一个 <code>render</code> 的方法，如今在 Web 开发中也大量采用类似的技术。这里我要额外提一下命名空间（namespace），当我们把所有应用的代码都挂到 <code>window.app</code> 或者类似一个对象上面的时候，目的是为了使用一个全局对象来控制他们的作用范围（<em>不太准确</em>）。另外，你可能有些疑惑，为啥上面会用到 ChakraUtils，实际上它只是封装了一下 ChakraCore 的API，所以这里不会过多的介绍，你可以从我的 github 上面看到它具体的实现。</p><p>However, the “render” function is still has to be defined. It should fit a JS function interface and perform an async dispatch to the main thread. The simplest implementation will look like this: 尽管如此，前面提到的 <code>render</code> 这个函数还没有实现，我们需要完成这部分工作。它的实现逻辑应该符合 JS 函数的接口，当调用的时候给主线程派发一个异步的操作。最简单的实现代码可能看起来是这样子的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JsValueRef <span class="title">render</span><span class="params">(JsValueRef callee, <span class="keyword">bool</span> isConstructCall, JsValueRef *arguments, <span class="keyword">unsigned</span> <span class="keyword">short</span> argumentCount, <span class="keyword">void</span> *callbackState)</span> </span>&#123;    </span><br><span class="line">    NSString *type = [NSString stringWithUTF8String:ChakraUtils::toString(arguments[<span class="number">1</span>])];</span><br><span class="line">    <span class="keyword">float</span> w &#123;ChakraUtils::toFloat(arguments[<span class="number">2</span>])&#125;;</span><br><span class="line">    <span class="keyword">float</span> h &#123;ChakraUtils::toFloat(arguments[<span class="number">3</span>])&#125;;</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        id delegate = [[NSApplication sharedApplication] delegate];</span><br><span class="line">                       </span><br><span class="line">        [delegate renderElementOfType:type size:NSMakeSize((CGFloat)w, (CGFloat)h)];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> JS_INVALID_REFERENCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Try to not to be overwhelmed by the amount of function parameters, in this article we’re about to use only one — arguments. The code above will read the first two parameters passed to the function from JavaScript and invoke an Objective-C AppDelegate method called renderElementOfType . No callbacks, no return values. Let’s keep it simple for now. 不要被上面函数参数的数量吓到，实际上在这篇文章里面，我们只用到了一个参数，也就是 <code>arguments</code>。上面的代码主要完成的工作是读取 JS 调用 render 函数时候传递的参数，然后调用 Objective C AppDelegate 里面 renderElementOfType 方法传递过去。不需要考虑返回值，不需要考虑回掉函数。</p><p>One thing, that may make you feel confused is a dispatch_async call. We use this function in order to schedule a block (statement inside ^{}) to be executed in the main dispatch queue (see <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">GCD documentation for details</a>). 上面代码里面有一个地方可能比较费解，就是 dispatch_async 的调用。我们用这个函数是为了在主线程调度队列里面调度执行一个 block，更多内容请参考<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html" target="_blank" rel="noopener">官方的文档</a></p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/7.png" alt="Traveling to the Main Thread island"><p class="caption">Traveling to the Main Thread island</p></div><p>Now, once “render” function is invoked, it sends a block to the main thread. Inside the block we have a renderElementOfType call, which is responsible for a final element creation: 现在一旦在 JS 里面调用 render 函数，就会把一个 block 发送到主线程。在这个 block 里面我们调用了 renderElementOfType 方法，然后开始绘制 UI。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)renderElementOfType:(NSString *)name size:(NSSize)size &#123;</span><br><span class="line">    GGWindow *window = [[GGWindow alloc] init];</span><br><span class="line">    [window openWithSize:NSMakeSize((CGFloat)size.width, (CGFloat)size.height)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>You may notice, that we hardcode window and don’t even use a name property. We’ll get back to this part in the third chapter. Other than that, this code should be pretty straight-forward: we create a CGWindow instance and call openWithSize method with a given params. 你可能注意到了，上面 renderElementOfType 函数里面我们对 window 硬编码了，什么还没来得及给它起名字，不过在第三篇文章里面我们还会介绍这部分的内容。除此之外，其它的部分应该很容易理解了，创建了一个 CGWindow 实例，然后调用 openWithSize 方法。</p><p>But when you call this function, you don’t see a window. Why? Because window is a local variable and it will be deallocated once you leave the function scope. So in order to see a window, we have to store a reference to this window somewhere outside of the function. Let’s create a UIManager class that will manage our UI references: 不过我们并没有看到窗口出现，为什么呢？因为 window 是一个局部变量，一旦 renderElementOfType 函数执行完毕，window 就会被释放掉了。所以为了能看到创建的窗口，必须把 CGWindow 的实例存在 renderElementOfType 函数之外的某个地方，保证窗口的引用不会被释放。所以我们创建了 UIManager 这个类，来管理所有 UI 的引用，代码如下：</p><p><strong>EBUIManager.h</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface EBUIManager : NSObject</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance;</span><br><span class="line">- (void)addValue:(id)value forKey:(NSString *)key;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p><strong>EBUIManager.m</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;EBUIManager.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation EBUIManager</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *registry;</span><br><span class="line"></span><br><span class="line">+ (instancetype)sharedInstance &#123;</span><br><span class="line">    static EBUIManager *sharedInstance = nil;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        if (!sharedInstance) &#123;</span><br><span class="line">            sharedInstance = [[self alloc] init];</span><br><span class="line">            registry = [NSMutableDictionary new];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addValue:(id)value forKey:(NSString *)key &#123;</span><br><span class="line">    [registry setValue:value forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>You’re probably wondering what does a sharedInstance mean? It’s one of the ways to create a singleton in Objective C. It’s not necessary to make UIManager a singleton, but to me it feels like a right way to do it. 你了能对上面的 sharedInstance 比较疑惑，它到底是干什么的呢？实际上那是在 Objective C 里面创建一个单例的方式，虽然对于 UIManager 来说，单例不是必须的，不过对我来说，让 UIManager 成为单例是一种很直观的方式。</p><p>This class has the only one public API method: addValue. In the next chapter I’m going to add some more (like deleteValue), but let’s keep it as simple as possible for now. UIManager 对外提供了唯一的接口 addValue。在下一章会给 UIManager 添加更多的接口（比如 deleteValue 之类的），不过现在为了简单起见，我们只需要 addValue 这一个接口。</p><p>Let’s update our renderElementOfType function to start using our storage: 现在就可以修改一下之前 renderElementOfType 的实现了，需要用 UIManager 来管理一下 CGWindow 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)renderElementOfType:(NSString *)name size:(NSSize)size &#123;</span><br><span class="line">    EBWindow *window = [[EBWindow alloc] init];</span><br><span class="line">    EBUIManager *manager = [EBUIManager sharedInstance];</span><br><span class="line">    [window openWithSize:NSMakeSize((CGFloat)size.width, (CGFloat)size.height)];</span><br><span class="line">    NSString *uuid = [[NSUUID UUID] UUIDString];</span><br><span class="line">    [manager addValue:window forKey:uuid];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>So once we get a UIManager instance, we generate a uuid for our window and put it in the storage by addValue. Inside the manager we generate a strong reference to the given object which prevents it from being deallocated (see ARC). 我们给每个 CGWindow 的实例生成一个 UUID，然后调用 UIManager 的 addValue 方法来保存这些实例的引用。在 UIManager 内部，我们用『强引用』(strong reference)的方式来保存 CGWindow 实例的引用，从而可以避免被释放，更多内容请参考 <a href="https://en.wikipedia.org/wiki/Automatic_Reference_Counting" target="_blank" rel="noopener">ARC 的官方文档</a></p><p>And you know what? That’s it! If you create a main.js file, add it to the bundle and type something like bridge.render('Window', 400, 400);, you’ll see a 400x400 window at the application startup! 好的，结束了，我们现在只需要准备一个 main.js，内容是 <code>bridge.render('Window', 400, 400)</code>，然后把它添加到 bundle 里面去，编译，运行整个项目，我们就能看到一个 400x400 的应用窗口出现了。</p><div class="figure"><img src="/blog/how-to-create-you-own-native-bridge-c2/8.png" alt="Empty 400x400 window, created from JavaScript"><p class="caption">Empty 400x400 window, created from JavaScript</p></div><p>Buy hey, it has nothing about React yet! What do we need to provide for a React-like interface to our platform? How to return references from Objective-C to JS? All these questions will be answered in the Chapter 3! 不过到这里还没有跟 React 扯上任何关系。如果要运行 React 的应用，在我们的平台上还缺少什么呢？如果把一些引用从 Objective C 返回给 JS 呢？这些问题我们会在第三篇文章里面回答。</p><p>In the meanwhile, you can play around with the code from this article. 与此同时，你可以从我们的 github 账户中把<a href="https://github.com/Kureev/ExampleBridge/releases/tag/2.0" target="_blank" rel="noopener">代码</a> checkout 本地测试，运行一下看看效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：https://medium.com/&lt;span class=&quot;citation&quot;&gt;@kureevalexey/how-to-create-your-own-native-bridge-bfa050e708fc&lt;/span&gt;#.ykryuzmun&lt;/p&gt;
&lt;div class=&quot;figure&quot;&gt;
&lt;img src=&quot;/blog/how-to-create-you-own-native-bridge-c2/1.png&quot; alt=&quot;JSVM and the first adventure&quot;&gt;&lt;p class=&quot;caption&quot;&gt;JSVM and the first adventure&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;What do you know about JavaScript engines? Did you ever try to embed one? In this chapter I’m going to guide you through the dark spooky forest of hosted objects, virtual machines, interpreters and other evil spirits that we call JavaScript engines.&lt;/p&gt;
&lt;p&gt;你之前对 JS 引擎是否有过了解？有没有试着在自己的项目里面嵌入一个 JS 引擎玩玩儿？在这篇文章里面，我会给你一些指引，以便可以顺利通过含有 Hosted Objects, Virtual Machines, Interpreters 以及一些其它稀奇古怪玩意儿的『魔法森林』。（&lt;em&gt;不太准确&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;I know that it may look scary, but don’t forget that a journey of a thousand miles starts with a single step. In our case it’ll be a step into code parsing. At this stage our JavaScript source is getting converted to a structure called abstract syntax tree (AST). There are many different techniques to parse your code (LL(k), LR(k) etc) and convert it to AST, but for the sake of simplicity I want to keep it out of this article.&lt;/p&gt;
&lt;p&gt;我知道这听起来很疯狂，不过我们要牢记『千里之行，始于足下』。对我们来说，第一步就是代码解析，也就是把原始的 JS 代码转化成抽象语法树（AST）的表示形式。业界已经有很多不同的方案可以把原始代码转化成抽象语法树，例如 LL(k), LR(k) 等等，不够为了简单起见，这篇文章里面我不会涉及相关的内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React Native" scheme="http://efe.baidu.com/tags/React-Native/"/>
    
      <category term="JS Engine" scheme="http://efe.baidu.com/tags/JS-Engine/"/>
    
      <category term="Objective C" scheme="http://efe.baidu.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>ECharts v3.5 发布：新增日历坐标系、坐标轴指示器；同时统计扩展 v1.0 发布</title>
    <link href="http://efe.baidu.com/blog/echarts-3-5-0/"/>
    <id>http://efe.baidu.com/blog/echarts-3-5-0/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2019-01-08T08:12:54.833Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECharts 新发布的 <a href="https://github.com/ecomfe/echarts/releases/tag/3.5.0" target="_blank" rel="noopener">3.5 版本</a>中，新增了日历坐标系，增强了坐标轴指示器。同时，<a href="https://github.com/ecomfe/echarts-stat" target="_blank" rel="noopener">ECharts 统计扩展</a> 1.0 版本发布了。日历坐标系用于在日历中绘制图表，坐标轴指示器方便用户观察数据内容，统计扩展是一个专门用来进行数据分析的工具。</p><p><img style="width:100%" src="/blog/echarts-3-5-0/banner.png"></p><a id="more"></a><h2 id="统计扩展">统计扩展</h2><p>统计扩展是一个专门用来进行数据分析的工具，目前主要包含了二维的回归、多维的聚类以及一些常用的统计功能。</p><p>扩展中的回归算法不仅包含了常用的线性回归，还包含了指数回归、对数回归、以及多项式回归。</p>线性回归的示例：<div class="ec-lazy" data-thumb="/blog/echarts-3-5-0/xS1bQ2AMKe.png" data-src="http://gallery.echartsjs.com/view.html?cid=xS1bQ2AMKe" style="width: 100%; height: 400px"></div>对数回归的示例：<div class="ec-lazy" data-thumb="/blog/echarts-3-5-0/xry3aWkmYe.png" data-src="http://gallery.echartsjs.com/view.html?cid=xry3aWkmYe" style="width: 100%; height: 400px"></div><p>秉承了可视分析的宗旨，我们的多维聚类分析，不仅可以静态地产出数据集聚类的结果，还可以动态地查看整个聚类分析的过程。</p>静态地产出数据集聚类的结果的示例：<div class="ec-lazy" data-thumb="/blog/echarts-3-5-0/xSkBOEaGtx.png" data-src="http://gallery.echartsjs.com/view.html?cid=xSkBOEaGtx" style="width: 100%; height: 400px"></div>动态地查看整个聚类分析的过程的示例：<div class="ec-lazy" data-thumb="/blog/echarts-3-5-0/xHyr-esMtg.png" data-src="http://gallery.echartsjs.com/view.html?cid=xHyr-esMtg" style="width: 100%; height: 400px"></div><p>和 echarts 中的原生图表不一样，统计扩展是作为一个扩展工具发布的。这意味着，在 echarts 官网下载的完整版本将不包含该扩展包。统计扩展和 echarts 结合使用时，需要在引入 <code>echarts.js</code> 之后，另外引入统计扩展对应的 <code>ecStat.js</code>。可以在 <a href="https://github.com/ecomfe/echarts-stat/releases/latest" target="_blank" rel="noopener">这里 (GitHub)</a> 找到最新版本，其中 <code>dist/ecStat.js</code> 可作为单文件引用。</p><p>如果想了解更多内容请前往 <a href="https://github.com/ecomfe/echarts-stat" target="_blank" rel="noopener">统计扩展 GitHub 首页</a>。</p><h2 id="日历坐标系">日历坐标系</h2><p>日历坐标系，是一种新的 echarts 坐标系，提供了在日历上绘制图表的能力。例如可以在日历坐标系上放置热力图、散点图、关系图等。如下示例：</p>在日历坐标系中使用热力图：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=calendar-heatmap&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div>在日历坐标系中使用散点图：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=calendar-effectscatter&amp;edit=1&amp;reset=1" style="width: 100%; height: 600px"></div>还可以混合放置不同的图表，例如下例子，同时放置了热力图和关系图：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=calendar-graph&amp;edit=1&amp;reset=1" style="width: 100%; height: 600px"></div><p><strong>水平和垂直放置日历</strong></p><p>在日历坐标系可以水平放置，也可以垂直放置。如上面的例子，使用热力图时，经常是水平放置的。但是如果需要格子的尺寸大些，水平放置就过于宽了，于是也可以选择垂直放置。参见 [calendar.orient](#calendar.orient)。</p><p><strong>尺寸的自适应</strong></p><p>日历坐标系支持不同尺寸的容器（页面）大小变化的自适应。首先，和 echarts 其他组件一样，日历坐标系可以选择使用 [left](#calendar.left)，[right](#calendar.right)，[top](#calendar.top)，<a href="bottom" class="uri">bottom</a>，[width](#calendar.width)，[height](#calendar.height) 来描述尺寸和位置，从而将日历摆放在上下左右各种位置，并随着页面尺寸变动而改变自身尺寸。另外，也可以使用 [cellSize](#calendar.cellSize) 来固定日历格子的长宽。</p><p><strong>中西方日历习惯的支持</strong></p><p>中西方日历有所差别，西方常使用星期日作为一周的第一天，中国使用星期一为一周的第一天。日历坐标系做了这种切换的支持。参见 [calendar.dayLabel.firstDay](#calendar.dayLabel.firstDay)。</p><p>另外，日历上的『月份』和『星期几』的文字，也可以较方便的切换中英文，甚至自定义。参见 [calendar.dayLabel.nameMap](#calendar.dayLabel.nameMap) [calendar.monthLabel.nameMap](#calendar.monthLabel.nameMap)。</p><p><strong>其他更丰富的效果</strong></p><p>灵活利用 echarts 图表和坐标系的组合，以及 API，可以实现更丰富的效果。</p>例如，制作农历：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=calendar-lunar&amp;edit=1&amp;reset=1" style="width: 100%; height: 500px"></div>下面这个例子，使用 <code>chart.convertToPixel</code> 接口，实现了饼图放置在日历坐标系中的效果。<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=calendar-pie&amp;edit=1&amp;reset=1" style="width: 100%; height: 640px"></div><h2 id="坐标轴指示器">坐标轴指示器</h2><p>坐标轴指示器 （axisPointer）指的是，鼠标悬浮到坐标系上时出现的竖线、阴影区域等。它能帮助用户观察数据。echarts 原有的坐标轴指示器本次被整理和增强了，加入了文本标签，自动吸附到数据，以及移动触屏的手柄拖拽交互，以及支持了多个坐标系中指示器的联动。</p>下面是一个K线图的示例。使用坐标轴指示器，能够比较方便得观察到每一项对应的 y 值。<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=doc-example/candlestick-axisPointer&amp;edit=1&amp;reset=1" style="width: 100%; height: 450px"></div><p>上例中，使用了 [axisPointer.link](#axisPointer.link) 来关联上下两个直角坐标系的 axisPointer，使他们同步运动。</p><p>坐标轴指示器也提供了一种适合触屏的交互方式，使用手柄来拖拽坐标轴指示器。如果触屏上和鼠标操作一样，在坐标系内部拖拽操作坐标轴指示器，那么手指可能会挡住图表，并且可能和『数据区域缩放移动』操作冲突。用单独的拖拽手柄，可以改善这个问题。</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=line-tooltip-touch&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div>这是另一个例子：<div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=candlestick-touch&amp;edit=1&amp;reset=1" style="width: 100%; height: 400px"></div><p>坐标轴指示器在多轴的场景能起到辅助作用，清晰得显示出对比数值，甚至可以在坐标轴指示器的文本标签内定制表达更多信息：</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=multiple-y-axis&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=multiple-x-axis&amp;edit=1&amp;reset=1" style="width: 100%; height: 300px"></div><p>最后提供一个内容更丰富些的例子，其中也使用了 [axisPointer.link](#axisPointer.link) 来联动不同的坐标轴指示器。他关联和高亮了处于不同坐标系中的相互对应的点。</p><div class="ec-lazy" data-thumb="http://echarts.baidu.com/gallery/data/thumb/bubble-gradient.png" data-src="http://echarts.baidu.com/gallery/view.html?c=scatter-nutrients-matrix&amp;edit=1&amp;reset=1" style="width: 100%; height: 640px"></div><script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script>(function () {    if (typeof jQuery === 'undefined') {        return;    }    var $ = jQuery;    var env = window['MD_ENV'];    var $ = jQuery;    var useThumb = env && (env.os.phone || env.os.tablet);    var blockList = $('.ec-lazy');    var $win = $(window);    blockList.each(function (index, block) {        block = $(block);        var src = block.attr('data-src');        block.attr('data-src', src);    });    // Lazy load.    $win.on('scroll', showBlock);    $(showBlock);    function initThumb(block, $block, blockThumb, blockSrc) {        $block.css('lineHeight', $block.height() + 'px');        block.innerHTML = [            '<img style="width:100%;height:auto;padding:0;vertical-align:middle;" src="', blockThumb, '"/>',            // for vertial middle            '<div style="vertical-align: middle; height: 100%; width: 0"></div>',            '<div style="cursor:pointer;thumb-btn;position:absolute;bottom:10px;width:100%;height:22px;line-height:22px;text-align:center;">',                '<em style="font-style:normal;border-radius:3px;padding:3px 5px;margin:3px 5px;color:white;background:#337ab7;font-size:12px;line-height:1.5;">点击图片加载真实图表</em>',            '</div>',            '<div class="ec-lazy-block-mask" style="cursor:pointer;position:absolute;left:0;top:0;width:100%;height:100%;"></div>'        ].join('');        $block.find('.ec-lazy-block-mask').on('click', function () {            initIFrame(block, $block, blockThumb, blockSrc);        });    }    function initIFrame(block, $block, blockThumb, blockSrc) {        block.innerHTML = [            '<iframe style="overflow:hidden;width:100%;height:100%;padding:0;" src="' , blockSrc, '">',            'frameborder="no" border="0" marginwidth="0" marginheight="0"',            'scrolling="no" hspace="0" vspace="0"></iframe>'        ].join('');    }    function showBlock() {        blockList.each(function (idx, block) {            var $block = $(block);            var blockSrc = $block.attr('data-src');            var blockThumb = $block.attr('data-thumb');            if (!blockSrc) {                return;            }            $block.css({                position: 'relative',                overflow: 'hidden',                textAlign: 'center',                padding: 0            });            var winScrollTop = $win.scrollTop();            var blockTop = block.offsetTop;            var winHeight = $win.height();            var winBottom = winScrollTop + winHeight;            var blockBottom = blockTop + $block.height();            if (winBottom >= blockTop && winBottom <= (blockBottom + winHeight)) {                $block.attr('data-src', '');                (useThumb && blockThumb)                    ? initThumb(block, $block, blockThumb, blockSrc)                    : initIFrame(block, $block, blockThumb, blockSrc);            }        });    }})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECharts 新发布的 &lt;a href=&quot;https://github.com/ecomfe/echarts/releases/tag/3.5.0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;3.5 版本&lt;/a&gt;中，新增了日历坐标系，增强了坐标轴指示器。同时，&lt;a href=&quot;https://github.com/ecomfe/echarts-stat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECharts 统计扩展&lt;/a&gt; 1.0 版本发布了。日历坐标系用于在日历中绘制图表，坐标轴指示器方便用户观察数据内容，统计扩展是一个专门用来进行数据分析的工具。&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;width:100%&quot; src=&quot;/blog/echarts-3-5-0/banner.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>可视化中的数据</title>
    <link href="http://efe.baidu.com/blog/echarts-dataAbstraction-tutorial/"/>
    <id>http://efe.baidu.com/blog/echarts-dataAbstraction-tutorial/</id>
    <published>2017-03-14T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>当下随着大数据热潮的到来，数据可视化作为一个新兴的领域，受到了学术界和工业界的重视。从可视分析、数据新闻到商业报表，各个领域都在越来越多的使用它。既然是数据可视化，说明数据是主体，可视化只是将数据以可视的形式表达的手段。接下来小编就与大家一起揭开可视化中数据的面纱，一探究竟。</p><a id="more"></a><h2 id="可视化什么数据抽象">可视化什么：数据抽象</h2><p>既然是数据可视化，无可非议，可视化的元素肯定是数据，这里所指的数据是广义上的数据，包括文本、图片、声音等超媒体数据。ECharts在可视化过程中所涉及的四种基本数据集类型分别是表格数据、网状数据、场数据和几何空间（spatial）数据，像集合、列表等也是常用的数据集类型。这些基本数据集类型又是由不同的数据类组合构成的，这里的数据类是指可视化中所涉及的数据种类，主要包括四种数据类，分别是数据项、数据项的属性、链接（links）、位置。数据项的属性又可分为类别型和有序型两种，其中有序型又进一步细分为序数型和数值型，下面将分别介绍数据类，数据集类型，以及属性类型。</p><h3 id="数据类">数据类</h3><p>本文主要讨论ECharts中所涉及的四种基本数据类，分别是数据项、数据项的属性、链接、位置。数据项是指一个独立的实体，如关系数据表中的一行，或网络中的一个节点；属性是数据项的某个可被观测的特性，如年龄，性别等；链接是指数据项之间的关系，该数据类型在网状关系型数据集中用的比较多；位置是地理空间数据类型，指代二维或三维空间中的某个具体位置；下图展示了四种不同的数据集类型所包含的数据类。</p><div class="figure"><img src="/blog/echarts-dataAbstraction-tutorial/echarts-dataAbstraction-tutorial-datatypes.png" alt="data"><p class="caption">data</p></div><h3 id="数据集类型">数据集类型</h3><p>数据集是指为了分析而收集的任何信息，数据集包括数据表，网状数据，场数据（本文主要关注信息可视化，而场数据主要应用于科学可视化，因而在此不作介绍）以及几何空间数据这四种基本类型，而现实世界中的数据集一般是由这四个基本类型中的一个或多个组合而成的。下图展示了四种不同数据集类型具体的内部结构。</p><div class="figure"><img src="/blog/echarts-dataAbstraction-tutorial/echarts-dataAbstraction-tutorial-dataset.png" alt="data"><p class="caption">data</p></div><h4 id="数据表">数据表</h4><p>数据表是常用的数据集形式，由行和列组成。对于简单的扁平表格来说，每一行代表一个数据项，每一列代表一个属性，表格中的每一个单元格是由行号和列号索引的，保存着某个数据项的某个属性值；多维数据表在数据仓库中用的比较多，具有复杂的结构以及复杂的索引机制，一般来说，简单扁平表格至多具有一个键属性（key attribute），而多维表格具有多个键属性。</p><h4 id="网状数据">网状数据</h4><p>网状数据主要用来表明数据项之间具有某种关系，在网状数据中数据项通常被称为节点，两个节点之间的关系被称为链接，也就是网络中的边，并且节点和链接都可以拥有与之相关联的属性。树是一种具有层次结构的特殊类型网络数据，与一般网络数据相比，树没有回路，每一个子节点都对应唯一的一个父节点。</p><h4 id="几何空间spatial数据">几何空间（spatial）数据</h4><p>几何空间结构数据通过明确的几何空间位置指定数据项的形状信息，这些数据项可以是空间中的点、一维的直线或曲线、二维的平面或区域，以及三维的立方体。空间数据在不同的度量尺度上具有层级结构。这种层级结构要么是原始数据集固有的，要么是从原始数据集派生出来的。 可视化中的数据主要以两种形式存在，一种是静态的数据文件，一种是动态的数据流。静态的数据文件是指可以同时获得完整的数据文件，而动态的数据流是指数据在不断的更新和变化。</p><h3 id="属性类型">属性类型</h3><p>属性类型主要分为类别型和有序型两种，有序型又可进一步分为序数型和数值型。有序型数据的排列方向有三种，分别是单向型，有公共零点的双向型，以及环状周期型，如下图所示，除此之外，属性也可能有层级结构。 类别型属性是指名称上的不同，属性的值之间没有明确的排序，例如喜欢的球类运动包括足球、篮球、排球等。虽然类别型属性内部没有明确的排序，但任意外部的排序机制可以被应用在类别型属性上，如将球类运动的名字按字母顺序排列。 有序型属性包括序数型属性和数值型属性，所有有序型属性都有隐含的排列顺序。对于序数型属性，如小中大，虽然我们不能对它进行完全的算术运算，但在属性的内部有明确定义的顺序，如大减去中并不是有意义的概念，但我们知道中介于大和小之间。数值属性与序数属性不同，它具有大小和量级的明确度量，并且支持算术比较，一般以整数和实数形式存在，如76米减去34米是个有意义的数值，并且它们之间的差是可以被度量的，像温度、高度、长度等都是数值属性。 有序型数据可以是单向的有序序列，比如人的年龄，只能往一个方向递增，也可以是有公共零点的对向序列，如温度。有序型数据也可以是环状周期的，如时间相关的属性。 在单个属性内部或者多个属性之间可能具有层级结构，如北京一年的交通事故数量，这是一个时间序列数据，具有时间属性，可以分层级聚合，可以分别按周、月、年聚合，在不同的时间聚合尺度下可能会发现数据集中有趣的模式。除了时间属性之外，地理空间数据也具有层级结构，如可以细分到省、市、县等。</p><div class="figure"><img src="/blog/echarts-dataAbstraction-tutorial/echarts-dataAbstraction-tutorial-attribute.png"></div><h2 id="总结">总结</h2><p>本文简要讨论了可视化中的数据，从数据的种类、数据集的类型以及属性的类型这三个角度阐述了可视化中需要可视表达的数据信息。</p><h4 id="参考文献">参考文献</h4><p>[1] Tamara Munzner.Visualization Analysis and Design. CRC Press, 2014.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当下随着大数据热潮的到来，数据可视化作为一个新兴的领域，受到了学术界和工业界的重视。从可视分析、数据新闻到商业报表，各个领域都在越来越多的使用它。既然是数据可视化，说明数据是主体，可视化只是将数据以可视的形式表达的手段。接下来小编就与大家一起揭开可视化中数据的面纱，一探究竟。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="教程" scheme="http://efe.baidu.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ECharts 水球图教程</title>
    <link href="http://efe.baidu.com/blog/echarts-liquidfill-chart-tutorial/"/>
    <id>http://efe.baidu.com/blog/echarts-liquidfill-chart-tutorial/</id>
    <published>2017-02-20T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>水球图是一种适合于展现单个百分比数据的图表类型，ECharts 的<a href="https://github.com/ecomfe/echarts-liquidfill" target="_blank" rel="noopener">水球图插件</a>使你能够通过非常简单的配置，实现酷炫的数据展示效果。</p><p><img src="/blog/echarts-liquidfill-chart-tutorial/echarts-liquidfill-chart-tutorial.gif" width="100%"></p><a id="more"></a><p>那么，今天我们就一起来学习一下，如何使用 ECharts 水球图。</p><h2 id="第一步引入-javascript-文件">第一步：引入 JavaScript 文件</h2><p>ECharts 的水球图是一个<em>插件</em>类型的图表。这意味着，在 ECharts 官网下载的完整版本将不包含水球图——这保证了不需要使用该图表的用户能够获得一个尽可能小的代码版本。使用时，需要在引入 <code>echarts.js</code> 之后，另外引入水球图对应的 <code>echarts-liquidfill.js</code>，可以在 <a href="https://github.com/ecomfe/echarts-liquidfill/tree/gh-pages/dist" target="_blank" rel="noopener">GitHub</a> 找到最新版本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"echarts-liquidfill.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 使用水球图的代码</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第二步指定-dom-元素作为图表容器">第二步：指定 DOM 元素作为图表容器</h2><p>和创建 ECharts 的其他图表一样，我们需要指定 DOM 中的一个有高度和宽度的元素作为图表的容器——也就是图表将会绘制的位置。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"liquidfill-chart"</span> <span class="attr">style</span>=<span class="string">"width=100%; height = 400px"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>传入该 DOM 元素，使用 ECharts 初始化图表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">'liquidfill-chart'</span>));</span><br></pre></td></tr></table></figure><h2 id="第三步设置水球图参数">第三步：设置水球图参数</h2><p>和其他 ECharts 图表一样，水球图提供将系列的 <code>type</code> 指定为 <code>'liquidFill'</code>（注意大小写）来表明这是一个水球图类型。</p><p>一个简单的配置项可以是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">chart.setOption(option);</span><br></pre></td></tr></table></figure><p>这样，就能得到文章开头的水球图效果了：</p><iframe style="width: 100%; height: 350px" src="http://gallery.echartsjs.com/view.html?cid=liquidfill-basic"></iframe><blockquote><p>如果发现图表没有正确显示，你可以检查以下几种可能：</p><ul><li>JS 文件是否正确加载；</li><li><code>echarts</code> 变量是否存在；</li><li>控制台是否报错（如果报错显示 <code>liquidFill</code> 系列不存在，则很可能 <code>echarts-liquidfill.js</code> 没有正确加载）；</li><li>DOM 元素在 <code>echarts.init</code> 的时候是否有高度和宽度。</li></ul></blockquote><p>可以发现，在上面的代码中，我们只指定了图表类型为 <code>'liquidFill'</code>，以及把数据设置为 <code>[0.6, 0.5, 0.4, 0.3]</code>（对应生成的四个波浪），而其他的参数都是预设的。</p><p>即使不配置很多参数，预设的参数也可以使你获得一个优雅的水球图效果。而如果有特定的需求，ECharts 水球图又支持非常高度定制的效果。下面我们具体说明如何定制化你的水球图。</p><h2 id="第四步定制化水球图">第四步：定制化水球图</h2><p>水球图支持非常高度定制化的需求，包括颜色（<code>color</code>）、大小（<code>radius</code>）、波的振幅（<code>amplitude</code>）、波长（<code>waveLength</code>）、相位（<code>phase</code>）、周期（<code>period</code>）、移动方向（<code>direction</code>）、形状（<code>shape</code>）、动画（<code>waveAnimation</code>）等等，完整的配置项参数参见<a href="https://github.com/ecomfe/echarts-liquidfill#api" target="_blank" rel="noopener">水球图 API</a>。文档有针对每个配置项的详细说明，这里我们来介绍一些重要的参数。</p><h3 id="形状与动画">形状与动画</h3><iframe style="width: 100%; height: 600px" src="http://gallery.echartsjs.com/view.html?cid=xry0tUfcBe"></iframe><p>除了默认的圆形（<code>'circle'</code>）水球图，还可以将 <code>shape</code> 设置为 ECharts <em>Symbol</em> 的其他类型：<code>'rect'</code>、<code>'roundRect'</code>、<code>'triangle'</code>、<code>'diamond'</code>、<code>'pin'</code>、<code>'arrow'</code>。甚至，使用 <code>'path://...'</code> 的形式，为其<a href="http://gallery.echartsjs.com/editor.html?c=liquidfill-echarts" target="_blank" rel="noopener">指定一个 SVG 路径</a>，得到非常酷炫的效果：</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=liquidfill-echarts"></iframe><p>通过将 <code>direction</code> 设为 <code>'left'</code> 或 <code>'right'</code>，指定波浪的移动方向，或者设为 <code>'none'</code> 表示静止。</p><p>上面的例子完整的配置项代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run at: http://gallery.echartsjs.com/editor.html?c=xry0tUfcBe</span></span><br><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        radius: <span class="string">'40%'</span>,</span><br><span class="line">        shape: <span class="string">'diamond'</span>,</span><br><span class="line">        center: [<span class="string">'25%'</span>, <span class="string">'25%'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        direction: <span class="string">'left'</span>,</span><br><span class="line">        radius: <span class="string">'40%'</span>,</span><br><span class="line">        shape: <span class="string">'rect'</span>,</span><br><span class="line">        center: [<span class="string">'75%'</span>, <span class="string">'25%'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        radius: <span class="string">'40%'</span>,</span><br><span class="line">        shape: <span class="string">'roundRect'</span>,</span><br><span class="line">        center: [<span class="string">'25%'</span>, <span class="string">'75%'</span>],</span><br><span class="line">        backgroundStyle: &#123;</span><br><span class="line">            borderColor: <span class="string">'#156ACF'</span>,</span><br><span class="line">            borderWidth: <span class="number">1</span>,</span><br><span class="line">            shadowColor: <span class="string">'rgba(0, 0, 0, 0.4)'</span>,</span><br><span class="line">            shadowBlur: <span class="number">20</span></span><br><span class="line">        &#125;,</span><br><span class="line">        outline: &#123;</span><br><span class="line">            show: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        waveAnimation: <span class="literal">false</span>, <span class="comment">// 禁止左右波动</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        radius: <span class="string">'50%'</span>,</span><br><span class="line">        shape: <span class="string">'pin'</span>,</span><br><span class="line">        center: [<span class="string">'75%'</span>, <span class="string">'75%'</span>],</span><br><span class="line">        amplitude: <span class="number">0</span>,</span><br><span class="line">        waveAnimation: <span class="literal">false</span>,</span><br><span class="line">        outline: &#123;</span><br><span class="line">            show: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        backgroundStyle: &#123;</span><br><span class="line">            shadowColor: <span class="string">'rgba(0, 0, 0, 0.4)'</span>,</span><br><span class="line">            shadowBlur: <span class="number">20</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单个波的配置">单个波的配置</h3><p>除了对所有水波做的设置之外，每个水波可以进行单独的配置。和 ECharts 的其他配置项一样，对单个数据的配置项将覆盖整个系列的配置项。</p><iframe style="width: 100%; height: 350px" src="http://gallery.echartsjs.com/view.html?cid=xry6CHNCVl"></iframe><p>在这个例子中，我们将第二条水波设为红色，并且改变其移动方向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, &#123;</span><br><span class="line">            value: <span class="number">0.5</span>,</span><br><span class="line">            direction: <span class="string">'left'</span>,</span><br><span class="line">            itemStyle: &#123;</span><br><span class="line">                normal: &#123;</span><br><span class="line">                    color: <span class="string">'red'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0.4</span>, <span class="number">0.3</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，原先 <code>data</code> 中的一项是一个数字，而在需要做特殊定制的数据中，我们将其设置为一个对象，<code>value</code> 值是原先的数字，其他配置项将覆盖系列配置项的值。</p><h3 id="文字显示">文字显示</h3><p>水球图中间的文字有个酷炫的效果，在水波和背景前的文字颜色是不同的，可以通过 <code>insideColor</code> 设置水波处的文字颜色，<code>color</code> 设置背景处的文字颜色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        radius: <span class="string">'80%'</span>,</span><br><span class="line">        data: [<span class="number">0.5</span>, <span class="number">0.45</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        label: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                    color: <span class="string">'red'</span>,</span><br><span class="line">                    insideColor: <span class="string">'yellow'</span>,</span><br><span class="line">                    fontSize: <span class="number">50</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><iframe style="width: 100%; height: 350px" src="http://gallery.echartsjs.com/view.html?cid=xHyUvV_tFe"></iframe><p>图表中间默认显示百分比数据，如果你需要将其设置为其他文字内容，可以通过 <code>formatter</code> 指定，这与 ECharts 的其他格式化函数也是相同的。</p><p><code>formatter</code> 可以是一个字符串，其中 <code>'{a}'</code>、<code>'{b}'</code>、<code>'{c}'</code> 会被分别替换成系列名称、数据名称、数据值。</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        name: <span class="string">'Liquid Fill'</span>,</span><br><span class="line">        data: [&#123;</span><br><span class="line">            name: <span class="string">'First Data'</span>,</span><br><span class="line">            value: <span class="number">0.6</span></span><br><span class="line">        &#125;, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>],</span><br><span class="line">        label: &#123;</span><br><span class="line">            normal: &#123;</span><br><span class="line">                formatter: <span class="string">'&#123;a&#125;\n&#123;b&#125;\nValue: &#123;c&#125;'</span>,</span><br><span class="line">                textStyle: &#123;</span><br><span class="line">                    fontSize: <span class="number">28</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><iframe style="width: 100%; height: 350px" src="http://gallery.echartsjs.com/view.html?cid=xHk5831cHg"></iframe><p>此外，<code>formatter</code> 也可以是一个函数，以下代码能得到和上面字符串形式同样的效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">formatter: <span class="function"><span class="keyword">function</span>(<span class="params">param</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param.seriesName + <span class="string">'\n'</span></span><br><span class="line">        + param.name + <span class="string">'\n'</span></span><br><span class="line">        + <span class="string">'Value:'</span> + param.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结">小结</h2><p>以上，我们介绍了 ECharts 水球图的一些基本用法，希望能够给大家启发，创作出更多波涛汹涌的作品。</p><p>更完整的配置项请参考 GitHub 上<a href="https://github.com/ecomfe/echarts-liquidfill" target="_blank" rel="noopener">详细的文档</a>，或者到 ECharts Gallery 上查看其它<a href="http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~query=liquidFill~author=all" target="_blank" rel="noopener">水球图作品</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;水球图是一种适合于展现单个百分比数据的图表类型，ECharts 的&lt;a href=&quot;https://github.com/ecomfe/echarts-liquidfill&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;水球图插件&lt;/a&gt;使你能够通过非常简单的配置，实现酷炫的数据展示效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-liquidfill-chart-tutorial/echarts-liquidfill-chart-tutorial.gif&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="教程" scheme="http://efe.baidu.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="水球图" scheme="http://efe.baidu.com/tags/%E6%B0%B4%E7%90%83%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>ECharts 3.4 版本发布：新增象形柱图、主题河流图、水球图</title>
    <link href="http://efe.baidu.com/blog/echarts-3-4-0/"/>
    <id>http://efe.baidu.com/blog/echarts-3-4-0/</id>
    <published>2017-01-12T16:00:00.000Z</published>
    <updated>2017-06-29T08:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECharts 新发布的 3.4 版本中，新增象形柱图、主题河流图、水球图三种新图表。象形柱图利用图片和形状表现数据，主题河流图可以用来表示事件或主题等在一段时间内变化，水球图常用来展现百分比数据。</p><p><img src="/blog/echarts-3-4-0/new-release-theme-river.png" width="100%"></p><a id="more"></a><h2 id="象形柱图">象形柱图</h2><p>象形柱图是可以设置各种具象图形元素（如图片、<a href="http://www.w3.org/TR/SVG/paths.html#PathData" target="_blank" rel="noopener">SVG PathData</a> 等）的柱状图。往往用在信息图中，用于有至少一个类目轴或时间轴的<a href="http://echarts.baidu.com/option.html#grid" target="_blank" rel="noopener">直角坐标系</a>上。</p><p>它既可以用图形的长宽变形表现数据，也可以用图形的个数、甚至是图形的颜色、透明度变化表现数据。</p><p>在下面的例子中，右边的两座山分别是一个图片，而最左侧的纸是由多个图片堆加成的，象形柱图会根据它们所在系列对应的数值，决定其高度。配合动画效果，能够实现很好的视觉效果。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=pictorialBar-hill"></iframe><p>在 <a href="http://jing.baidu.com/h5/echarts-christmas-2016.html" target="_blank" rel="noopener">ECharts 圣诞活动页</a>中，我们制作了以下这个驯鹿和交通方式的速度对比图，这样的图表可以使用 ECharts 象形柱图方便地实现。下图包含两个系列，一个是显示在上方的交通方式矢量图标，象形柱图默认会将每个图标放在对应值所在位置的下方，通过 <code>symbolSize</code> 指定图标大小；另一个系列是显示在图标下方的山峰，在不指定 <code>symbolSize</code> 的情况下，将填充满所在的“柱子”，因而就有了图示效果。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=pictorialBar-velocity"></iframe><p>除此之外，象形柱图还可以用同一图形的个数表现数值，实现类似 ECharts 圣诞活动页中一群小精灵的效果。因而象形柱图可以很大程度上满足信息图的制图需求。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=pictorialBar-spirit"></iframe><p>从 3.4 版本起，象形柱图将被包含在 <a href="http://echarts.baidu.com/download.html" target="_blank" rel="noopener">ECharts 下载页面</a>的“完整”版本中，无需引入额外文件，通过将系列名称设为 <code>pictorialBar</code> 即可使用。</p><p>更多例子请前往<a href="http://echarts.baidu.com/examples.html#chart-type-pictorialBar" target="_blank" rel="noopener">官网例子</a>查看。</p><h2 id="主题河流图">主题河流图</h2><p>主题河流图是一种特殊的流图，它主要用来表示事件或主题等在一段时间内的变化。</p><p>主题河流中不同颜色的条带状河流分支编码了不同的事件或主题，河流分支的宽度编码了原数据集中的 <code>value</code> 值。此外，原数据集中的时间属性，映射到单个时间轴上。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=themeRiver-basic"></iframe><p>图中的每一个系列，可以是一个产品市场占有率的变化，也可以表示国家人口的变化等等事件或主题。</p><p>更多例子请前往<a href="http://echarts.baidu.com/examples.html#chart-type-themeRiver" target="_blank" rel="noopener">官网例子</a>查看。</p><h2 id="水球图">水球图</h2><p>水球图的使用方式非常简单，实现以下这样的效果，只需要将系列类型设为 <code>liquidFill</code>，并且指定数据即可。</p><iframe style="width: 100%; height: 300px" src="http://gallery.echartsjs.com/view.html?cid=liquidfill-basic"></iframe><p>对应的代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    series: [&#123;</span><br><span class="line">        type: <span class="string">'liquidFill'</span>,</span><br><span class="line">        data: [<span class="number">0.6</span>, <span class="number">0.5</span>, <span class="number">0.4</span>, <span class="number">0.3</span>]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>水球图的个性化程度非常高，你可以为每个波指定波长、周期、相位、颜色、阴影、透明度等等属性，“水球”的形状可以是圆形、方形、三角形等等，甚至可以指定任意的 <a href="http://www.w3.org/TR/SVG/paths.html#PathData" target="_blank" rel="noopener">SVG PathData</a>，因此可以制作出变化非常的效果。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=liquidfill-echarts"></iframe><p>我们在 ECharts 圣诞主题页实现的雪球下降的效果，即是用水球图实现的。</p><iframe style="width: 100%; height: 400px" src="http://gallery.echartsjs.com/view.html?cid=christmas-gift-show"></iframe><p>和象形柱图、主题河流图不同的是，水球图是作为插件发布的。这意味着，在 ECharts 官网下载的完整版本将不包含水球图，使用时，需要在引入 <code>echarts.js</code> 之后，另外引入水球图对应的 <code>echarts-liquidfill.js</code>，可以在 <a href="https://github.com/ecomfe/echarts-liquidfill/tree/gh-pages/dist" target="_blank" rel="noopener">GitHub</a> 找到最新版本。</p><p>如果感兴趣的话，可以前往<a href="https://github.com/ecomfe/echarts-liquidfill" target="_blank" rel="noopener">水球图 GitHub 项目页面</a>了解更多，或者在 <a href="http://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~query=liquidfill~author=all" target="_blank" rel="noopener">Gallery</a> 页面查看更多效果。</p><h2 id="其他更新内容">其他更新内容</h2><ul><li><p>[+] [map series](http://echarts.baidu.com/option.html#series-map) 可以使用用户指定的 <a href="http://echarts.baidu.com/option.html#geo" target="_blank" rel="noopener">geo 坐标系</a> 了（原先是只能使用内置的 geo 坐标系）。从而，geo 坐标系可以使用 <a href="http://echarts.baidu.com/option.html#series-map" target="_blank" rel="noopener">map series</a> 控制自身的颜色，并且 <a href="http://echarts.baidu.com/option.html#series-map" target="_blank" rel="noopener">map series</a> 可以和其他类型的 series（如 <a href="http://echarts.baidu.com/option.html#series-scatter" target="_blank" rel="noopener">scatter series</a>）共享 geo 坐标系。参见 <a href="http://echarts.baidu.com/option.html#series-map.geoIndex" target="_blank" rel="noopener">series-map.geoIndex</a>。</p></li><li><p>[+] 增加了 <a href="http://echarts.baidu.com/api.html#action.graph.focusNodeAdjacency" target="_blank" rel="noopener">focusNodeAdjacency action</a>，从而能用 API 控制 <a href="http://echarts.baidu.com/option.html#series-geo" target="_blank" rel="noopener">graph</a> 的连接高亮。</p></li><li><p>[+] 增加了 <a href="http://echarts.baidu.com/option.html#series-pie.animationType" target="_blank" rel="noopener">series-pie.animationType</a>，支持不同的饼图动画效果。</p></li><li><p>[+] [animationDuration](http://echarts.baidu.com/option.html#animationDuration) 增加了回调函数支持，可以根据不同的数据项得到不同的动画时长。</p></li><li><p>[+] [category axis](http://echarts.baidu.com/option.html#xAxis.type) 支持了 <a href="http://echarts.baidu.com/option.html#xAxis.min" target="_blank" rel="noopener">min</a> <a href="http://echarts.baidu.com/option.html#xAxis.max" target="_blank" rel="noopener">max</a> 的设置。</p></li><li><p>[+] [category axis](http://echarts.baidu.com/option.html#xAxis.type) 默认情况会显示所有的类目，不论是否有类目中没有数据（原先两端的没有数据的类目不会被显示）。</p></li><li><p>[+] [singleAxis](http://echarts.baidu.com/option.html#singleAxis) 中的 <code>data</code> 支持了一维数组的数据格式，如 <code>[11, 23, 44]</code>。</p></li><li><p>[+] [dataZoom](http://echarts.baidu.com/option.html#dataZoom) 支持了 <a href="http://echarts.baidu.com/option.html#singleAxis" target="_blank" rel="noopener">singleAxis</a>。</p></li><li><p>[+] 开放了 throttle 工具方法：<code>chart.util.throttle</code>。</p></li><li><p>[+] 优化了 <a href="http://echarts.baidu.com/option.html#grid" target="_blank" rel="noopener">直角坐标系</a> 中数据全不显示时的显示效果。</p></li><li><p>[+] [K 线图](http://echarts.baidu.com/option.html#series-candlestick) 支持了 <a href="http://echarts.baidu.com/option.html#series-candlestick.barWidth" target="_blank" rel="noopener">barWidth</a>，<a href="http://echarts.baidu.com/option.html#series-candlestick.barMinWidth" target="_blank" rel="noopener">barMinWidth</a>，<a href="http://echarts.baidu.com/option.html#series-candlestick.barMaxWidth" target="_blank" rel="noopener">barMaxWidth</a> 设置。参见 <a href="https://github.com/ecomfe/echarts/issues/4783" target="_blank" rel="noopener">#4783</a>。</p></li><li><p>[+] [线图](http://echarts.baidu.com/option.html#series-lines) 支持了 <a href="http://echarts.baidu.com/option.html#series-lines.symbol" target="_blank" rel="noopener">symbol</a>, <a href="http://echarts.baidu.com/option.html#series-lines.symbolSize" target="_blank" rel="noopener">symbolSize</a> 设置。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#visualMap-piecewise" target="_blank" rel="noopener">visualMap-piecewise</a> 中数据标签和首尾的文本同时显示。参见 <a href="http://echarts.baidu.com/option.html#visualMap-piecewise.showLabel" target="_blank" rel="noopener">visualMap-piecewise.showLabel</a> 参见 <a href="https://github.com/ecomfe/echarts/issues/4845" target="_blank" rel="noopener">#4845</a>。</p></li><li><p>[+] 支持了 <a href="http://echarts.baidu.com/option.html#visualMap" target="_blank" rel="noopener">visualMap</a> 支持系列中的某些数据不受 <code>visualMap</code> 控制。</p></li><li><p>[^] 在 <a href="http://echarts.baidu.com/api.html#action.tooltip.showTip" target="_blank" rel="noopener">showTip</a> 事件中开放了 <code>dataIndex</code> 参数。</p></li><li><p>[^] 修复了 tooltip 中的 XSS 隐患。参见 <a href="https://github.com/ecomfe/echarts/issues/4769" target="_blank" rel="noopener">#4769</a>。</p></li><li><p>[^] 修复了 <a href="http://echarts.baidu.com/option.html#series-graph.edgeLabel" target="_blank" rel="noopener">series-graph.edgeLabel</a> 中部分属性无效的问题。参见 <a href="https://github.com/ecomfe/echarts/issues/4555" target="_blank" rel="noopener">#4555</a>。</p></li><li><p>[^] 修复了 <a href="http://echarts.baidu.com/option.html#series-gauge" target="_blank" rel="noopener">series-gauge</a> 中 <code>min</code> <code>max</code> 是 <code>stirng</code> 时的 tick 渲染问题。参见 <a href="https://github.com/ecomfe/echarts/issues/4617" target="_blank" rel="noopener">#4617</a>。</p></li><li><p>[^] 修复了 <a href="http://echarts.baidu.com/option.html#series-gauge.pointer.show" target="_blank" rel="noopener">series-gauge.pointer.show</a> 的问题。参见 <a href="https://github.com/ecomfe/echarts/issues/4618" target="_blank" rel="noopener">#4618</a>。</p></li><li><p>[^] 修复了 <a href="http://echarts.baidu.com/option.html#series-radar" target="_blank" rel="noopener">series-radar</a> 在无数据时渲染可能抛错的问题。</p></li><li><p>[^] 修复了 <a href="http://echarts.baidu.com/option.html#series-line.markArea.label.normal.show" target="_blank" rel="noopener">markArea.label.normal.show</a> 的问题。参见 <a href="https://github.com/ecomfe/echarts/issues/4723" target="_blank" rel="noopener">#4723</a>。</p></li><li><p>[^] 优化了 <a href="http://echarts.baidu.com/option.html#yAxis.type" target="_blank" rel="noopener">log 数轴</a> 中，数据小于等于 0 时的处理。参见 <a href="https://github.com/ecomfe/echarts/issues/4743" target="_blank" rel="noopener">#4743</a> 和 <a href="https://github.com/ecomfe/echarts/issues/3161" target="_blank" rel="noopener">#3161</a>。</p></li></ul><p><strong>欢迎前往 <a href="http://gallery.echartsjs.com/explore.html" target="_blank" rel="noopener">ECharts Gallery</a> 创建自己的 ECharts 图表，更方便地提问，以及建立自己的作品集。2017 年，让我们一起将可视化做得更棒！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ECharts 新发布的 3.4 版本中，新增象形柱图、主题河流图、水球图三种新图表。象形柱图利用图片和形状表现数据，主题河流图可以用来表示事件或主题等在一段时间内变化，水球图常用来展现百分比数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/echarts-3-4-0/new-release-theme-river.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据可视化" scheme="http://efe.baidu.com/tags/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
      <category term="ECharts" scheme="http://efe.baidu.com/tags/ECharts/"/>
    
      <category term="新版本" scheme="http://efe.baidu.com/tags/%E6%96%B0%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
</feed>
